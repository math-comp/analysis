(* mathcomp analysis (c) 2017 Inria and AIST. License: CeCILL-C.              *)
From mathcomp Require Import all_ssreflect.
From mathcomp Require Import ssralg ssrnum ssrint.
From mathcomp Require Import finmap.
Require Import boolp reals ereal classical_sets posnum nngnum topology.
Require Import normedtype.
From HB Require Import structures.
Require Import sequences measure csum cardinality.

(******************************************************************************)
(*                           measure.v cont'd                                 *)
(*                (Extension theorem and Lebesgue measure)                    *)
(*                                                                            *)
(* Extension theorem:                                                         *)
(* measurable_cover X == the set of sequences F such that                     *)
(*                       - forall i, F i is measurable                        *)
(*                       - X `<=` \bigcup_i (F i)                             *)
(*          mu_ext mu == the extension of the measure mu, a measure over a    *)
(*                       ring of sets; it is an outer measure, declared as    *)
(*                       canonical (i.e., we have the notation                *)
(*                       [outer_measure of mu_ext mu])                        *)
(*                                                                            *)
(*     s<< G >> == sigma-algebra generated by G                               *)
(*     dynkin S == S is a Dynkin system                                       *)
(*    gdynkin G == Dynkin system generated by G, notation: d<< G >>           *)
(*  Hahn_ext mu == extension of the measure mu over a ring of sets to         *)
(*                 a measure of the generated sigma algebra                   *)
(*                                                                            *)
(* set_of_itv i == the set of x such that x \in i where i is an interval      *)
(*   itv_cplt s == complement of the list of intervals s                      *)
(* itv_diff i j == i \ j where i and j are intervals assuming ~ j <= i        *)
(*   lt_itv i j == total ordering of intervals: the left bound of i is        *)
(*                 smaller than the one of j, and if it is equal then the     *)
(*                 right bound of i is smaller than the one of j              *)
(*                                                                            *)
(*  decompose s == turn a sequence of intervals into a sequence of            *)
(*                 non-overlapping intervals with the same cover              *)
(*                                                                            *)
(*  [sset of s] == the finite unions of the sequence of intervals s           *)
(*                 (a "simple set")                                           *)
(*  Module Sset == simple sets form an algebra of sets                        *)
(*                                                                            *)
(*    hlength A == length of the hull of the set of real numbers A            *)
(* Lemma hlengthUitv == hlength is additive on intervals                      *)
(*                                                                            *)
(* slength X == measure of the set X when it is a simple set, and 0 o.w.      *)
(* ccitv n == [-n, n] interval                                                *)
(* slength_sigma_finite == slength is sigma-finite                            *)
(*                                                                            *)
(* Section slength_additive:                                                  *)
(*   This section establishes that slength is additive on simple sets.        *)
(*   Lemma:                                                                   *)
(*     slength_additive                                                       *)
(* Section slength_sigma_additive_on_intervals:                               *)
(*   This section established that slength is sigma-additive on intervals     *)
(*   seen as simple sets. Lemmas:                                             *)
(*     slength_sigma_subadditive_on_finite_intervals                          *)
(*     slength_sigma_additive_on_finite_intervals                             *)
(*     slength_sigma_subadditive_on_infinite_intervals                        *)
(*     slength_sigma_subadditive_on_intervals                                 *)
(*     slength_sigma_additive_on_intervals                                    *)
(* Section addressing_sequence_of_simple_sets:                                *)
(*   reindexing                                                               *)
(* Section slength_measure:                                                   *)
(*   slength_semi_sigma_additive                                              *)
(*                                                                            *)
(* length == Lebesgue measure                                                 *)
(*                                                                            *)
(******************************************************************************)

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.
Import Order.TTheory GRing.Theory Num.Def Num.Theory.

Local Open Scope classical_set_scope.
Local Open Scope ring_scope.
Local Open Scope ereal_scope.

(* NB: PR in progress *)
(* TODO: remove when available in all the Coq versions supported by the CI
   (as of today, only in Coq 8.13) *)
Definition uncurry {A B C:Type} (f:A -> B -> C)
  (p:A * B) : C := match p with (x, y) => f x y end.

Lemma adde_def_nneg_series (R : realType) (f g : (\bar R)^nat) (P Q : pred nat) :
  (forall n, P n -> 0 <= f n) -> (forall n, Q n -> 0 <= g n) ->
  adde_def (\sum_(i <oo | P i) f i) (\sum_(i <oo | Q i) g i).
Proof.
move=> f0 g0; rewrite /adde_def !negb_and; apply/andP; split.
- apply/orP; right; apply/eqP => Qg.
  by have := ereal_nneg_series_lim_ge0 g0; rewrite Qg.
- apply/orP; left; apply/eqP => Pf.
  by have := ereal_nneg_series_lim_ge0 f0; rewrite Pf.
Qed.

(* PR 395 in progress *)
Lemma cvg_geometric_series_half (R : archiFieldType) (r : R) n :
  series (fun k => r / (2 ^ (k + n.+1))%:R : R^o) --> (r / 2 ^+ n : R^o).
Proof.
rewrite (_ : series _ = series (geometric (r / (2 ^ n.+1)%:R) 2^-1%R)); last first.
  rewrite funeqE => m; rewrite /series /=; apply eq_bigr => k _.
  by rewrite expnD natrM (mulrC (2 ^ k)%:R) invfM exprVn (natrX _ 2 k) mulrA.
apply: cvg_trans.
  apply: cvg_geometric_series.
  by rewrite ger0_norm // invr_lt1 // ?ltr1n // unitfE.
rewrite [X in (X - _)%R](splitr 1) div1r addrK.
by rewrite -mulrA -invfM expnSr natrM -mulrA divff// mulr1 natrX.
Qed.
Arguments cvg_geometric_series_half {R} _ _.

Lemma epsilon_trick (R : realType) (A : (\bar R)^nat) (e : {nonneg R})
    (P : pred nat) : (forall n, 0 <= A n) ->
  \sum_(i <oo | P i) (A i + (e%:nngnum / (2 ^ i.+1)%:R)%:E) <=
  \sum_(i <oo | P i) A i + e%:nngnum%:E.
Proof.
move=> A0; rewrite (@le_trans _ _ (lim (fun n => (\sum_(0 <= i < n | P i) A i) +
    \sum_(0 <= i < n) (e%:nngnum / (2 ^ i.+1)%:R)%:E))) //.
  rewrite ereal_pseriesD //; last by move=> n _; apply: divr_ge0.
  rewrite ereal_limD //.
  - rewrite lee_add2l //; apply: lee_lim => //.
    + by apply: is_cvg_ereal_nneg_series => n _; apply: divr_ge0.
    + by apply: is_cvg_ereal_nneg_series => n _; apply: divr_ge0.
    + by near=> n; apply: lee_sum_nneg_subset => // i _; apply divr_ge0.
  - exact: is_cvg_ereal_nneg_series.
  - by apply: is_cvg_ereal_nneg_series => n _; apply: divr_ge0.
  - by apply: adde_def_nneg_series => // n _; apply: divr_ge0.
suff cvggeo : (fun n => \sum_(0 <= i < n) (e%:nngnum / (2 ^ i.+1)%:R)%:E) -->
    e%:nngnum%:E.
  rewrite ereal_limD //.
  - by rewrite lee_add2l // (cvg_lim _ cvggeo).
  - exact: is_cvg_ereal_nneg_series.
  - by apply: is_cvg_ereal_nneg_series => ?; rewrite lee_fin divr_ge0.
  - by rewrite (cvg_lim _ cvggeo) //= fin_num_adde_def.
rewrite (_ : (fun n => _) = @EFin _ \o
    (fun n => \sum_(0 <= i < n) (e%:nngnum / (2 ^ (i + 1))%:R))%R); last first.
  rewrite funeqE => n /=; rewrite (@big_morph _ _ (@EFin _) 0 adde)//.
  by under [in RHS]eq_bigr do rewrite addn1.
apply: cvg_comp; last apply cvg_refl.
have := cvg_geometric_series_half e%:nngnum O.
by rewrite expr0 divr1; apply: cvg_trans.
Grab Existential Variables. all: end_near. Qed.
(* /PR 395 in progress *)

Section measurable_cover.
Variable T : ringOfSetsType.
Implicit Types (X : set T) (F : (set T)^nat).

Definition measurable_cover X := [set F : (set T)^nat |
  (forall i, measurable (F i)) /\ X `<=` \bigcup_k (F k)].

Lemma cover_measurable X F : measurable_cover X F -> forall k, measurable (F k).
Proof. by move=> + k; rewrite /measurable_cover => -[] /(_ k). Qed.

Lemma cover_subset X F : measurable_cover X F -> X `<=` \bigcup_k (F k).
Proof. by case. Qed.

End measurable_cover.

Section measure_extension.
Variables (R : realType) (T : ringOfSetsType) (mu : {measure set T -> \bar R}).

Definition mu_ext (X : set T) : \bar R :=
  ereal_inf [set \sum_(i <oo) mu (A i) | A in measurable_cover X].

Lemma le_mu_ext : {homo mu_ext : A B / A `<=` B >-> A <= B}.
Proof.
move=> A B AB; apply/le_ereal_inf => x [B' [mB' BB']].
by move=> <-{x}; exists B' => //; split => //; apply: subset_trans AB BB'.
Qed.

Lemma mu_ext_ge0 A : 0%E <= mu_ext A.
Proof.
apply: lb_ereal_inf => x [B [mB AB] <-{x}]; rewrite ereal_lim_ge //=.
  by apply: is_cvg_ereal_nneg_series => // n _; exact: measure_ge0.
by near=> n; rewrite sume_ge0 // => i _; apply: measure_ge0.
Grab Existential Variables. all: end_near. Qed.

Lemma mu_ext0 : mu_ext set0 = 0%E.
Proof.
apply/eqP; rewrite eq_le; apply/andP; split; last first.
  by apply: mu_ext_ge0; exact: measurable0.
rewrite /mu_ext; apply ereal_inf_lb; exists (fun _ => set0).
  by split => // _; exact: measurable0.
by apply: (@lim_near_cst _ _ _ _ _ 0%E) => //; near=> n => /=; rewrite big1.
Grab Existential Variables. all: end_near. Qed.

Lemma measurable_uncurry (G : ((set T)^nat)^nat) (x : nat * nat) :
  measurable (G x.1 x.2) -> measurable (uncurry G x).
Proof. by case: x. Qed.

Lemma mu_ext_sigma_subadditive : sigma_subadditive mu_ext.
Proof.
move=> A; have [[i ioo]|] := pselect (exists i, mu_ext (A i) = +oo).
  rewrite (ereal_nneg_series_pinfty _ _ ioo)// ?lee_pinfty// => n _.
  exact: mu_ext_ge0.
rewrite -forallNE => Aoo.
suff add2e : forall e : {posnum R},
    mu_ext (\bigcup_n A n) <= \sum_(i <oo) mu_ext (A i) + e%:num%:E.
  apply lee_adde => e.
  by rewrite -(mul1r e%:num) -(@divff _ 2%:R)// -mulrAC -mulrA add2e.
move=> e; rewrite (le_trans _ (epsilon_trick _ _ _))//; last first.
  by move=> n; apply: mu_ext_ge0.
pose P n (B : (set T)^nat) := measurable_cover (A n) B /\
  \sum_(k <oo) mu (B k) <= mu_ext (A n) + (e%:num / (2 ^ n.+1)%:R)%:E.
have [G PG] : {G : ((set T)^nat)^nat & forall n, P n (G n)}.
  apply: (@choice _ _ P) => n; rewrite /P /mu_ext.
  set S := (X in ereal_inf X); move infS : (ereal_inf S) => iS.
  case: iS infS => [r Sr|Soo|Soo].
  - have en1 : (0 < e%:num / (2 ^ n.+1)%:R)%R.
      by rewrite divr_gt0 // ltr0n expn_gt0.
    have [x [[B [mB AnB muBx]] xS]] := lb_ereal_inf_adherent (PosNum en1) Sr.
    exists B; split => //; rewrite muBx -Sr; apply/ltW.
    by rewrite (lt_le_trans xS) // lee_add2l //= lee_fin ler_pmul.
  - by have := Aoo n; rewrite /mu_ext Soo.
  - suff : lbound S 0%E by move/lb_ereal_inf; rewrite Soo.
    move=> /= _ [B [mB AnB] <-].
    by apply: ereal_nneg_series_lim_ge0 => ? _; exact: measure_ge0.
have muG_ge0 : forall x, 0%E <= (mu \o uncurry G) x.
  by move=> x; apply/measure_ge0/measurable_uncurry/(PG x.1).1.1.
apply (@le_trans _ _ (\csum_(i in setT) (mu \o uncurry G) i)).
  rewrite /mu_ext; apply ereal_inf_lb.
  have [f [Tf fi]] : exists e, enumeration (@setT (nat * nat)) e /\ injective e.
    have /countable_enumeration [|[f ef]] := countable_prod_nat.
      by rewrite predeqE => /(_ (0%N, 0%N)) [] /(_ Logic.I).
    by exists (enum_wo_rep infinite_prod_nat ef); split;
     [exact: enumeration_enum_wo_rep | exact: injective_enum_wo_rep].
  exists (uncurry G \o f).
    split => [i|]; first exact/measurable_uncurry/(PG (f i).1).1.1.
    apply: (@subset_trans _  (\bigcup_n \bigcup_k G n k)) => [t [i _]|].
      by move=> /(cover_subset (PG i).1) -[j _ ?]; exists i => //; exists j.
    move=> t [i _ [j _ Bijt]].
    have [k fkij] : exists k, f k = (i, j).
      by have : setT (i, j) by []; rewrite Tf => -[k _ fkij]; exists k.
    by exists k => //=; rewrite fkij.
  rewrite -(@csum_image _ _ (mu \o uncurry G) _ xpredT) //; congr csum.
  by rewrite Tf predeqE=> -[a b]; split=> -[n _ <-]; exists n.
rewrite (_ : csum _ _ = \sum_(i <oo) \sum_(j <oo ) mu (G i j)); last first.
  pose J : nat -> set (nat * nat) := fun i => [set (i, j) | j in setT].
  rewrite (_ : setT = \bigcup_k J k); last first.
    by rewrite predeqE => -[a b]; split => // _; exists a => //; exists b.
  rewrite csum_bigcup /=; last 3 first.
    - by move=> k; exists (k, O), O.
    - apply/trivIsetP => i j _ _ ij.
      rewrite predeqE => -[n m] /=; split => //= -[] [_] _ [<-{n} _].
      by move=> [m' _] [] /esym/eqP; rewrite (negbTE ij).
    - by move=> /= [n m]; apply/measure_ge0; exact: (cover_measurable (PG n).1).
  rewrite (_ : setT = id @` xpredT); last first.
    by rewrite image_id funeqE => x; rewrite trueE.
  rewrite csum_image //; last by move=> n _; apply: csum_ge0.
  apply eq_ereal_pseries => /= j.
  pose x_j : nat -> nat * nat := fun y => (j, y).
  have [enux injx] : enumeration (J j) x_j /\ injective x_j.
    by split => [|x y [] //]; rewrite /enumeration predeqE=> -[? ?]; split.
  rewrite -(@csum_image R _ (mu \o uncurry G) x_j predT) //=; last first.
    by move=> x _; move: (muG_ge0 (j, x)).
  by congr csum; rewrite predeqE => -[a b]; split; move=> [i _ <-]; exists i.
apply lee_lim.
- apply: is_cvg_ereal_nneg_series => n _.
  by apply: ereal_nneg_series_lim_ge0 => m _; exact: (muG_ge0 (n, m)).
- by apply: is_cvg_ereal_nneg_series => n _; apply: adde_ge0 => //;
    [exact: mu_ext_ge0 | rewrite lee_fin // divr_ge0 // ler0n].
- by near=> n; apply: lee_sum => i _; exact: (PG i).2.
Grab Existential Variables. all: end_near. Qed.

End measure_extension.

Canonical outer_measure_of_measure (R : realType) (T : ringOfSetsType)
  (mu : {measure set T -> \bar R}) : {outer_measure set T -> \bar R} :=
    OuterMeasure (OuterMeasure.Axioms (mu_ext0 mu) (mu_ext_ge0 mu)
      (le_mu_ext mu) (mu_ext_sigma_subadditive mu)).
(* /NB: PR in progress *)

(* NB: PR to MathComp in progress *)
Lemma natr_absz (R : numDomainType) i : `|i|%:R = `|i|%:~R :> R.
Proof. by rewrite -abszE. Qed.
(* END NB: PR to MathComp in progress *)

(* NB: not used *)
Notation ssum u := (lim (series u)).

Lemma EFin_sum (R : numDomainType) n m (f : nat -> \bar R) :
  (forall i, (n <= i < m)%N -> f i \is a fin_num) ->
  \sum_(n <= i < m) f i = (\sum_(n <= i < m) real_of_extended (f i))%:E.
Proof.
move=> nim; rewrite (@big_morph _ _ (@EFin R) 0 adde) //.
rewrite [LHS]big_nat_cond [RHS]big_nat_cond; apply eq_bigr => i.
by rewrite andbT => /nim fi; rewrite -EFin_real_of_extended.
Qed.

Lemma telescope_sume (R : numDomainType) n m (f : (\bar R)^nat) :
  (forall i, (n <= i <= m)%N -> f i \is a fin_num) ->
  (n <= m)%N ->
  \sum_(n <= k < m) (f k.+1 - f k) = f m - f n.
Proof.
move=> foo nm.
have [g fg] : exists g : nat -> R, forall i, (n <= i <= m)%N -> f i = (g i)%:E.
  exists (real_of_extended \o f) => i nim; rewrite -EFin_real_of_extended //.
  exact: foo.
rewrite EFin_sum //; last first.
  move=> i /andP[ni im]; rewrite fin_numD foo/= ?im ?(leq_trans _ (leqnSn _))//.
  by rewrite fin_numN foo// ni/= ltnW.
rewrite [in LHS]big_nat_cond.
(under eq_bigr) => [i|].
  rewrite andbT => /andP[ni im].
  rewrite real_of_extendedD //; last 2 first.
    by rewrite foo // im (leq_trans ni).
    by rewrite fin_numN foo// ni /= ltnW.
  by rewrite real_of_extendedN; over.
rewrite -big_nat_cond telescope_sumr // subEFin.
rewrite -EFin_real_of_extended; last by rewrite foo // nm leqnn.
by rewrite -EFin_real_of_extended // foo// leqnn.
Qed.

Section eseries.
Local Open Scope ereal_scope.
Variables (R : numDomainType) (u_ : nat -> \bar R).

Definition eseries : (\bar R)^nat := [sequence \sum_(0 <= k < n) u_ k]_n.

Lemma eseriesEnat : eseries = [sequence \sum_(0 <= k < n) u_ k]_n.
Proof. by []. Qed.

Lemma eseriesEord : eseries = [sequence \sum_(k < n) u_ k]_n.
Proof. by rewrite /eseries /=; under eq_fun do rewrite big_mkord. Qed.
End eseries.

(* TODO: substitute to lee_adde? *)
Lemma lee_addgt0Pr (R : realFieldType) (x y : \bar R) :
  reflect (forall e : R, (0 < e)%R -> (x <= y + e%:E)%E) (x <= y)%E.
Proof.
apply/(iffP idP); move: x y => [x| |] [y| |] //.
- by rewrite lee_fin => /ler_addgt0Pr xy e e0; rewrite -addEFin lee_fin xy.
- by move=> _ e e0; rewrite -addEFin lee_ninfty.
- move=> xy; rewrite lee_fin; apply/ler_addgt0Pr => e /xy.
  by rewrite -addEFin lee_fin.
- by move=> _; rewrite lee_pinfty.
- by move=> /(_ _ ltr01).
- by move=> /(_ _ ltr01).
- by move=> /(_ _ ltr01).
- by move=> _; rewrite lee_ninfty.
Qed.

Reserved Notation "'s<<' A '>>'".
Reserved Notation "[ 'sset' 'of' s ]"
  (at level 0, format "[ 'sset'  'of'  s ]").

(* TODO: move? not used *)
Lemma gsum_nat_setT (R : realType) (a : (\bar R)^nat) :
  (forall n, 0 <= a n) -> \csum_(i in setT) a i = \sum_(i <oo) a i.
Proof.
move=> a0; rewrite (@ereal_pseries_csum _ a xpredT) //.
by congr csum; rewrite predeqE.
Qed.

(* mu_ext mu and mu coincide on measurable sets *)
Lemma measurable_mu_extE (R : realType) (T : ringOfSetsType)
    (mu : {measure set T -> \bar R}) X :
  measurable X -> [outer_measure of mu_ext mu] X = mu X.
Proof.
move=> mX; apply/eqP; rewrite eq_le; apply/andP; split.
  apply ereal_inf_lb; exists (fun n => if n is 0%N then X else set0).
    by split=> [[]// _|t Xt]; [exact: measurable0 | exists 0%N].
  apply/cvg_lim => //; rewrite -cvg_shiftS.
  rewrite (_ : [sequence _]_n = cst (mu X)); first exact: cvg_cst.
  by rewrite funeqE => n /=; rewrite big_nat_recl//= big1 ?adde0.
apply/lb_ereal_inf => x [A [mA XA] <-{x}].
have XUA : X = \bigcup_n (X `&` A n).
  rewrite predeqE => t; split => [Xt|[i _ []//]].
  by have [i _ Ait] := XA _ Xt; exists i; split.
apply: (@le_trans _ _ (\sum_(i <oo) mu (X `&` A i))).
  by rewrite {1}XUA; apply: generalized_Boole_inequality => //;
    [move=> i; exact: measurableI | rewrite -XUA].
apply lee_lim.
- by apply: is_cvg_ereal_nneg_series => n _; exact/measure_ge0/measurableI.
- by apply: is_cvg_ereal_nneg_series => n _; exact/measure_ge0.
- near=> n; apply: lee_sum => i  _; apply: le_measure => //;
    rewrite /mkset ?in_setE //; by [exact: measurableI | apply: subIset; right].
Grab Existential Variables. all: end_near. Qed.

(* NB: not used *)
Lemma caratheodory_measurable_mu_ext (R : realType) (T : measurableType)
    (mu : {measure set T -> \bar R}) A :
  measurable A -> [outer_measure of mu_ext mu].-measurable A.
Proof.
move=> mA; apply le_caratheodory_measurable => // X /=.
suff le_mu : forall B, measurable B -> X `<=` B ->
    mu_ext mu (X `&` A) + mu_ext mu (X `&` ~` A) <= mu B.
  apply lb_ereal_inf => Y [B [mB XB] <-{Y}].
  have /(_ XB)/le_trans := le_mu _ (measurable_bigcup _ mB); apply.
  by apply: generalized_Boole_inequality => //; exact: measurable_bigcup.
move=> B mB BX; apply (@le_trans _ _ (mu (B `&` A) + mu (B `&` ~` A))).
  apply: lee_add.
  - apply/ereal_inf_lb; exists (fun n => if n is 0%N then B `&` A else set0).
      split=> [[|_]|t [Xt At]]; [apply: measurableI => //|exact: measurable0|].
      by exists 0%N => //; split => //; exact: BX.
    set F := (X in lim_in _ X); have : ProperFilter F by typeclasses eauto.
    move/(@cvg_lim _ _ _); apply => //.
    rewrite -cvg_shiftS (_ : [sequence _]_n = cst (mu (B `&` A))) /=.
      exact: cvg_cst.
    by rewrite funeqE => n /=; rewrite big_mkord big_ord_recl /= big1 ?adde0.
  - apply ereal_inf_lb; exists (fun n => if n is 0%N then B `&` ~` A else set0).
      split=> [[|_]|t [Xt At]].
      + by rewrite -setDE; apply: measurableD.
      + exact: measurable0.
      + by exists 0%N; split => //; exact: BX.
    set F := (X in lim_in _ X); have : ProperFilter F by typeclasses eauto.
    move/(@cvg_lim _ _ _); apply => //.
    rewrite -cvg_shiftS (_ : [sequence _]_n = cst (mu (B `&` ~` A))).
      exact: cvg_cst.
    by rewrite funeqE => n /=; rewrite big_mkord big_ord_recl /= big1 ?adde0.
rewrite -measure_additive2 //.
- by rewrite -setIUr setUCr setIT.
- exact: measurableI.
- by rewrite -setDE; apply: measurableD.
- by rewrite setICA -(setIA B) setICr 2!setI0.
Qed.

Definition measurableP U (T : set (set U)) :=
  [/\ T set0, (forall A, T A -> T (~` A)) &
     (forall A : (set U)^nat, (forall n, T (A n)) -> T (\bigcup_k A k))].

Lemma measurableP_measurable (T : measurableType) : measurableP (@measurable T).
Proof.
by split => //;
  [exact: measurable0 |exact: measurableC | exact: measurable_bigcup].
Qed.

Lemma measurableP_bigcap (U : Type) (I : choiceType) (T : I -> (set (set U))) :
  forall (J : set I), (forall n, J n -> measurableP (T n)) ->
                 measurableP (\bigcap_(i in J) (T i)).
Proof.
move=> J mT; split=> [i Ji|A AJ i Ji|A_ TA_ i Ji].
- by have [] := mT i.
- by have [_ mTiC _] := mT i Ji; exact/mTiC/AJ.
- by have [_ _ mTiU] := mT i Ji; apply mTiU => j; apply TA_.
Qed.

Section generated_salgebra.
Variables (U : Type).
Implicit Types M : set (set U).

Inductive g_salgebra M : set (set U) :=
| g_salgebra_self : forall A, M A -> s<< M >> A
| g_salgebra_set0 : s<< M >> set0
| g_salgebra_setC : forall A, s<< M >> A -> s<< M >> (~` A)
| g_salgebra_bigcup : forall A : (set U)^nat, (forall i, s<< M >> (A i)) ->
    s<< M >> (\bigcup_i (A i)) where "'s<<' M '>>'" := (g_salgebra M).

Lemma g_salgebraE M :
  s<< M >> = \bigcap_(A in [set T : set (set U) | measurableP T /\ M `<=` T]) A.
Proof.
rewrite predeqE => A; split => [|]. elim=>
  [ {}A ? N [?] | {}A [[]]| {}A ? MA N [[? NC ?] ?] | {}A ? MA N [[? ? NI] ?]];
  [exact | by [] | by apply/NC; apply: MA | by apply NI => i; exact: (MA i)].
apply; split; [split|]; [exact: g_salgebra_set0 | exact: g_salgebra_setC |
  exact: g_salgebra_bigcup | by move=> B MB; apply g_salgebra_self].
Qed.

Lemma measurableP_g_salgebra M : measurableP (g_salgebra M).
Proof. by rewrite g_salgebraE; apply measurableP_bigcap => /= ? [?]. Qed.

Lemma g_salgebra_smallest M :
  forall T : set (set U), measurableP T -> M `<=` T -> g_salgebra M `<=` T.
Proof. by move=> T mT MT t; rewrite g_salgebraE; exact. Qed.

End generated_salgebra.
Notation "'s<<' M '>>'" := (g_salgebra M).

Definition g_measurable (U : Type) (C : set (set U)) := U.

Section generated_salgebra_instance.
Variables (U : Type) (C : set (set U)).

HB.instance Definition g_salgebra_mixin :=
  @isMeasurable.Build (g_measurable C) (g_salgebra C)
  (@g_salgebra_set0 _ C) (@g_salgebra_setC _ C) (@g_salgebra_bigcup _ C).

Definition g_salgebra_measurableType := [the measurableType of g_measurable C].

End generated_salgebra_instance.

Section measure_setD.
Variables (R : realType) (T : ringOfSetsType).
Variables m : {measure set T -> \bar R}.

Lemma measure_setDI A B : measurable A -> measurable B ->
  m A = m (A `\` B) + m (A `&` B).
Proof.
move=> mA mB.
rewrite -[in LHS](SetOrder.Internal.joinIB A B) measure_semi_additive2.
by rewrite addeC.
exact: measurableI.
exact: measurableD.
by apply: measurableU; [exact: measurableI |exact: measurableD].
by rewrite setDE setICA -setIA setICr 2!setI0.
Qed.

Lemma measure_setD A B : measurable A -> measurable B ->
  m A < +oo -> m (A `\` B) = m A - m (A `&` B).
Proof.
move=> mA mB mAoo.
rewrite (measure_setDI mA mB) addeK // fin_numE; apply/andP; split.
  rewrite gt_eqF// (lt_le_trans _ (measure_ge0 _ _))// ?lte_ninfty//.
  exact: measurableI.
rewrite lt_eqF// (le_lt_trans _ mAoo)// le_measure //.
by rewrite inE /=; exact: measurableI.
by rewrite inE.
by apply: subIset; left.
Qed.

End measure_setD.

(* TODO: move *)
Definition seqDU T (F : (set T)^nat) n := F n `\` (\big[setU/set0]_(m < n) F m).

Lemma seqDU_eq T (F : (set T)^nat) n :
  \big[setU/set0]_(m < n) F m = \big[setU/set0]_(m < n) seqDU F m.
Proof.
elim: n => [|n ih]; first by rewrite 2!big_ord0.
rewrite !big_ord_recr /= predeqE => t; split=> [[Ft|Fnt]|[Ft|[Fnt Ft]]].
- by left; rewrite -ih.
- have [?|?] := pselect ((\big[setU/set0]_(i < n) seqDU F i) t); first by left.
  by right; split => //; rewrite ih.
- by left; rewrite ih.
- by right.
Qed.

Lemma seqDU_bigcup_eq T (F : (set T)^nat) : \bigcup_m (F m) = \bigcup_m (seqDU F m).
Proof.
rewrite /seqDU predeqE=> t; split=> [[i _ Fit]|[i _]]; last first.
  by rewrite setDE => -[Fit _]; exists i.
have [X|X] := pselect ((\big[setU/set0]_(k < i) F k) t); last by exists i.
suff [j [Fjt Fijt]] : exists j, F j t /\ forall k, (k < j)%N -> ~ F k t.
  by exists j => //; split => //; rewrite bigcup_ord => -[k /= kj]; exact: Fijt.
move: X; rewrite bigcup_ord => -[/= k ki Fkt]; clear Fit ki i.
have [n ni] := ubnP k; elim: n => // n ih in t k Fkt ni *.
case: k => [|k] in Fkt ni *; first by exists O.
rewrite ltnS in ni.
have [?|] := pselect (forall k0 : nat, (k0 < k.+1)%N -> ~ F k0 t); first by exists k.+1.
move=> /existsNP[i] /not_implyP[ik1] /contrapT Fit; apply (ih t i) => //.
by rewrite ltnS in ik1; rewrite (leq_ltn_trans ik1).
Qed.

Lemma trivIset_seqDU T (F : (set T)^nat) : trivIset setT (seqDU F).
Proof.
move=> i j _ _; wlog ij : i j / (i < j)%N => [/(_ _ _ _) tB|].
  by have [ij /tB->|ij|] := ltngtP i j; rewrite //setIC => /tB->.
move=> /set0P; apply: contraNeq => _; apply/eqP.
rewrite /seqDU 2!setDE !setIA setIC (bigD1 (Ordinal ij)) //=.
by rewrite setCU setIAC !setIA setICl !set0I.
Qed.

(* TODO: remove *)
Lemma trivIset_setIC T I (D : set I) (F : I -> set T) X :
  trivIset D (fun i => F i `&` X) = trivIset D (fun i => X `&` F i).
Proof. by under eq_fun do rewrite setIC. Qed.

Lemma lim_mkord (R : realType) (f : (\bar R)^nat) :
  lim (fun n => \sum_(k < n) f k)%E = \sum_(k <oo) f k.
Proof.
rewrite (_ : (fun n => _) = (fun n => \sum_(0 <= k < n) f k)%E) // funeqE => k.
by rewrite big_mkord.
Qed.

(* TODO: move *)
Lemma add_ltoo (R : realDomainType) (x y : \bar R) : x < +oo -> y < +oo -> x + y < +oo.
Proof. by move: x y => -[r [r'| |]| |] // ? ?; rewrite -addEFin lte_pinfty. Qed.

(* TODO: generalize *)
Lemma lte_sum_pinfty (R : realDomainType) T (s : seq T) (P : pred T) (f : T -> \bar R) :
  (forall x, P x -> f x < +oo) -> \sum_(i <- s | P i) f i < +oo.
Proof.
elim/big_ind : _ => [_|x y xoo yoo foo|i ?]; [exact: lte_pinfty| |exact].
by apply: add_ltoo; [exact: xoo| exact: yoo].
Qed.

(* TODO: move *)
Section sigma_finite_lemma.
Variables (R : realFieldType) (T : ringOfSetsType) (A : set T)
  (mu : {additive_measure set T -> \bar R}).

Lemma sigma_finiteP : sigma_finite A mu ->
  exists2 F : (set T)^nat,
    A = \bigcup_i F i &
      (forall i, F i `<=` F i.+1) /\
      forall i, measurable (F i) /\ mu (F i) < +oo.
Proof.
move=> [S AS moo].
exists (fun n => \big[setU/set0]_(i < n.+1) S i).
  rewrite AS predeqE => t; split => [[i _ Sit]|[i _]].
  by exists i => //; rewrite big_ord_recr /=; right.
  by rewrite bigcup_ord => -[j /= ji Sjt]; exists j.
split => i.
  by rewrite [in X in _ `<=` X]big_ord_recr /=; left.
split.
  by apply: bigsetU_measurable => j _; exact: (moo j).1.
rewrite (@le_lt_trans _ _ (\sum_(j < i.+1) mu (S j))) //.
  by apply: Boole_inequality => j; exact: (moo j).1.
by apply/lte_sum_pinfty => j _; exact: (moo j).2.
Qed.

End sigma_finite_lemma.

Reserved Notation "'d<<' D '>>'".

Section dynkin.
Variable T : Type.
Implicit Types D G : set (set T).

Definition dynkin D := [/\ D setT, (forall Y, D Y -> D (~` Y)) &
  (forall F : (set T)^nat, trivIset setT F ->
   (forall n, D (F n)) -> D (\bigcup_k F k))].

Lemma dynkinT D : dynkin D -> D setT. Proof. by case. Qed.

Lemma dynkinC D : dynkin D -> (forall Y, D Y -> D (~` Y)). Proof. by case. Qed.

Lemma dynkinU D : dynkin D -> (forall F : (set T)^nat, trivIset setT F ->
  (forall n, D (F n)) -> D (\bigcup_k F k)). Proof. by case. Qed.

Definition gdynkin G := \bigcap_(x in [set D | dynkin D /\ G `<=` D]) x.
Local Notation "'d<<' D '>>'" := (gdynkin D).

Lemma dynkin_g G : dynkin (d<< G >>).
Proof.
split=> [D /= [] []//| | ].
- by move=> Y sGY D /= [dD GD]; exact/(dynkinC dD)/(sGY D).
- by move=> F tF gGF D /= [dD GD]; apply dD => // k; exact: gGF.
Qed.

Lemma gdynkin_smallest G D : dynkin D -> G `<=` D -> d<< G >> `<=` D.
Proof. by move=> dD GD S; exact. Qed.

Lemma salgebra_is_dynkin D : measurableP D -> dynkin D.
Proof.
by case=> ? DC DU; split => [|//|? ? ?]; [rewrite -setC0; apply DC|exact/DU].
Qed.

End dynkin.
Notation "'d<<' D '>>'" := (gdynkin D).

Fact salgebra_is_dynkin' (T : measurableType) : dynkin (@measurable T).
Proof.
apply salgebra_is_dynkin; split; first exact: measurable0.
- by move=> Y mY; exact: measurableC.
- by move=> F mF; apply: measurable_bigcup.
Qed.

Section dynkin_lemmas.
Variable T : Type.
Implicit Types D G : set (set T).

Lemma dynkin_setI_bigI D (F : (set T)^nat) : dynkin D ->
  (forall A B, D A -> D B -> D (A `&` B)) -> (forall n, D (F n)) ->
  forall n, D (\big[setI/setT]_(i < n) F i).
Proof.
move=> dD DI DF; elim => [|n ih].
  by rewrite big_ord0; exact: (dynkinT dD).
by rewrite big_ord_recr /=; apply DI.
Qed.

Lemma dynkin_setI_salgebra D : dynkin D ->
  (forall A B, D A -> D B -> D (A `&` B)) -> measurableP D.
Proof.
move=> dD DI; split => [|//|F DF].
- by rewrite -setCT; apply/(dynkinC dD)/(dynkinT dD).
- exact/(dynkinC dD).
- rewrite seqDU_bigcup_eq; apply/(dynkinU dD) => //; first exact/trivIset_seqDU.
  move=> n; rewrite /seqDU setDE; apply DI => //.
  rewrite bigcup_ord setC_bigcup -bigcap_ord.
  by apply: (@dynkin_setI_bigI _ (fun x => ~` F x)) => // ?; exact/(dynkinC dD).
Qed.

Lemma gdynkin_setI_salgebra G : (forall A B, G A -> G B -> G (A `&` B)) ->
  d<< G >> = s<< G >>.
Proof.
move=> GI; rewrite eqEsubset; split.
  apply: gdynkin_smallest => //; last exact/g_salgebra_self.
  exact/salgebra_is_dynkin/measurableP_g_salgebra.
pose delta (D : set T) := [set E | d<< G >> (E `&` D)].
have ddelta (D : set T) : d<<G>> D -> dynkin (delta D).
  move=> dGD; split; first by rewrite /delta /= setTI.
  - move=> E DE; rewrite /delta /=.
    have -> : (~` E) `&` D = ~` ((E `&` D) `|` (~` D)).
      by rewrite -[LHS]setU0 -(setICl D) -setIUl -setCI -{2}(setCK D) -setCU.
    have : d<<G>> ((E `&` D) `|` ~` D).
      rewrite -bigcup2E => S [dS GS]; apply (dynkinU dS).
        move=> [|[|i]] [|[|j]] => // _ _; rewrite /bigcup2 /=.
        + by rewrite -setIA setICr setI0 => /set0P; rewrite eqxx.
        + by rewrite setI0 => /set0P; rewrite eqxx.
        + by rewrite setICA setICl setI0 => /set0P; rewrite eqxx.
        + by rewrite setI0 => /set0P; rewrite eqxx.
        + by rewrite set0I => /set0P; rewrite eqxx.
        + by rewrite set0I => /set0P; rewrite eqxx.
        + by rewrite set0I => /set0P; rewrite eqxx.
      move=> [|[|n]] //; rewrite /bigcup2 /=.
      + exact: DE.
      + suff : d<<G>> (~` D) by exact.
        by move=> F [dF GF]; apply (dynkinC dF) => //; exact: dGD.
      + by rewrite -setCT; apply/(dynkinC dS)/(dynkinT dS).
    by move=> dGEDD S /= [+ GS] => dS; apply/(dynkinC dS); exact: dGEDD.
  - move=> F tF deltaDF; rewrite /delta /= => S /= [dS GS].
    rewrite bigcup_distrl; apply (dynkinU dS) => //.
    by rewrite trivIset_setIC; exact: trivIset_setI.
    by move=> n; apply: (deltaDF n).
have GdG : G `<=` d<< G >> by move=> ? ? ? [_]; apply.
have Gdelta : forall A, G A -> G `<=` delta A.
  by move=> ? ? ? ?; rewrite /delta /= => ? [?]; apply; exact/GI.
have GdGdelta : forall A, G A -> d<< G >> `<=` delta A.
  move=> ? ?; apply gdynkin_smallest => //; last exact: Gdelta.
  by apply/ddelta; exact: GdG.
have dGGI : forall A B, d<<G>> A -> G B -> d<<G>> (A `&` B).
  by move=> ? ? ? ?; apply: GdGdelta.
have dGGdelta : forall A, d<<G>> A -> G `<=` delta A.
  by move=> ? ? ? ?; rewrite /delta /= setIC; exact: dGGI.
have dGdGdelta : forall A, d<<G>> A -> d<< G >> `<=` delta A.
  by move=> ? ?; exact: (gdynkin_smallest (ddelta _ _) (dGGdelta _ _)).
have dGdGdG : forall A B, d<<G>> A -> d<<G>> B -> d<<G>> (A `&` B).
  by move=> ? ? ? ?; exact: dGdGdelta.
apply: g_salgebra_smallest => //; apply: dynkin_setI_salgebra => //.
exact: dynkin_g.
Qed.

End dynkin_lemmas.

Section measure_unique.
Variables (R : realType) (T : measurableType) (G : set (set T)).
Hypothesis TG : measurable = s<< G >>.
Hypothesis GI : forall A B, G A -> G B -> G (A `&` B).
(* existence of an exhausting sequence *)
Variable g : (set T)^nat.
Hypothesis Gg : forall i, G (g i).
Hypothesis gnondecr : forall k, g k `<=` g k.+1.
Hypothesis gfull : \bigcup_k (g k) = setT.
Variables m m' : {measure set T -> \bar R}.
Hypothesis mm' : forall A, G A -> m A = m' A.
Hypothesis mgfinite : forall k, (m (g k) < +oo)%E.

Lemma measure_unique : forall E, measurable E -> m E = m' E.
Proof.
pose D n := [set X | measurable X /\ m (g n `&` X) = m' (g n `&` X)].
have dD : forall n, dynkin (D n).
  move=> n; split.
  - by rewrite /D /=; split => //; [exact: measurableT | rewrite setIT mm'].
  - move=> X [SX mm'X]; split; first exact: measurableC.
    rewrite -setDE measure_setD //; last by rewrite TG; exact/g_salgebra_self/Gg.
    by rewrite mm' // mm'X -measure_setD // -?mm'// TG; exact/g_salgebra_self/Gg.
  - move=> F tF DF; rewrite /D /=; split.
      by apply: measurable_bigcup => // i;  exact: (DF i).1.
    rewrite bigcup_distrr.
    transitivity (\sum_(i <oo) m (g n `&` F i)%E).
      rewrite -lim_mkord; apply/esym/cvg_lim => //=.
      apply: measure_sigma_additive; last exact: trivIset_setI.
      move=> i; apply: measurableI => //; last exact: (DF i).1.
      by rewrite TG; exact/g_salgebra_self/Gg.
    transitivity (\sum_(i <oo) m' (g n `&` F i)).
      by apply: eq_ereal_pseries => // k; have := (DF k).2.
    rewrite -lim_mkord; apply/cvg_lim => //.
    apply: measure_sigma_additive; last exact: trivIset_setI.
    move=> i; apply: measurableI => //; last exact: (DF i).1.
    by rewrite TG; exact/g_salgebra_self/Gg.
have GD : forall n, G `<=` D n.
  move=> n S GS; rewrite /D /=; split.
  - by rewrite TG; exact/g_salgebra_self.
  - by rewrite mm'//; exact: GI.
have dGsG : d<< G >> = s<< G >> := gdynkin_setI_salgebra GI.
have mDE : forall n, measurable = D n.
  move=> n; rewrite eqEsubset; split=> [| x []//].
  by rewrite TG -dGsG; exact: gdynkin_smallest.
have mm'g : forall n E, measurable E -> m (g n `&` E) = m' (g n `&` E).
  by move=> n E; rewrite (mDE n) /D /= => -[SE].
have gE : forall E, measurable E -> \bigcup_k (g k `&` E) = E.
  by move=> E SE; rewrite -bigcup_distrl gfull setTI.
move=> E mE.
transitivity (lim (fun n => m (g n `&` E))).
  rewrite -[in LHS](gE E) //; apply/esym/cvg_lim/cvg_mu_inc => //.
  - by move=> i; apply: measurableI => //; rewrite TG; exact/g_salgebra_self/Gg.
  - apply/measurable_bigcup => i; apply/measurableI => //.
    by rewrite TG; exact/g_salgebra_self/Gg.
  - move=> p q pq; apply: setSI; apply/subsetPset.
    by apply/nondecreasing_seqP => // n; exact/subsetPset/gnondecr.
transitivity (lim (fun n => m' (g n `&` E))).
  rewrite (_ : (fun n => _) = (fun n => m' (g n `&` E))) //.
  by rewrite funeqE => i; rewrite mm'g.
rewrite -[in RHS](gE E) //; apply/cvg_lim/cvg_mu_inc => //.
- by move=> i; apply: measurableI => //; rewrite TG; exact/g_salgebra_self/Gg.
- apply/measurable_bigcup => i; apply/measurableI => //.
  by rewrite TG; exact/g_salgebra_self/Gg.
- move=> p q pq; apply: setSI; apply/subsetPset.
  by apply/nondecreasing_seqP => // n; exact/subsetPset/gnondecr.
Qed.

End measure_unique.

Section Hahn_extension.
Variables (R : realType) (T : ringOfSetsType) (mu : {measure set T -> \bar R}).

Let mstar : {outer_measure set T -> \bar R} := [outer_measure of mu_ext mu].
Let M : measurableType := [the measurableType of caratheodory_type mstar].

Lemma subset_g_salgebra_caratheodory : s<< @measurable T >> `<=` @measurable M.
Proof.
apply: g_salgebra_smallest.
  split; [exact: measurable0 | by move=> X mX; exact: measurableC |
    by move=> u_ mu_; exact: measurable_bigcup].
move=> A mA; apply le_caratheodory_measurable => // X.
apply lb_ereal_inf => _ [B [mB XB] <-].
set BA := eseries (fun n => mu (B n `&` A)).
set BNA := eseries (fun n => mu (B n `&` ~` A)).
apply (@le_trans _ _ (lim BA + lim BNA)); [apply: lee_add|].
  - rewrite (_ : BA = eseries (fun n => mstar (B n `&` A))); last first.
      rewrite funeqE => n; apply: eq_bigr => i _.
      by rewrite /mstar /= measurable_mu_extE //; exact: measurableI.
    apply (@le_trans _ _ (mstar (\bigcup_k (B k `&` A)))).
      by apply le_mu_ext; rewrite -bigcup_distrl; apply setISS.
    exact: outer_measure_sigma_subadditive.
  - rewrite (_ : BNA = eseries (fun n => mstar (B n `\` A))); last first.
      rewrite funeqE => n; apply eq_bigr => i _.
      by rewrite /mstar /= measurable_mu_extE //; exact: measurableD.
    apply (@le_trans _ _ (mstar (\bigcup_k (B k `\` A)))).
      by apply le_mu_ext; rewrite -bigcup_distrl; apply setISS.
    exact: outer_measure_sigma_subadditive.
have ? : cvg BNA.
  apply/is_cvg_ereal_nneg_series => n _.
  by rewrite -setDE; apply: measure_ge0 => //; apply: measurableD.
have ? : cvg BA.
  apply/is_cvg_ereal_nneg_series => n _.
  by apply: measure_ge0 => //; apply: measurableI.
have ? : cvg (eseries (mu \o B)).
  by apply/is_cvg_ereal_nneg_series => n _; exact: measure_ge0.
have [def|] := boolP (adde_def (lim BA) (lim BNA)); last first.
  rewrite /adde_def negb_and 2!negbK => /orP[/andP[BAoo BNAoo]|/andP[BAoo BNAoo]].
  - suff -> : lim (eseries (mu \o B)) = +oo by rewrite lee_pinfty.
    apply/eqP; rewrite -lee_pinfty_eq -(eqP BAoo); apply/lee_lim => //.
    near=> n; apply: lee_sum => m _; apply: le_measure; rewrite /mkset; by
      [rewrite inE; exact: measurableI | rewrite inE | apply: subIset; left].
  - suff -> : lim (eseries (mu \o B)) = +oo by rewrite lee_pinfty.
    apply/eqP; rewrite -lee_pinfty_eq -(eqP BNAoo); apply/lee_lim => //.
    near=> n; apply: lee_sum => m _; rewrite -setDE; apply: le_measure;
      rewrite /mkset; by [rewrite inE; exact: measurableD |
                          rewrite inE |
                          apply: subIset; left].
rewrite -ereal_limD // (_ : (fun _ => _) =
    eseries (fun i => mu (B i `&` A) + mu (B i `&` ~` A))); last first.
  by rewrite funeqE => n; rewrite -big_split /=; apply eq_bigr.
apply/lee_lim => //.
  apply/is_cvg_ereal_nneg_series => // n _; apply/adde_ge0.
  by apply: measure_ge0 => //; apply: measurableI.
  by rewrite -setDE; apply: measure_ge0; apply: measurableD.
near=> n; apply: lee_sum => i _; rewrite -measure_semi_additive2.
- apply: le_measure; rewrite /mkset; [rewrite inE |
                                      by rewrite inE |
                                      by rewrite -setIUr setUCr setIT].
  by apply: measurableU; [exact: measurableI |
                          rewrite -setDE; exact: measurableD].
- exact: measurableI.
- by rewrite -setDE; exact: measurableD.
- apply: measurableU; [exact: measurableI | rewrite -setDE; exact: measurableD].
- by rewrite setIACA setICr setI0.
Grab Existential Variables. all: end_near. Qed.

Let I : measurableType := g_salgebra_measurableType (@measurable T).

Definition Hahn_ext' : set I -> \bar R := mu_ext mu.
Definition Hahn_ext : {measure set I -> \bar R}.
apply: (@Measure.Pack _ _ _ Hahn_ext' (@Measure.Axioms _ _ _ _ _ _)).
- exact: mu_ext0.
- by move=> x ?; exact: mu_ext_ge0.
- move=> F mF tF mUF; rewrite /Hahn_ext'.
  apply: (@caratheodory_measure_sigma_additive _ _ mstar) => //; last first.
    exact: subset_g_salgebra_caratheodory.
  by move=> i; exact: (subset_g_salgebra_caratheodory (mF i)).
Defined.

Lemma Hahn_ext_sigma_finite : @sigma_finite _ T setT mu ->
  @sigma_finite _ I setT Hahn_ext.
Proof.
move=> -[S setTS mS]; exists S => //; move=> i; split.
  exact: (g_salgebra_self (mS i).1).
by rewrite /Hahn_ext /= /Hahn_ext' measurable_mu_extE //;
  [exact: (mS i).2 | exact: (mS i).1].
Qed.

Lemma Hahn_ext_unique : @sigma_finite _ T setT mu ->
  (forall mu' : {measure set I -> \bar R},
    (forall X, @measurable T X -> mu' X = mu X) ->
    (forall X, @measurable I X -> Hahn_ext X = mu' X)).
Proof.
move=> sfmu mu' mu'mu; move: (sfmu) => /sigma_finiteP[S setTS [Snondec mS]] X mX.
apply: (@measure_unique R I (@measurable T) erefl _ S) => //.
- by move=> ? ? ? ?; apply: measurableI.
- by move=> i; exact: (mS i).1.
- move=> Y mY.
  by rewrite /Hahn_ext/Hahn_ext'/= measurable_mu_extE // mu'mu.
- move=> i.
  by rewrite /Hahn_ext/=/Hahn_ext' measurable_mu_extE //;
    [exact: (mS i).2 | exact: (mS i).1].
Qed.

End Hahn_extension.

(* NB: not used *)
Lemma subset_seqD (R : numDomainType) (A : (set R)^nat) k : seqD A k `<=` A k.
Proof. by case: k => [|k] //= r []. Qed.

(* NB: not used *)
Lemma trivIset_subsequence (T : Type) (s : nat -> set T) (e : nat -> nat) :
  injective e -> trivIset setT s -> trivIset setT (s \o e).
Proof.
move=> ie /trivIsetP H; apply/trivIsetP => a b _ _ ab /=.
apply H => //.
by apply: contra ab => /eqP ab; apply/eqP/ie.
Qed.

(* NB: not used *)
Lemma lt_lim (R : realFieldType) (u_ : R^o^nat) (M : R) :
  nondecreasing_seq u_ -> cvg u_ -> (M < lim u_)%R ->
  \forall n \near \oo, (M <= u_ n)%R.
Proof.
move=> ndu cu Ml; have [[n Mun]|] := pselect (exists n, M <= u_ n)%R.
  near=> m; suff : (u_ n <= u_ m)%R by exact: le_trans.
  by near: m; by exists n.+1 => // p q; apply/ndu/ltnW.
move/forallNP => Mu.
have {}Mu : forall x, (M > u_ x)%R by move=> x; rewrite ltNge; apply/negP.
have : (lim u_ <= M)%R by apply lim_le => //; near=> m; exact/ltW/Mu.
by move/(lt_le_trans Ml); rewrite ltxx.
Grab Existential Variables. all: end_near. Qed.

(*TODO: PR *)
Lemma sum_fset_nat_ub (R : realDomainType) (f : (\bar R)^nat) (F : {fset nat})
    (P : pred nat) n :
  (forall i, P i -> 0%E <= f i) ->
  (F `<=` @nat_of_ord _ @` fsets_ord xpredT n)%fset ->
  \sum_(i <- F | P i) f i <= \sum_(i < n | P i) f i.
Proof.
move=> f0 /fsubsetP F_fsets_ord.
apply (@le_trans _ _ (\sum_(i <- @nat_of_ord _ @` [fset j : 'I_n | P j]) f i)%fset); last first.
  rewrite big_imfset /=; last by move=> i j _ _; apply: ord_inj.
  by rewrite big_fset /= big_enum_cond.
apply (@le_trans _ _ (\sum_(i <- [fset nat_of_ord j | j in 'I_n]%fset | P i) f i)); last first.
  rewrite big_imfset /=; last by move=> i j _ _; apply/ord_inj.
  rewrite big_fset big_enum_cond /= big_mkcond /=.
  rewrite big_imfset /=; last by move=> i j _ _; apply/ord_inj.
  by rewrite -big_mkcond /= big_enum_cond.
apply/(lee_sum_nneg_subfset _ (fun m _ => f0 m)) => t /F_fsets_ord.
by move=> /imfsetP[/= j _ ->{t}]; apply/imfsetP; exists j.
Qed.

Lemma lee_sum_lim (R : realType) (f : (\bar R)^nat) (F : {fset nat})
    (P : pred nat) :
  (forall i, P i -> 0%E <= f i) ->
  \sum_(i <- F | P i) f i <= \sum_(i <oo | P i) f i.
Proof.
move=> f0; have [/eqP ->|F0] := boolP (F == fset0).
  by rewrite big_mkcond big_seq_fset0 ereal_nneg_series_lim_ge0.
have [n FnS] : exists n, (F `<=` @nat_of_ord _ @` fsets_ord xpredT n)%fset.
  move/fset_nat_maximum : F0 => [i [iF Fi]]; exists i.+1.
  apply/fsubsetP => j jF; apply/imfsetP => /=.
  by move/Fi : jF; rewrite -ltnS => jF; exists (Ordinal jF) => //; rewrite inE.
apply/(le_trans _ (ereal_nneg_series_lim_ge n f0)).
by rewrite big_mkord sum_fset_nat_ub.
Qed.

Lemma head_behead {T : eqType} (s : seq T) def : s != [::] -> head def s :: behead s = s.
Proof. by case: s. Qed.

Lemma mask_second (T : Type) (b : T) a t :
  a :: t = mask (true :: false :: nseq (size t) true) [:: a, b & t].
Proof. by rewrite /= mask_true. Qed.

Local Close Scope ereal_scope.

From mathcomp Require Import interval.

(* PR just merged to mathcomp's master *)
Lemma ge_pinfty (R : numDomainType) (x : itv_bound R) : (+oo <= x)%O = (x == +oo)%O.
Proof. by move: x => [[]|[]]. Qed.

Lemma le_ninfty (R : numDomainType) (x : itv_bound R) : (x <= -oo)%O = (x == -oo%O).
Proof. by case: x => // -[]. Qed.

Lemma gt_pinfty (R : numDomainType) (x : itv_bound R) : (+oo%O < x)%O = false.
Proof. by case: x. Qed.

Lemma lt_ninfty (R : numDomainType) (x : itv_bound R) : (x < -oo%O)%O = false.
Proof. by case: x => // -[]. Qed.
(* end PR just merged to mathcomp's master *)

Lemma ltz_opp (R : numDomainType) (n : nat) : (0 < n)%N -> - n%:R < n%:R :> R.
Proof.
by move=> n0; rewrite -subr_lt0 -opprD -natrD oppr_lt0 ltr0n addn_gt0 n0.
Qed.

(* NB: of general interest? *)
Section lte_bnd.
Variable R : numDomainType.

Local Lemma BLeft_ltE (x y : R) : (BLeft x < BLeft y)%O = (x < y).
Proof. by []. Qed.
Local Lemma BRight_leE (x y : R) : (BRight x <= BRight y)%O = (x <= y).
Proof. by []. Qed.
Local Lemma BRight_BLeft_leE (x y : R) : (BRight x <= BLeft y)%O = (x < y).
Proof. by []. Qed.
Local Lemma BLeft_BRight_ltE (x y : R) : (BLeft x < BRight y)%O = (x <= y).
Proof. by []. Qed.
Local Lemma BRight_BSide_ltE (x y : R) b : (BRight x < BSide b y)%O = (x < y).
Proof. by case: b. Qed.
Local Lemma BLeft_BSide_leE (x y : R) b : (BLeft x <= BSide b y)%O = (x <= y).
Proof. by case: b. Qed.

Definition lte_bnd := (BLeft_ltE, BLeft_BRight_ltE, BRight_BSide_ltE,
  BLeft_BSide_leE, BRight_BLeft_leE, BRight_leE).

Lemma BSide_BRight_leE (x y : R) b : (BSide b x <= BRight y)%O = (x <= y).
Proof. by case: b. Qed.
Lemma BSide_BLeft_leE (x y : R) b : (BSide b x < BLeft y)%O = (x < y).
Proof. by case: b. Qed.
Lemma BSide_leE (x y : R) b : (BSide b x <= BSide b y)%O = (x <= y).
Proof. by case: b. Qed.
Lemma BSide_ltE (x y : R) b : (BSide b x < BSide b y)%O = (x < y).
Proof. by case: b. Qed.

End lte_bnd.

Lemma ltBRight_leBLeft (R : realDomainType) (a : itv_bound R) (r : R) :
  (a < BRight r)%O -> (a <= BLeft r)%O.
Proof. by move: a => [[] a|[]]. Qed.

Lemma itv_meet_mem (R : realDomainType) (i1 i2 j1 j2 : itv_bound R) (x : R) :
  x \in itv_meet (Interval i1 i2) (Interval j1 j2) <->
  x \in Interval i1 i2 /\ x \in Interval j1 j2.
Proof.
split.
  rewrite /= 3!itv_boundlr joinEtotal meetEtotal le_maxl le_minr.
  by move=> /andP[/andP[-> ->] /andP[-> ->]].
case; rewrite 2!itv_boundlr => /andP[i1x xi2] /andP[j1x xj2].
by rewrite /= itv_boundlr joinEtotal meetEtotal le_maxl le_minr i1x j1x xj2 xi2.
Qed.

Coercion pair_of_interval T (I : interval T) : itv_bound T * itv_bound T :=
  let: Interval b1 b2 := I in (b1, b2).

(* non-empty interval *)
Definition neitv {R : numDomainType} : pred _ := [pred i : interval R | (i.1 < i.2)%O].

Definition itv_center (R : numDomainType) (i : interval R) : R :=
  match i with
  | Interval (BSide _ a) (BSide _ b) => (a + b) / 2
  | Interval -oo%O (BSide _ b) => b - 1
  | Interval (BSide _ a) +oo%O => a + 1
  | Interval -oo%O +oo%O => 0
  | _ => 0
  end.

Section itv_center_lemmas.
Variable R : numFieldType.
Implicit Types i : interval R.

Lemma mem_itv_center i : neitv i -> itv_center i \in i.
Proof.
move: i => [[[]a|[]] [[]b|[]]] //= ab; rewrite in_itv /=.
by rewrite midf_lt // andbT midf_le // ltW.
by rewrite midf_le // midf_le.
by rewrite ler_addl ler01.
by rewrite midf_lt // midf_lt.
by rewrite midf_lt // midf_le // ltW.
by rewrite ltr_addl ltr01.
by rewrite ltr_subl_addr ltr_addl.
by rewrite ler_subl_addr ler_addl.
Qed.

Lemma itv_center_bnd2 i : neitv i -> forall b, (BSide b (itv_center i) <= i.2)%O.
Proof.
move: i => [[[]a|[]] [[]b|[]]] //= => ab; case; rewrite lte_bnd.
by rewrite midf_le // ltW.
by rewrite midf_lt.
by rewrite midf_le.
by rewrite midf_le.
by rewrite midf_le // ltW.
by rewrite midf_lt.
by rewrite midf_le // ltW.
by rewrite midf_le // ltW.
by rewrite ler_subl_addl ler_addr.
by rewrite ltr_subl_addl ltr_addr.
by rewrite ler_subl_addl ler_addr.
by rewrite ler_subl_addl ler_addr.
Qed.

Lemma itv_center_bnd1 i : neitv i -> forall b, (i.1 <= BSide b (itv_center i))%O.
Proof.
move: i => [[[]a|[]] [[]b|[]]] //= => ab; case; rewrite lte_bnd.
by rewrite midf_le // ltW.
by rewrite midf_le // ltW.
by rewrite midf_le.
by rewrite midf_le.
by rewrite ler_addl.
by rewrite ler_addl.
by rewrite midf_lt.
by rewrite midf_le // ltW.
by rewrite midf_lt.
by rewrite midf_le // ltW.
by rewrite ltr_addl.
by rewrite ler_addl.
Qed.

(* NB: not used *)
Lemma midf_in_itv ba bb (a b : R) : a < b ->
  (a + b) / 2 \in Interval (BSide ba a) (BSide bb b).
Proof.
move=> ab; rewrite (@mem_itv_center (Interval (BSide ba a) (BSide bb b))) //.
by move: ba bb => [] [] //; rewrite /neitv /= lte_bnd ltW.
Qed.

(* NB: not used *)
Lemma BLeft_itv_center_lt (a b : itv_bound R) :
  (a < b)%O -> (BLeft (itv_center (Interval a b)) < b)%O.
Proof.
move: b a => [[]b|[]] [[]a|[]] //=; rewrite ?lte_bnd => ab.
by rewrite midf_lt.
by rewrite midf_lt.
by rewrite ltr_subl_addl ltr_addr.
by rewrite midf_le.
by rewrite midf_le // ltW.
by rewrite ler_subl_addl ler_addr.
Qed.

(* NB: not used *)
Lemma lt_BLeft_itv_center (a b : itv_bound R) :
  (a < b)%O -> (a < BRight (itv_center (Interval a b)))%O.
Proof.
move: b a => [[]b|[]] [[]a|[]] //=; rewrite ?lte_bnd => ab.
by rewrite midf_le // ltW.
by rewrite midf_lt.
by rewrite midf_le.
by rewrite midf_lt.
by rewrite ler_addl.
by rewrite ltr_addl.
Qed.

End itv_center_lemmas.

(* /NB: of general interest? *)

(* NB: definitions and lemmas to make a bridge between MathComp intervals and classical sets *)
Section set_of_itv.
Variable (R : numDomainType).
Implicit Type i j : interval R.
Implicit Type x y : R.
Implicit Type a : itv_bound R.

Definition set_of_itv i : set R := [set x | x \in i].

Lemma set_of_itv_mem i x : set_of_itv i x <-> x \in i.
Proof. by move: i => [[[]i1|[]] [[]i2|[]]]. Qed.

Lemma subset_of_itvP i j : {subset i <= j} <-> set_of_itv i `<=` set_of_itv j.
Proof. by move: i j => [[[] ?|[]] [[] ?|[]]] [[[] ?|[]] [[] ?|[]]]. Qed.

Lemma set_of_itvNlt_set0 i : ~~ neitv i -> set_of_itv i = set0.
Proof.
case: i => a b /itv_ge ij0; rewrite predeqE => r; split => //.
by rewrite /set_of_itv /mkset ij0.
Qed.

Lemma set_of_itv_pinfty_bnd a : set_of_itv (Interval +oo%O a) = set0.
Proof. by rewrite set_of_itvNlt_set0. Qed.

Lemma set_of_itv_bnd_ninfty a : set_of_itv (Interval a -oo%O) = set0.
Proof. by rewrite set_of_itvNlt_set0 //=; case: a => [[]a|[]]. Qed.

Definition set_of_itv_infty_set0 :=
  (set_of_itv_bnd_ninfty, set_of_itv_pinfty_bnd).

Lemma set_of_itv_pinfty_ninfty : set_of_itv (Interval +oo%O -oo%O) = @set0 R.
Proof. by rewrite set_of_itvNlt_set0. Qed.

Lemma set_of_itv_ninfty_ninfty : set_of_itv (Interval -oo%O -oo%O) = @set0 R.
Proof. by rewrite set_of_itvNlt_set0. Qed.

Lemma set_of_itv_pinfty_pinfty : set_of_itv (Interval +oo%O +oo%O) = @set0 R.
Proof. by rewrite set_of_itvNlt_set0. Qed.

Lemma set_of_itv_open_open x y : set_of_itv `]x, y[ = (fun z => x < z < y).
Proof. by []. Qed.

Lemma set_of_itv_closed_closed x y : set_of_itv `[x, y] = (fun z => x <= z <= y).
Proof. by []. Qed.

Lemma set_of_itv_open_closed x y : set_of_itv `]x, y] = (fun z => x < z <= y).
Proof. by []. Qed.

Lemma set_of_itv_closed_open x y : set_of_itv `[x, y[ = (fun z => x <= z < y).
Proof. by []. Qed.

Lemma set_of_itv_ninfty_pinfty : set_of_itv `]-oo, +oo[ = @setT R.
Proof. by rewrite predeqE. Qed.

Lemma set_of_itv_open_pinfty x : set_of_itv `]x, +oo[ = (fun z => x < z).
Proof. by rewrite predeqE /set_of_itv /mkset => r; rewrite in_itv andbT. Qed.

Lemma set_of_itv_closed_pinfty x : set_of_itv `[x, +oo[ = (fun z => x <= z).
Proof. by rewrite predeqE /set_of_itv /mkset => r; rewrite in_itv andbT. Qed.

Lemma set_of_itv_ninfty_open x : set_of_itv `]-oo, x[ = (fun z => z < x).
Proof. by rewrite predeqE /set_of_itv /mkset => r; rewrite in_itv. Qed.

Lemma set_of_itv_ninfty_closed x : set_of_itv `]-oo, x] = (fun z => z <= x).
Proof. by rewrite predeqE /set_of_itv /mkset => r; rewrite in_itv. Qed.

Definition set_of_itvE := (set_of_itv_open_open, set_of_itv_closed_closed,
  set_of_itv_open_closed, set_of_itv_closed_open, set_of_itv_ninfty_pinfty,
  set_of_itv_open_pinfty, set_of_itv_closed_pinfty, set_of_itv_ninfty_open,
  set_of_itv_ninfty_closed, set_of_itv_ninfty_ninfty, set_of_itv_pinfty_ninfty,
  set_of_itv_pinfty_pinfty, set_of_itv_infty_set0).

Section punctured_interval.

Lemma open_closed_set1 x y : x < y ->
  set_of_itv `]x, y] = set_of_itv `]x, y[ `|` [set y].
Proof.
move=> ab; rewrite !set_of_itvE predeqE => r; split=>[/andP[xr]|].
  by rewrite le_eqVlt => /orP[/eqP->|ry]; [by right|left; rewrite xr].
by case=> [/andP[ar /ltW ->]|->]; [rewrite andbT|rewrite ab lexx].
Qed.

Lemma closed_open_set1 x y : x < y ->
  set_of_itv `[x, y[ = [set x] `|` set_of_itv `]x, y[.
Proof.
move=> xy; rewrite !set_of_itvE predeqE => r; split=> [/andP[]|].
  by rewrite le_eqVlt => /orP[/eqP->|xr ry]; [left|right; rewrite xr].
by case=> [->|/andP[/ltW -> -> //]]; rewrite lexx.
Qed.

Lemma closed_closed_set1l x y : x <= y ->
  set_of_itv `[x, y] = [set x] `|` set_of_itv `]x, y].
Proof.
move=> ab; rewrite !set_of_itvE predeqE => r; split=> [/andP[]|].
  by rewrite le_eqVlt => /orP[/eqP->|xr ry]; [left|right; rewrite xr].
by case=> [->|/andP[/ltW -> -> //]]; rewrite lexx.
Qed.

Lemma closed_closed_set1r x y : x <= y ->
  set_of_itv `[x, y] = set_of_itv `[x, y[ `|` [set y].
Proof.
move=> xy; rewrite !set_of_itvE predeqE => r; split=> [/andP[xr]|].
  by rewrite le_eqVlt => /orP[/eqP->|ry]; [right|left; rewrite xr].
by case=> [/andP[-> /ltW //]|->]; rewrite lexx xy.
Qed.

Lemma closed_pinfty_set1 x : set_of_itv `[x, +oo[ = [set x] `|` set_of_itv `]x, +oo[.
Proof.
rewrite predeqE => r; rewrite !set_of_itvE; split; last by case=> [->//|/ltW].
by rewrite le_eqVlt => /orP[/eqP ->|?]; [left|right].
Qed.

Lemma ninfty_closed_set1 x : set_of_itv `]-oo, x] = set_of_itv `]-oo, x[ `|` [set x].
Proof.
rewrite predeqE => r; rewrite !set_of_itvE; split => [|[/ltW //|-> //=]].
by rewrite le_eqVlt => /orP[/eqP ->|xr]; [right|left].
Qed.

End punctured_interval.

End set_of_itv.
Arguments set_of_itv {R}.

Section set_of_itv_numFieldType.
Variable R : numFieldType.
Implicit Types i : interval R.

Lemma set_of_itv_eq0 i : (set_of_itv i == set0) = ~~ neitv i.
Proof.
apply/idP/idP => [/eqP|]; last by move=> ?; rewrite set_of_itvNlt_set0.
apply: contraPN => /mem_itv_center => ii.
by apply/eqP/set0P; exists (itv_center i); apply/set_of_itv_mem.
Qed.

Lemma set_of_itv_neq0 i : (set_of_itv i != set0) = (neitv i).
Proof. by rewrite set_of_itv_eq0 negbK. Qed.

Lemma set_of_itv0P i : set_of_itv i = set0 <-> i =i pred0.
Proof.
move: i => [a b]; split => [/eqP|ab0]; first by rewrite set_of_itv_eq0 => /itv_ge.
apply/eqP; rewrite set_of_itv_eq0; apply: contraPN ab0 => ab0.
by move/(_ (itv_center (Interval a b))); rewrite mem_itv_center.
Qed.

Lemma neitvNpred0 i : neitv i = ~~ `[< i =i pred0 >].
Proof.
apply/idP/idP => [|/asboolP/set_of_itv0P/eqP].
  by rewrite -set_of_itv_neq0; apply: contra => /asboolP/set_of_itv0P/eqP.
by rewrite set_of_itv_neq0.
Qed.

Lemma pred0Nneitv i : `[< i =i pred0 >] = ~~ neitv i.
Proof. by rewrite neitvNpred0 negbK. Qed.

Lemma pred0_hasNsup i : i =i pred0 -> ~ has_sup (set_of_itv i).
Proof.
case: i => a b /= ab0; rewrite /has_sup not_andP; left.
exact/set0P/negP/negPn/eqP/set_of_itv0P.
Qed.

Lemma pred0_hasNinf i : i =i pred0 -> ~ has_inf (set_of_itv i).
Proof.
case: i => a b /= ab0; rewrite /has_inf not_andP; left.
exact/set0P/negP/negPn/eqP/set_of_itv0P.
Qed.

End set_of_itv_numFieldType.

Section interval_has_bound.
Variable R : numDomainType.

Lemma has_lbound_bounded (x y : R) (b0 b1 : bool) :
  has_lbound (set_of_itv (Interval (BSide b0 x) (BSide b1 y))).
Proof. by case: b0; exists x => r /andP[]; rewrite lte_bnd // => /ltW. Qed.

Lemma has_ubound_bounded (x y : R) (b0 b1 : bool) :
  has_ubound (set_of_itv (Interval (BSide b0 x) (BSide b1 y))).
Proof. by case: b1; exists y => r /andP[]; rewrite lte_bnd // => _ /ltW. Qed.

Lemma has_lbound_infty (x : R) b : has_lbound (set_of_itv (Interval (BSide b x) +oo%O)).
Proof. by case: b; exists x => y; rewrite !set_of_itvE // => /ltW. Qed.

Lemma has_ubound_infty (x : R) b : has_ubound (set_of_itv (Interval -oo%O (BSide b x))).
Proof. by case: b; exists x => y // /ltW. Qed.

End interval_has_bound.

Hint Extern 0 (has_lbound (set_of_itv _)) =>
  solve[apply: has_lbound_bounded | apply: has_lbound_infty] : core.
Hint Extern 0 (has_ubound (set_of_itv _)) =>
  solve[apply: has_ubound_bounded | apply: has_ubound_infty] : core.

Section interval_hasNbound.

Lemma hasNubound_setT (R : realDomainType) : ~ has_ubound (@setT R).
Proof. by case=> x /(_ (x + 1) I); apply/negP; rewrite -ltNge ltr_addl. Qed.

Lemma hasNlbound_setT (R : realDomainType) : ~ has_lbound (@setT R).
Proof.
by case=> x /(_ (x - 1) I); apply/negP; rewrite -ltNge ltr_subl_addr ltr_addl.
Qed.

Variable R : realType.

Lemma hasNlbound_ninfty (r : R) b :
  ~ has_lbound (set_of_itv (Interval -oo%O (BSide b r))).
Proof.
suff : ~ has_lbound (set_of_itv `]-oo, r[).
  by case: b => //; apply/ssrbool.contra_not/subset_has_lbound => x /ltW.
apply/has_lbPn => x; exists (minr (r - 1) (x - 1)).
by rewrite !set_of_itvE lt_minl ltr_subl_addr ltr_addl ltr01.
by rewrite lt_minl orbC ltr_subl_addr ltr_addl ltr01.
Qed.

Lemma hasNubound_pinfty (r : R) b :
  ~ has_ubound (set_of_itv (Interval (BSide b r) +oo%O)).
Proof.
suff : ~ has_ubound (set_of_itv `]r, +oo[).
  case: b => //; apply/ssrbool.contra_not/subset_has_ubound => x.
  by rewrite !set_of_itvE => /ltW.
apply/has_ubPn => x; rewrite !set_of_itvE; exists (maxr (r + 1) (x + 1));
by rewrite ?in_itv /= ?andbT lt_maxr ltr_addl ltr01 // orbT.
Qed.

End interval_hasNbound.

Hint Extern 0 (~ has_lbound _) =>
  solve[apply: hasNlbound_setT | apply: hasNlbound_ninfty] : core.
Hint Extern 0 (~ has_ubound _) =>
  solve[apply: hasNubound_setT | apply: hasNubound_pinfty] : core.

Section interval_has.
Variable R : realType.
Implicit Types x : R.

Lemma has_sup_half x b (i : itv_bound R) : (i < BSide b x)%O ->
  has_sup (set_of_itv (Interval i (BSide b x))).
Proof.
move: b i => [] [[]y|[]]; rewrite ?lte_bnd => xy; try
  (split => //; exists ((x + y) / 2); rewrite !set_of_itvE addrC !(midf_le,midf_lt) //; exact: ltW) ||
  (by split => //; exists (x - 1); rewrite !set_of_itvE !(ltr_subl_addr,ler_subl_addr, ltr_addl,ler_addl)).
Qed.

Lemma has_inf_half x b (i : itv_bound R) : (BSide b x < i)%O ->
  has_inf (set_of_itv (Interval (BSide b x) i)).
Proof.
move: b i => [] [[]y|[]]; rewrite ?lte_bnd => xy; try
  (split => //; exists ((x + y) / 2); rewrite !set_of_itvE !(midf_le,midf_lt) //; exact: ltW) ||
  (by split => //; exists (x + 1); rewrite !set_of_itvE !(ltr_addl,ler_addl)).
Qed.

End interval_has.

Hint Extern 0 (has_sup _) => solve[apply: has_sup1 | exact: has_sup_half] : core.
Hint Extern 0 (has_inf _) => solve[apply: has_inf1 | exact: has_inf_half]: core.

Lemma minus_bside_pinfty (R : numDomainType) (x : R) b :
  -%R @` set_of_itv (Interval (BSide b x) +oo%O) =
  set_of_itv (Interval -oo%O (BSide (negb b) (- x))).
Proof.
rewrite predeqE => /= r; split=> [[y xy <-]|xr].
  case: b xy; [by rewrite !set_of_itvE ler_oppl opprK |
  by rewrite !set_of_itvE ltr_oppl opprK].
exists (- r); rewrite ?opprK //.
case: b xr; [by rewrite !set_of_itvE ler_oppr |
  by rewrite !set_of_itvE ltr_oppr].
Qed.

Lemma minus_open_open (R : numDomainType) (x y : R) :
  -%R @` set_of_itv `]x, y[ = set_of_itv `](- y), (- x)[.
Proof.
rewrite predeqE => /= r; split=> [[u /andP[xu uy <-]]|/andP[yr rx]].
rewrite !lte_bnd in xu, uy.
by rewrite !set_of_itvE ltr_oppl opprK uy /= ltr_oppl opprK.
exists (- r); last by rewrite opprK.
rewrite !lte_bnd in yr, rx.
by rewrite !set_of_itvE ltr_oppr rx /= ltr_oppl.
Qed.

Section interval_sup_inf.
Variable R : realType.
Implicit Types x y : R.

Lemma sup_ninfty x b : sup (set_of_itv (Interval -oo%O (BSide b x))) = x.
Proof.
case: b; last first.
  by rewrite ninfty_closed_set1 sup_setU ?sup1 // => ? ? ? ->; exact/ltW.
set s := sup _; apply/eqP; rewrite eq_le; apply/andP; split.
- apply sup_le_ub; last by move=> ? /ltW.
  by exists (x - 1); rewrite !set_of_itvE ltr_subl_addr ltr_addl.
- rewrite leNgt; apply/negP => sx; pose p := (s + x) / 2.
  suff /andP[?]: (p < x) && (s < p) by apply/negP; rewrite -leNgt sup_ub.
  by rewrite !midf_lt.
Qed.

Lemma inf_pinfty x b : inf (set_of_itv (Interval (BSide b x) +oo%O)) = x.
Proof.
case: b; last by rewrite /inf minus_bside_pinfty sup_ninfty opprK.
by rewrite closed_pinfty_set1 inf_setU ?inf1 // => _ b->; rewrite !set_of_itvE => /ltW.
Qed.

Let sup_open_bside x y b : x < y ->
  sup (set_of_itv (Interval (BRight x) (BSide b y))) = y.
Proof.
case: b => xy; last first.
  by rewrite open_closed_set1 // sup_setU ?sup1 // => ? ? /andP[? /ltW ?] ->.
set B := set_of_itv _; set A := set_of_itv `]-oo, x].
rewrite -(@sup_setU _ A B) //.
- rewrite -(sup_ninfty y true); congr sup.
  rewrite predeqE => u; split=> [[|/andP[]//]|yu].
  by rewrite /A !set_of_itvE => /le_lt_trans; apply.
  by have [xu|ux] := ltP x u; [right; rewrite /B !set_of_itvE xu| left].
- by move=> u v; rewrite /A /B => ? /andP[xv _]; rewrite (le_trans _ (ltW xv)).
Qed.

Lemma sup_bounded x y a b : x < y ->
  sup (set_of_itv (Interval (BSide a x) (BSide b y))) = y.
Proof.
case: a => xy; last exact: sup_open_bside.
case: b.
  by rewrite closed_open_set1 // sup_setU ?sup_open_bside // => ? ? -> /andP[/ltW].
rewrite closed_closed_set1r; last exact/ltW.
by rewrite  sup_setU ?sup1// => ? ? /andP[_ /ltW ? ->].
Qed.

Lemma sup_closed_closed x y : x <= y -> sup (set_of_itv `[x, y]) = y.
Proof.
by move=> xy; rewrite closed_closed_set1r // sup_setU ?sup1 // => ? ? /andP[_ /ltW ? ->].
Qed.

Let inf_bside_open x y b : x < y ->
  inf (set_of_itv (Interval (BSide b x) (BLeft y))) = x.
Proof.
case: b => xy.
  by rewrite closed_open_set1// inf_setU ?inf1 // => _ ? -> /andP[/ltW].
by rewrite /inf minus_open_open sup_open_bside ?opprK // ltr_oppl opprK.
Qed.

Lemma inf_bounded x y a b : x < y ->
  inf (set_of_itv (Interval (BSide a x) (BSide b y))) = x.
Proof.
case: b => xy; first exact: inf_bside_open.
case: a.
  rewrite closed_closed_set1l; last exact: ltW.
  by rewrite inf_setU ?inf1 // => ? ? -> /andP[/ltW].
by rewrite open_closed_set1 // inf_setU ?inf_bside_open // => ? ? /andP[? /ltW ?] ->.
Qed.

Lemma inf_closed_closed x y : x <= y -> inf (set_of_itv `[x, y]) = x.
Proof.
by move=> ?; rewrite closed_closed_set1l // inf_setU ?inf1 // => ? ? -> /andP[/ltW].
Qed.

End interval_sup_inf.

(* lemmas between set_of_itv and set-theoretic operations *)
Section set_of_itv_realDomainType.
Variable R : realDomainType.
Implicit Types x y : R.

Lemma set_of_itvC_ninfty_BSide b x :
  ~` set_of_itv (Interval -oo%O (BSide b x)) =
  set_of_itv (Interval (BSide b x) +oo%O).
Proof.
case: b; rewrite !set_of_itvE predeqE => r.
by split; rewrite leNgt => /negP.
by split; rewrite ltNge => /negP.
Qed.

Lemma set_of_itvC_BSide_pinfty b x :
  ~` set_of_itv (Interval (BSide b x) +oo%O) =
  set_of_itv (Interval -oo%O (BSide b x)).
Proof. by rewrite -set_of_itvC_ninfty_BSide setCK. Qed.

Let set_of_itvC_BSide_BSide (b0 b1 : bool) x y :
  ~` set_of_itv (Interval (BSide b0 x) (BSide b1 y)) =
  set_of_itv (Interval -oo%O (BSide b0 x)) `|`
  set_of_itv (Interval (BSide b1 y) +oo%O).
Proof.
move: b0 b1 => [] []; rewrite !set_of_itvE predeqE => r; split.
by move/negP; rewrite negb_and -ltNge -leNgt => /orP.
by move/orP; rewrite leNgt (ltNge r x) -negb_and => /negP.
by move/negP; rewrite negb_and -2!ltNge => /orP.
by move/orP; rewrite 2!ltNge -negb_and => /negP.
by move/negP; rewrite negb_and -2!leNgt => /orP.
by move/orP; rewrite 2!leNgt -negb_and => /negP.
by move/negP; rewrite negb_and -leNgt -ltNge => /orP.
by move/orP; rewrite leNgt (ltNge y r) -negb_and => /negP.
Qed.

Lemma set_of_itvC_Interval (i : interval R) : ~` set_of_itv i =
  set_of_itv (Interval -oo%O i.1) `|` set_of_itv (Interval i.2 +oo%O).
Proof.
case: i => -[[] x|[]] [[] y|[]] /=.
by rewrite set_of_itvC_BSide_BSide.
by rewrite set_of_itvC_BSide_BSide.
by rewrite !set_of_itvE setUT setC0.
by rewrite set_of_itvC_BSide_pinfty !set_of_itvE setU0.
by rewrite set_of_itvC_BSide_BSide.
by rewrite set_of_itvC_BSide_BSide.
by rewrite set_of_itvNlt_set0 // setC0 !set_of_itvE setUT.
by rewrite set_of_itvC_BSide_pinfty !set_of_itvE setU0.
by rewrite set_of_itvC_ninfty_BSide !set_of_itvE set0U.
by rewrite set_of_itvC_ninfty_BSide !set_of_itvE set0U.
by rewrite set_of_itvE setC0 set0U set_of_itvE.
by rewrite !set_of_itvE setCT set0U.
by rewrite !set_of_itvE setTU setC0.
by rewrite !set_of_itvE setTU setC0.
by rewrite set_of_itvNlt_set0 // setC0 !set_of_itvE setTU.
by rewrite !set_of_itvE setC0 setU0.
Qed.

Definition set_of_itvC := (set_of_itvC_ninfty_BSide,
                           set_of_itvC_BSide_pinfty,
                           set_of_itvC_Interval).

Lemma set_of_itv_meet (i j : interval R) :
  set_of_itv (itv_meet i j) = set_of_itv i `&` set_of_itv j.
Proof.
rewrite eqEsubset; split => x; move: i j => [i1 i2] [j1 j2].
- move/set_of_itv_mem => /=.
  rewrite itv_boundlr joinEtotal meetEtotal le_maxl le_minr.
  move=> /andP[/andP[i1x j1x] /andP[xi2 xj2]].
  by split; apply/set_of_itv_mem; rewrite itv_boundlr ?i1x ?xi2 // j1x xj2.
- case => /set_of_itv_mem; rewrite itv_boundlr => /andP[i1x xi2] /set_of_itv_mem.
  rewrite itv_boundlr => /andP[j1x xj2]; apply/set_of_itv_mem.
  by rewrite itv_boundlr joinEtotal meetEtotal le_maxl le_minr i1x xi2 j1x.
Qed.

(* NB: not used *)
Lemma set_of_itv_split (a c b : itv_bound R) : (a <= c <= b)%O ->
  set_of_itv (Interval a b) = set_of_itv (Interval a c) `|` set_of_itv (Interval c b).
Proof.
move=> /andP[ac cb]; rewrite predeqE => r; split.
- rewrite set_of_itv_mem itv_boundlr => /andP[ar rb].
  have [rc|cr] := leP (BRight r) c.
    by left; rewrite set_of_itv_mem itv_boundlr ar rc.
    by right; rewrite set_of_itv_mem itv_boundlr rb andbT ltBRight_leBLeft.
case; rewrite !set_of_itv_mem !itv_boundlr => /andP[].
by move=> -> /le_trans; apply.
by move=> + ->; rewrite andbT; apply le_trans.
Qed.

End set_of_itv_realDomainType.

Section set_of_itv_cancel.
Variable R : realType.

Lemma set_of_itvK : {in neitv, cancel set_of_itv (@Rhull R)}.
Proof.
move=> [[[] i1|[]] [[] i2|[]]]; rewrite /Rhull //=.
- rewrite inE /= lte_bnd => i12.
  rewrite asboolT //= inf_bounded // {1}set_of_itvE lexx i12 asboolT //.
  by rewrite asboolT // sup_bounded // {1}set_of_itvE /= ltW // ltxx asboolF.
- rewrite inE /= lte_bnd => X0.
  rewrite asboolT // inf_closed_closed // {1}set_of_itvE  lexx X0 asboolT //.
  by rewrite asboolT // sup_closed_closed // {1}set_of_itvE X0 lexx asboolT.
- by move=> _; rewrite asboolT // {1}set_of_itvE inf_pinfty lexx asboolT // asboolF.
- rewrite inE /= lte_bnd => i12.
  rewrite asboolT // inf_bounded // {1}set_of_itvE ltxx asboolF // asboolT //.
  by rewrite sup_bounded // {1}set_of_itvE ltxx andbF asboolF.
- rewrite inE /= lte_bnd => i12.
  rewrite asboolT // inf_bounded // {1}set_of_itvE ltxx asboolF // asboolT //.
  by rewrite sup_bounded // {1}set_of_itvE i12 lexx asboolT.
- by move=> _; rewrite asboolT // inf_pinfty {1}set_of_itvE ltxx asboolF // asboolF.
- by move=> _; rewrite asboolF // asboolT // {1}set_of_itvE sup_ninfty ltxx asboolF.
- by move=> _; rewrite asboolF // asboolT // {1}set_of_itvE sup_ninfty lexx asboolT.
- by move=> _; rewrite set_of_itvE asboolF // asboolF.
Qed.

Lemma RhullK : {in [pred X | `[< is_interval X >]], cancel (@Rhull R) set_of_itv}.
Proof.
move=> X /asboolP iX; rewrite /Rhull /set_of_itv /mkset /= predeqE => r.
case: ifPn => /asboolP bX; last first.
  case: ifPn => /asboolP aX; last by rewrite (interval_unbounded_setT _ bX aX).
  rewrite in_itv /= negbK; have [/asboolP XsupX /=|/asboolPn XsupX /=] := boolP `[< _ >].
    split => [|Xr].
      rewrite le_eqVlt => /orP[/eqP -> //|rX].
      move/has_lbPn : bX => /(_ r)[y Xy yr].
      by move: (iX _ _ Xy XsupX); apply; rewrite yr.
    by rewrite /mkset sup_ub //; exact/asboolP.
  split => [rX|Xr]; last exact: sup_ub_strict.
  apply: (@interior_subset [topologicalType of R^o]).
  by rewrite interval_left_unbounded_interior.
case: ifPn => /asboolP uX.
  have [/asboolP XinfX | /asboolPn XinfX ] := boolP `[< _ >].
    rewrite in_itv /= negbK; have [/asboolP XsupX /=|/asboolP XsupX /=] := boolP `[< _ >].
      split=> [|Xr]; last first.
        by rewrite /mkset sup_ub // andbT inf_lb.
      move => /andP[]; rewrite le_eqVlt => /orP[/eqP <- //|infXr].
      rewrite le_eqVlt => /orP[/eqP -> //|rsupX].
      apply: (@interior_subset [topologicalType of R^o]).
      by rewrite interval_bounded_interior //; rewrite /mkset infXr.
    split => [|Xr].
      rewrite /mkset => /andP[]; rewrite le_eqVlt => /orP[/eqP <- //|infXr rsupX].
      apply: (@interior_subset [topologicalType of R^o]).
      by rewrite interval_bounded_interior //; rewrite /mkset infXr.
    by rewrite /mkset inf_lb //= sup_ub_strict.
  have [/asboolP XsupX /=|/asboolP XsupX /=] := boolP `[< _ >].
    rewrite in_itv /=; split=> [|Xr]; last first.
      by rewrite inf_lb_strict // sup_ub.
    move=> /andP[infXr]; rewrite le_eqVlt => /orP[/eqP -> //|rsupX].
    apply: (@interior_subset [topologicalType of R^o]).
    by rewrite interval_bounded_interior //; rewrite /mkset infXr.
  rewrite in_itv /=; split=> [|Xr]; last first.
    by rewrite inf_lb_strict // sup_ub_strict.
  move => /andP[infXr rsupX].
  apply: (@interior_subset [topologicalType of R^o]).
  by rewrite interval_bounded_interior //; rewrite /mkset infXr.
rewrite in_itv /=; have [/asboolP XinfX /=| /asboolPn XinfX /=] := boolP `[< _ >].
  rewrite andbT; split => [|Xr]; last exact: inf_lb.
  rewrite le_eqVlt => /orP[/eqP <- //|infXr].
  move/has_ubPn : uX => /(_ r)[y Xy yr].
  by move: (iX _ _ XinfX Xy); apply; rewrite infXr.
rewrite andbT.
split=> [infXr|Xr]; last exact: inf_lb_strict.
apply: (@interior_subset [topologicalType of R^o]).
by rewrite interval_right_unbounded_interior.
Qed.

End set_of_itv_cancel.

Lemma absurdb {b : bool} {C : Prop} : b -> ~~ b -> C.
Proof. by move=> h /negP. Qed.

Lemma absurdNb {b : bool} {C : Prop} : ~~ b -> b -> C.
Proof. by move=> /negP. Qed.

Arguments absurd {_} {_}.

Lemma absurdnot {A C : Prop} : ~ A -> A -> C.
Proof. by []. Qed.

Lemma set_of_itv_setT (R : realType) (i : interval R) :
  set_of_itv i = setT -> i = `]-oo, +oo[.
Proof.
have [i0 iT|i0 /(congr1 (@Rhull _))] := pselect (i =i pred0).
  apply: (absurd i0) => /set_of_itv0P; rewrite iT predeqE => /(_ 0).
  by case=> + _; exact.
rewrite set_of_itvK.
  by move=> ->; rewrite /Rhull asboolF // asboolF.
by rewrite -topredE /= neitvNpred0; apply/asboolP.
Qed.

(* NB: not used *)
Lemma itv_boundNpinfty (R : numDomainType) (a : itv_bound R) :
  a != +oo%O <-> (a = -oo%O \/ exists b r, a = BSide b r).
Proof.
move: a => [b r|[]] => /=; split => //.
- by move=> _; right; exists b, r.
- by move=> _; left.
- by move=> [//|[b [r //]]].
Qed.

(* NB: not used *)
Lemma itv_boundNninfty (R : numDomainType) (a : itv_bound R) :
  a != -oo%O <-> (a = +oo%O \/ exists b r, a = BSide b r).
Proof.
move: a => [b r|[]] => /=; split => //.
- by move=> _; right; exists b, r.
- by move=> [//|[b [r //]]].
- by move=> _; left.
Qed.

Lemma trivIset_set_of_itv_nth (R : numDomainType) def (s : seq (interval R))
  (D : set nat) : set_of_itv def = set0 ->
  trivIset D (fun i => set_of_itv (nth def s i)) <->
    trivIset D (fun i => nth set0 (map set_of_itv s) i).
Proof.
move=> def0; split=> /trivIsetP ss; apply/trivIsetP => i j Di Dj ij.
- have [si|si] := ltP i (size s); last first.
    by rewrite (nth_default set0) ?size_map// set0I.
  have [sj|sj] := ltP j (size s); last first.
    by rewrite setIC (nth_default set0) ?size_map// set0I.
  by rewrite (nth_map def) // (nth_map def) // ss.
- have [?|h] := ltP i (size s); last by rewrite (nth_default def h) def0 set0I.
  have [?|h] := ltP j (size s); last by rewrite (nth_default def h) def0 setI0.
  by have := ss _ _ Di Dj ij; rewrite (nth_map def) // (nth_map def).
Qed.
Arguments trivIset_set_of_itv_nth {R} _ {s}.

(* NB: not used *)
Lemma non_empty_bnd1 (R : numFieldType) (s : seq (interval R)) :
  all (fun j => [set x | x \in j] != set0) s -> forall i, i \in s -> i.1 != +oo%O.
Proof.
move=> /allP sne [a b] si /=; apply/negP => /eqP boo.
by move: si; rewrite boo => /sne; rewrite set_of_itv_neq0.
Qed.

Lemma non_empty_bnd2 (R : numFieldType) (s : seq (interval R)) :
  all neitv s -> forall i, i \in s -> i.2 != -oo%O.
Proof.
move=> /allP sne [a b] si /=; apply/negP => /eqP boo.
move: si; rewrite boo => /sne.
by rewrite -set_of_itv_neq0 set_of_itv_bnd_ninfty => /negP.
Qed.

(* NB subitvP : forall d (T : porderType d) (i1 i2 : interval T), (i1 <= i2)%O -> {subset i1 <= i2} *)
Lemma subitvP' (R : realFieldType) (i1 i2 : interval R) : {subset i1 <= i2} -> (i1 <= i2)%O.
Proof.
Abort.

Section simple_sets.
Variable R : numDomainType.
Implicit Types (s : seq (interval R)) (i : interval R).

Definition sset s := \big[setU/set0]_(x <- s) set_of_itv x.

Local Notation "[ 'sset' 'of' s ]" := (sset s).

Lemma ssetE s : [sset of s] = \big[setU/set0]_(x <- s) (set_of_itv x).
Proof. by []. Qed.

Lemma sset_cons i s : [sset of i :: s] = set_of_itv i `|` [sset of s].
Proof. by rewrite ssetE big_cons -ssetE. Qed.

Lemma sset_nil : [sset of @nil (interval R)] = set0.
Proof. by rewrite ssetE big_nil. Qed.

Lemma sset_cons1 i : [sset of [:: i]] = set_of_itv i.
Proof. by rewrite sset_cons sset_nil setU0. Qed.

Lemma sset_bigcup s :
  [sset of s] = \bigcup_(i in [set j | j \in s]) (set_of_itv i).
Proof. by rewrite bigcup_set. Qed.

Lemma ssetP s x :
  [sset of s] x <-> (\bigcup_(i in [set j | j \in s]) (set_of_itv i)) x.
Proof. by rewrite -sset_bigcup. Qed.

Lemma sseti s1 s2 : s1 =i s2 -> [sset of s1] = [sset of s2].
Proof.
move=> s12; rewrite 2!sset_bigcup eqEsubset; split => x [i]; rewrite /mkset => + ix.
by rewrite s12 => ?; exists i.
by rewrite -s12 => ?; exists i.
Qed.

Lemma sset_filter_neitv s : [sset of [seq x <- s | neitv x]] = [sset of s].
Proof.
elim: s => // h t ih /=; case: ifPn => [h0|h0].
  by rewrite sset_cons ih -sset_cons.
by rewrite sset_cons ih set_of_itvNlt_set0// set0U.
Qed.

End simple_sets.
Notation "[ 'sset' 'of' s ]" := (sset s).

Notation bnd1eta := (fun (i : interval _) => i.1).
Notation bnd2eta := (fun (i : interval _) => i.2).

Section itv_cplt.
Variable R : realType.
Implicit Types s : seq (interval R).

Definition itv_cplt s : seq (interval R) :=
  let a' := -oo%O :: map bnd2eta s in
  let b' := rcons (map bnd1eta s) +oo%O in
  map (uncurry (@Interval _)) (zip a' b').

Lemma itv_cplt_nil : [sset of itv_cplt [::]] = setT.
Proof. by rewrite /itv_cplt ssetE big_seq1 set_of_itvE. Qed.

Lemma itv_cpltE1 s : ~` [sset of s] `<=` [sset of itv_cplt s].
Proof.
elim: s => [x _|[a1 b1] t ih x]; first by rewrite itv_cplt_nil.
rewrite sset_cons setCU => -[] x_notin_h /ih {}ih.
set a := map bnd1eta (Interval a1 b1 :: t).
set b := map bnd2eta (Interval a1 b1 :: t).
rewrite (_ : itv_cplt _ = Interval -oo%O a1 ::
  map (uncurry (@Interval _)) (zip b (rcons (behead a) +oo%O))) //.
rewrite sset_cons.
have : (set_of_itv (Interval -oo%O a1) `|` set_of_itv (Interval b1 +oo%O)) x.
  by rewrite set_of_itvC in x_notin_h.
case=> [xa1|/set_of_itv_mem xb1]; [by left|right].
have {ih} /ssetP[j] : [sset of map (uncurry (@Interval _))
  (zip (-oo%O :: behead b) (rcons (behead a) +oo%O))] x by [].
rewrite {1}/mkset => + /set_of_itv_mem jx.
rewrite {}/b {}/a.
move: t => [|[a2 b2] t /=]; first by rewrite sset_cons1.
rewrite inE => /orP[/eqP jb2|jb2].
  apply/ssetP; exists (Interval b1 a2); first by rewrite /mkset inE eqxx.
  apply/set_of_itv_mem; rewrite itv_splitI xb1 /=.
  by move: jx; rewrite jb2 => /set_of_itv_mem.
by apply/ssetP; exists j => //; rewrite /mkset inE jb2 orbT.
Qed.

Lemma itv_cpltE2 s :
  sorted <=%O (map bnd2eta s) -> sorted <=%O (map bnd1eta s) ->
  [sset of itv_cplt s] `<=` ~` [sset of s].
Proof.
set a := map bnd1eta s.
set b := map bnd2eta s.
move=> sorted_b sorted_a x.
move=> /ssetP[/= j] /mapP[[b' a']] /(nthP (+oo%O, -oo%O)) => -[k'].
rewrite size_zip /= size_rcons 2!size_map minnn ltnS => k's.
rewrite nth_zip; last by rewrite size_rcons /= !size_map.
move=> -[kb' ka'] jba'.
move/set_of_itv_mem => xj /ssetP[] i si /set_of_itv_mem xi.
have [k [ks ik]] : exists k, (k < size s)%N /\
    i = Interval (nth -oo%O a k) (nth +oo%O b k).
  move/(nthP 0%O) : si => [k ks ki].
  exists k; split => //.
  by rewrite /a /b !(nth_map 0%O) // ki; case: i {xi ki}.
move: xi; rewrite ik itv_boundlr => /andP[akx xbk].
move: xj; rewrite jba' itv_boundlr => /andP[b'x xa'].
rewrite -/a in ka'.
rewrite -/b in kb'.
have [kk'|k'k] := leP k k'.
  case: k' => [|k'] in k's ka' kb' kk' *.
    move: kk'; rewrite lex0 => /eqP k0.
    rewrite {k's ks} /= in kb' jba' b'x xa'.
    rewrite -{}kb' {b'x b'} in jba'.
    rewrite -ka' /= in xa'.
    rewrite k0 /a /= in akx.
    rewrite {jba' k0 ka' xbk ik k sorted_a sorted_b a' b j}.
    rewrite {}/a in xa'.
    case: s => [//|s0 s1] in si akx xa' *.
    have := le_trans xa' akx.
    by rewrite lte_bnd ltxx.
  rewrite /= in kb'.
  have : (k' <= (size s).-1)%N by move: k's; clear -si; case: s si.
  rewrite leq_eqVlt => /orP[/eqP k's1|k's1].
    move: ka'; rewrite nth_rcons size_map k's1 prednK //; last first.
      by move: k's; clear -si; case: s si.
    rewrite ltnn eqxx => ka'.
    have : (BRight x <= BLeft x)%O.
      rewrite (le_trans xbk) // (le_trans _ b'x) //= -kb'.
      apply: (sorted_leq_nth le_trans) => //.
      by rewrite inE /b size_map.
      by rewrite inE size_map.
      by rewrite -ltnS k's1 prednK // (leq_ltn_trans _ ks).
    by rewrite lte_bnd ltxx.
  move: kk'; rewrite le_eqVlt => /orP[kk'|kk'].
    have : (BRight x <= BLeft x)%O.
      rewrite (@le_trans _ _ (nth -oo%O a k)) // (le_trans xa') // -ka'.
      by rewrite nth_rcons size_map -(eqP kk') ks.
    by rewrite lte_bnd ltxx.
  have : (BRight x <= BLeft x)%O.
    rewrite (@le_trans _ _ (nth +oo%O b k)) // (le_trans _ b'x) //= -kb'.
    apply: (sorted_leq_nth le_trans) => //.
    by rewrite inE /b size_map.
    by rewrite inE size_map.
  by rewrite lte_bnd ltxx.
have : (BRight x <= BLeft x)%O.
  rewrite (le_trans xa') //= (le_trans _ akx) //.
  rewrite -ka' nth_rcons size_map (ltn_trans k'k ks).
  apply: (sorted_leq_nth le_trans) => //.
  by rewrite inE size_map (ltn_trans k'k).
  by rewrite inE size_map.
  by rewrite ltnW.
by rewrite lte_bnd ltxx.
Qed.

Lemma itv_cpltE s : sorted <=%O (map bnd2eta s) -> sorted <=%O (map bnd1eta s) ->
  [sset of itv_cplt s] = ~` [sset of s].
Proof. by rewrite eqEsubset; split; [exact: itv_cpltE2 | exact: itv_cpltE1]. Qed.

Definition itv_cplt_ne s := [seq x <- itv_cplt s | neitv x].

Lemma itv_cplt_neE s : sorted <=%O (map bnd2eta s) -> sorted <=%O (map bnd1eta s) ->
  [sset of itv_cplt_ne s] = ~` [sset of s].
Proof.
move=> sorted_a sorted_b.
by rewrite /itv_cplt_ne sset_filter_neitv itv_cpltE.
Qed.

End itv_cplt.

Section itv_diff.
Variable R : realType.
Implicit Types i j : interval R.

(* assumes ~ j <= i *)
Definition itv_diff i j := if ~~ neitv (itv_meet i j) then i
  else
    let: Interval i1 i2 := i in let: Interval j1 j2 := j in
    if (j1 <= i1)%O then
      (if (j2 <= i2)%O then Interval j2 i2 else 0%O)
    else
      (if (j2 <= i2)%O then 0%O else Interval i1 j1).

Lemma set_of_itv_diff i j :
  (~~ (j <= i)%O) || ((j <= i)%O && (j.1 == i.1)) ->
  set_of_itv (itv_diff i j) = set_of_itv i `\` set_of_itv j.
Proof.
move=> ji.
rewrite /itv_diff; case: ifPn => [ij0|/negPn ij0].
  by apply/esym/setDidPl; rewrite -set_of_itv_meet; apply/eqP; rewrite set_of_itv_eq0.
move: i j => [i1 i2] [j1 j2] /= in ji ij0 *.
have [ji1|ji1] := leP j1 i1.
- have [ji2|ji2] := leP j2 i2.
  + rewrite eqEsubset; split => x.
    * move/set_of_itv_mem; rewrite itv_boundlr => /andP[j2x xi2]; split.
        apply/set_of_itv_mem.
        rewrite itv_boundlr xi2 andbT (@le_trans _ _ j2) // leNgt; apply/negP => j2j1.
        apply/negP : ij0.
        rewrite joinEtotal meetEtotal maxElt ltNge ji1 /= minElt ltNge ji2 /=.
        by rewrite /neitv /= -leNgt ltW.
      move/set_of_itv_mem; rewrite itv_boundlr => /andP[j1x xj2].
      by have := le_trans xj2 j2x; rewrite lte_bnd ltxx.
    * move=> -[/set_of_itv_mem]; rewrite itv_boundlr => /andP[i1x xi2 ix].
      apply/set_of_itv_mem; rewrite itv_boundlr xi2 andbT.
      rewrite leNgt; apply/negP => xj2.
      apply: ix.
      apply/set_of_itv_mem.
      by rewrite itv_boundlr (le_trans ji1).
  + rewrite set_of_itvE; apply/esym.
    rewrite setD_eq0 => x.
    move/set_of_itv_mem; rewrite itv_boundlr => /andP[i1x xi2].
    apply/set_of_itv_mem; rewrite itv_boundlr (le_trans ji1) //=.
    by rewrite (le_trans xi2) // ltW.
- have [ji2|ji2] := leP j2 i2.
    case/orP: ji => [ji|/andP[ji j1i1]].
      apply: absurdb ji.
      by rewrite itv_leEmeet/= (join_l (ltW _))// meet_l.
    by rewrite gt_eqF in j1i1.
  rewrite eqEsubset; split => x.
  * move/set_of_itv_mem; rewrite itv_boundlr => /andP[i1x xj1]; split.
      apply/set_of_itv_mem; rewrite itv_boundlr i1x /= leNgt; apply/negP => i2j1.
      apply/negP : ij0.
      rewrite meetEtotal minElt ji2 joinEtotal maxElt ji1 /neitv /=.
      by rewrite -leNgt (le_trans _ xj1) // (le_trans (ltW i2j1)).
    move/set_of_itv_mem; rewrite itv_boundlr => /andP[j1x xj2].
    by have := le_trans xj1 j1x; rewrite lte_bnd ltxx.
  * move=> -[/set_of_itv_mem]; rewrite itv_boundlr => /andP[i1x xi2] /set_of_itv_mem.
    rewrite itv_boundlr => /negP; rewrite negb_and -2!ltNge => /orP[xj1|j2x].
      by apply/set_of_itv_mem; rewrite itv_boundlr i1x.
    by have := lt_trans (le_lt_trans xi2 ji2) j2x; rewrite ltxx.
Qed.

Lemma set_of_itv_diffxx i : set_of_itv (itv_diff i i) = set0.
Proof. by rewrite set_of_itv_diff ?setDv// lexx eqxx. Qed.

End itv_diff.

Definition disjoint_itv {R : numDomainType} : rel (interval R) :=
  fun a b => [disjoint (set_of_itv a) & (set_of_itv b)].

Lemma disjoint_itvP {R : realFieldType} (i j : interval R) :
  disjoint_itv i j <-> itv_meet i j =i pred0.
Proof.
case: i j => [a b] [c d]; rewrite /disjoint_itv /= -set_of_itv_meet; split.
  by move/eqP/set_of_itv0P.
by move=> ij0; apply/eqP/set_of_itv0P.
Qed.

Lemma lt_disjoint (R : numDomainType) (i j : interval R) :
  (forall x y, x \in i -> y \in j -> x < y) -> disjoint_itv i j.
Proof.
move=> ij; apply/eqP; rewrite predeqE => x; split => // -[].
move/set_of_itv_mem => xi /set_of_itv_mem xj.
by have := ij _ _ xi xj; rewrite ltxx.
Qed.

Lemma path_disjoint_setT_eq0 (R : numDomainType) (t : seq (interval R)) :
  all (fun x => set_of_itv x != set0) t ->
  path disjoint_itv `]-oo, +oo[ t ->
  t = [::].
Proof.
case: t => // h t /= /andP[/set0P[x hx] ne] /andP[hT].
by apply: (absurdb hT); rewrite /disjoint_itv; apply/set0P; exists x.
Qed.

Section lt_itv.
Variable R : realFieldType.
Implicit Types i j : interval R.

Definition lt_itv i j := (i.1 < j.1)%O || ((i.1 == j.1) && (i.2 < j.2)%O).

Definition le_itv i j := (i == j) || (lt_itv i j).

Lemma lt_itvxx i : lt_itv i i = false.
Proof. by rewrite /lt_itv 2!ltxx andbF. Qed.

Lemma lt_itv_def i j : lt_itv i j = (j != i) && le_itv i j.
Proof.
rewrite /le_itv andb_orr eq_sym andNb /=; apply/idP/idP => [ij|/andP[]//].
by rewrite andbC ij /=; apply: contraPN ij => /eqP ->; rewrite lt_itvxx.
Qed.

Lemma le_itv_refl : reflexive le_itv.
Proof. by case=> a b; rewrite /le_itv eqxx. Qed.

Lemma le_itv_anti : antisymmetric le_itv.
Proof.
move=> /= [a b] [c d]; rewrite /le_itv => /andP[/orP[/eqP[-> -> //]|]].
rewrite /lt_itv /= => /orP[ac /orP[/eqP//|]|/andP[/eqP ac bd]].
  by rewrite ltNge (ltW ac) /= eq_sym lt_eqF.
by rewrite ac eqxx ltxx /= ltNge (ltW bd) orbF => /eqP.
Qed.

Lemma lt_itv_trans : transitive lt_itv.
Proof.
move=> [k1 k2] [i1 i2] [j1 j2]; rewrite /lt_itv /=.
case: (ltgtP i1 k1) => // [ik1 _| <-{k1} ik2]; last first.
  by case: (ltgtP i1 j1) => // _; apply: lt_trans.
by case: (ltgtP k1 j1) => // [kj1 _|<-]; [rewrite (lt_trans ik1) | rewrite ik1].
Qed.

Lemma le_itv_trans : transitive le_itv.
Proof.
move=> j i k; rewrite /le_itv.
move=> /orP[/eqP -> //|ij] /orP[/eqP <-|jk]; first by rewrite orbC ij.
by rewrite (lt_itv_trans ij jk) orbT.
Qed.

Definition le_itv_porderMixin :=
  LePOrderMixin lt_itv_def le_itv_refl le_itv_anti le_itv_trans.
Fact le_itv_display (disp : unit) : unit. Proof. exact. Qed.
Definition le_itv_porderType (disp : unit) :=
  POrderType (le_itv_display disp) (interval R) le_itv_porderMixin.

Lemma le_lt_trans_itv j i k : le_itv i j -> lt_itv j k -> lt_itv i k.
Proof. exact: (@le_lt_trans _ (le_itv_porderType _)). Qed.

Lemma lt_le_trans_itv j i k : lt_itv i j -> le_itv j k -> lt_itv i k.
Proof. exact: (@lt_le_trans _ (le_itv_porderType _)). Qed.

Lemma ltW_itv i j : lt_itv i j -> le_itv i j.
Proof. exact: (@ltW _ (le_itv_porderType _)). Qed.

Lemma total_le_itv : total le_itv.
Proof.
move=> [i1 i2] [j1 j2]; rewrite /le_itv/lt_itv/=; case/boolP: (_ == _) => ij//=.
case: (ltgtP i1 j1) => //=; rewrite ?orbT // => ij1.
by rewrite ij1; case: ltgtP => //=; rewrite ?orbT// => ->; rewrite eqxx.
Qed.

Definition le_itv_orderMixin :=
  LeOrderMixin lt_itv_def (fun _ _ => erefl) (fun _ _ => erefl)
               le_itv_anti le_itv_trans total_le_itv.
Fail Canonical le_itv_latticeType := LatticeType (interval R) le_itv_orderMixin.

Let lt_itv_lt i j : lt_itv i j -> disjoint_itv i j ->
  forall x y, x \in i -> y \in j -> x < y.
Proof.
move: i j => [a b] [c d]; rewrite /lt_itv; case: (ltgtP a c) => // [ac _|<-{c}].
- rewrite /disjoint_itv -set_of_itv_meet => /eqP/set_of_itv0P ij0 x y.
  rewrite 2!itv_boundlr => /andP[ax xb] /andP[cy yd].
  have [bc|cb] := leP b c; first by have := le_trans xb (le_trans bc cy).
  rewrite ltNge; apply/negP => yx.
  have /negP := ij0 y; apply; apply/itv_meet_mem; rewrite 2!itv_boundlr.
  by rewrite (le_trans (ltW ac)) //= (le_trans _ xb) // yd andbT cy.
- move=> /= ?; rewrite /disjoint_itv -set_of_itv_meet => /eqP/set_of_itv0P abd.
  move=> x y; rewrite 2!itv_boundlr => /andP[ax xb] /andP[ay yd].
  rewrite ltNge; apply/negP => yx; have /negP := abd x.
  apply; apply/itv_meet_mem; split => //; rewrite itv_boundlr ax //=.
  by rewrite (le_trans xb) // ltW.
Qed.

Lemma lt_itv_le i j : le_itv i j -> disjoint_itv i j ->
  forall x y, x \in i -> y \in j -> x < y.
Proof.
move: i j => [i1 i2] [j1 j2].
move/orP => [/eqP[<-{j1} <-{j2}]|]; last exact: lt_itv_lt.
have [i1i2|i1i2 _ x y] := ltP i1 i2; last by rewrite itv_ge // -leNgt.
apply: absurdNb.
by rewrite /disjoint_itv -set_of_itv_meet set_of_itv_neq0 /= meetxx joinxx.
Qed.

Let lt_itv_subset i j k (r : R) : r \in i -> r \in k -> r \notin j ->
  lt_itv i j -> lt_itv j k ->
  (i <= j)%O \/ (j <= i)%O.
Proof.
move: i j k => [a1 a2] [b1 b2] [c1 c2] + + + ab bc; move: bc ab => /=.
rewrite /lt_itv /=; case: (ltgtP b1 c1) => //= [b1c1 _|<-{c1} b2c2]; last first.
  case : (ltgtP a1 b1) => //= [a1b1 _|<-{b1} a2b2]; last first.
    rewrite 2!itv_boundlr => /andP[a1x xa2] /andP[_ xc2] _; left.
    by rewrite itv_leEmeet/= joinxx (meet_l (ltW _)).
  rewrite 3!itv_boundlr => /andP[a1x xa2] /andP[b1x xc2].
  rewrite negb_and -2!ltNge => xb1b2; right.
  rewrite itv_leEmeet /= (join_l (ltW _))//.
  case/orP: xb1b2 => [|?]; first by move/(le_lt_trans b1x); rewrite ltxx.
  by rewrite meet_l // (le_trans _ xa2) //= ltW.
case : (ltgtP a1 b1) => // [a1b1 _|-> // a2b2].
  rewrite 3!itv_boundlr => /andP[a1x xa2] /andP[c1x xc2].
  rewrite negb_and -2!ltNge => xb1b2; right.
  rewrite itv_leEmeet /= (join_l (ltW _))//; case/orP: xb1b2 => [xb1|b2x].
    by have := lt_trans (lt_le_trans b1c1 c1x) xb1; rewrite ltxx.
  by rewrite meet_l//= (le_trans _ xa2) // ltW.
rewrite 3!itv_boundlr => /andP[b1x xa2] _ _; left.
by rewrite itv_leEmeet/= joinxx (meet_l (ltW _)).
Qed.

Lemma le_itv_subset i j k (r : R) :
  r \in i -> r \in k -> r \notin j ->
  le_itv i j -> le_itv j k ->
  (i <= j)%O \/ (j <= i)%O.
Proof.
move=> xa xc xb /orP[/eqP <- _|ab]; [by left|].
move/orP => [/eqP bc|]; last exact: (lt_itv_subset _ xc).
by move: xb; rewrite bc xc.
Qed.

End lt_itv.
Arguments lt_itv {R}.
Arguments le_itv {R}.
Arguments lt_itv_trans {R}.
Arguments le_itv_trans {R}.
Arguments total_le_itv {R}.
Arguments le_itv_refl {R}.
Arguments le_itv_anti {R}.

Lemma perm_eq_trivIset_new {T : eqType} (s1 s2 : seq (set T)) (D : set nat) :
  [set k | (k < size s1)%N] `<=` D -> perm_eq s1 s2 ->
  trivIset D (fun i => nth set0 s1 i) -> trivIset D (fun i => nth set0 s2 i).
Proof.
move=> s1D.
rewrite perm_sym => /(perm_iotaP set0)[s ss1 s12] /trivIsetP ts1.
apply/trivIsetP => i j Di Dj ij.
rewrite {}s12 {s2}; have [si|si] := ltnP i (size s); last first.
  by rewrite (nth_default set0) ?size_map// set0I.
rewrite (nth_map O) //; have [sj|sj] := ltnP j (size s); last first.
  by rewrite (nth_default set0) ?size_map// setI0.
rewrite (nth_map O) // ts1 //.
  apply s1D; rewrite /mkset.
  have : nth O s i \in iota 0 (size s1) by rewrite -(perm_mem ss1) mem_nth.
  by rewrite mem_iota leq0n add0n.
  apply s1D; rewrite /mkset.
  have : nth O s j \in iota 0 (size s1) by rewrite -(perm_mem ss1) mem_nth.
  by rewrite mem_iota leq0n add0n.
by rewrite nth_uniq // (perm_uniq ss1) iota_uniq.
Qed.

Lemma trivIset_sort (R : realFieldType) (s : seq (interval R)) (D : set nat) :
  [set k | (k < size s)%N] `<=` D ->
  trivIset D (fun i => set_of_itv (nth 0%O s i)) ->
  trivIset D (fun i => set_of_itv (nth 0%O (sort le_itv s) i)).
Proof.
move=> sD ts.
rewrite trivIset_set_of_itv_nth ?set_of_itvE//.
apply (@perm_eq_trivIset_new _ (map set_of_itv s)).
- by apply: subset_trans _ sD => /= i; rewrite size_map.
- by rewrite perm_map // perm_sym perm_sort.
- by rewrite -(@trivIset_set_of_itv_nth _ 0%O) ?set_of_itvE.
Qed.

Lemma sset_sort_le_itv (R : realType) (s : seq (interval R)) :
  [sset of sort le_itv s] = [sset of s].
Proof. exact/sseti/mem_sort. Qed.

Section lt_itv_diff.
Variable R : realType.
Implicit Types i j : interval R.

Lemma lt_itv_diff i j : lt_itv i j -> ~~ (j <= i)%O -> ~~ (i <= j)%O ->
  lt_itv (itv_diff i j) j.
Proof.
rewrite /itv_diff; case: ifPn => //; move: i j => [a b] [c d] /=.
rewrite /lt_itv /=; case: ltgtP => [ab _ _ ji ijb|//|/= <-{c} ij0 bd _ abd].
  have [db|db] /= := leP d b; last by rewrite ab.
  by apply: (absurdNb ji); rewrite itv_leEmeet /= (join_l (ltW _))// meet_l.
rewrite leNgt bd /=.
by apply: (absurdNb abd); rewrite itv_leEmeet /= joinxx (meet_l (ltW _)).
Qed.

Lemma le_itv_diff i j : le_itv i j -> ~~ (j <= i)%O -> ~~ (i <= j)%O ->
  le_itv (itv_diff i j) j.
Proof.
rewrite /le_itv => /orP[/eqP <-{j}|]; first by rewrite lexx.
by move=> ab sba sab; apply/orP; right; exact: lt_itv_diff.
Qed.

Lemma lt_itv_itv_diff k i j : ~~ (j <= i)%O -> disjoint_itv k i ->
  lt_itv i j -> lt_itv k i -> lt_itv k j ->
  lt_itv k (itv_diff i j).
Proof.
move: k i j => [k1 k2] [a1 a2] [b1 b2] /=; rewrite /lt_itv /=.
case: (ltgtP a1 b1) => [a1b1 ba + _| // | <-{b1}].
  have a2b2 : (a2 < b2)%O.
    rewrite ltNge; apply: contra ba => b2a2.
    by rewrite itv_leEmeet /= (join_l (ltW _))// meet_l.
  move: ba a1b1; case: (ltgtP k1 a1) => [k1a1 _ a1b1 ya _ _| //|<-{a1} ba a1b1 ya /= k2a2 _].
    rewrite /itv_diff; case: ifPn => [_|ab0]; first by rewrite k1a1.
    by rewrite leNgt a1b1 /= leNgt a2b2 /= k1a1.
  rewrite /itv_diff; case: ifPn => [_|/negPn ab0]; first by rewrite ltxx eqxx.
  rewrite leNgt a1b1 /= leNgt a2b2 /= ltxx eqxx /=.
  rewrite ltNge; apply: contraPN ya => b1k2 /disjoint_itvP /=.
  move/asboolP; apply/negP; rewrite -neitvNpred0.
  by rewrite /neitv /= joinxx (meet_l (ltW k2a2)) (lt_le_trans a1b1) // leNgt.
case: (ltgtP k1 a1) => [k1a1 ab ya /= a2b2 _ _| // |<-{a1} ab ya /= a2b2 k2a2 k2b2].
  rewrite /itv_diff; case: ifPn => [_|ab0]; first by rewrite k1a1.
  by rewrite lexx leNgt a2b2 /= (lt_le_trans k1a1) // bound_lex1.
rewrite /itv_diff; case: ifPn => [_|/negPn ab0]; first by rewrite ltxx eqxx.
rewrite lexx leNgt a2b2 /= (ltNge k2) bound_le0x andbF orbF ltNge.
apply: contraPN ab0; rewrite ge_pinfty => /eqP k1oo.
by rewrite /neitv /= k1oo join_r // set_of_itvNlt_set0.
Qed.

Lemma le_itv_itv_diff0 i j : set_of_itv i = set0 -> le_itv i (itv_diff i j).
Proof.
move=> i0.
by rewrite /itv_diff -set_of_itv_neq0 set_of_itv_meet i0 set0I negbK eqxx /le_itv eqxx.
Qed.

Lemma le_itv_itv_diff k i j : ~~ (j <= i)%O -> disjoint_itv k i ->
  le_itv i j -> le_itv k i -> le_itv k j ->
  le_itv k (itv_diff i j).
Proof.
move=> ji ki; rewrite {1}/le_itv => /orP[/eqP ij|ij].
  by apply: (absurdNb ji); rewrite ij lexx.
rewrite {1}/le_itv => /orP[/eqP ya|ya].
  move: ki; rewrite {}ya {k} => ii.
  have [/eqP a0 _|a0 _] := boolP (set_of_itv i == set0).
    exact: le_itv_itv_diff0.
  by apply: (absurd ii); apply/negP; rewrite /disjoint_itv setIid.
move/orP => [/eqP kj|kj].
by move: ya; rewrite kj => /(lt_itv_trans _ _ _ ij); rewrite lt_itvxx.
by apply/orP; right; exact: lt_itv_itv_diff.
Qed.

End lt_itv_diff.

Section lt_itv_disjoint.
Variable R : realType.

Lemma nonempty_sorted_disjoint_itv h (t : seq (interval R)) :
  all neitv t ->
  sorted le_itv (h :: t) ->
  path disjoint_itv h t ->
  (forall c, c \in t -> disjoint_itv h c).
Proof.
elim: t h => [h t0 _ _ c //|b t ih a t0 /= /andP[lt_ab lt_bt] /andP[dis_ab dis_bt] c].
rewrite inE => /orP[/eqP ->{c} //|ct]; apply: ih => //.
- by move: t0; rewrite /= => /andP[].
- by rewrite (mask_second b) (sorted_mask (@le_itv_trans _)) //= lt_ab.
- case: t => [//|d t] in t0 lt_bt dis_bt ct *.
  move: dis_bt; rewrite [in X in X -> _]/= => /andP[dis_bd dis_dt].
  rewrite /= {}dis_dt andbT.
  move: (lt_itv_le lt_ab dis_ab) => {}lt_ab.
  move/andP : lt_bt => [+ _] => /lt_itv_le/(_ dis_bd) lt_bd.
  apply/lt_disjoint => x y xa yd.
  have nb : neitv b by move: t0 => /= /andP[].
  by rewrite (@lt_trans _ _ (itv_center b) _ _ (lt_ab _ _ _ _) (lt_bd _ _ _ _)) // mem_itv_center.
Qed.

Lemma nonempty_sorted_disjoint_itv_trivIset h (t : seq (interval R)) :
  all neitv t ->
  sorted le_itv (h :: t) ->
  path disjoint_itv h t ->
  trivIset setT (fun i => set_of_itv (nth 0%O (h :: t) i)).
Proof.
elim: t h => //= [h t0 _ _|b t ih a /andP[b0 t0] /andP[lt_ab lt_bt] /andP[dis_ab dis_bt]].
  apply/trivIsetP => i j _ _ ij.
  case: i => [|i] /= in ij *.
    case: j => [|j] //= in ij *.
    by rewrite nth_nil set_of_itvE setI0.
  by rewrite nth_nil set_of_itvE set0I.
apply/trivIsetP => i j _ _; move: i j.
move=> [|i] [|j] //= ?.
- have [jbt|btj] := ltP j (size (b :: t)).
    apply/eqP/(@nonempty_sorted_disjoint_itv _ (b :: t)) => //=.
    by rewrite b0.
    by rewrite lt_ab.
    by rewrite dis_ab.
    by rewrite mem_nth.
  by rewrite nth_default // set_of_itvE setI0.
- have [ibt|bti] := ltP i (size (b :: t)).
    rewrite setIC.
    apply/eqP/(@nonempty_sorted_disjoint_itv _ (b :: t)) => //=.
    by rewrite b0.
    by rewrite lt_ab.
    by rewrite dis_ab.
    by rewrite mem_nth.
  by rewrite nth_default // set_of_itvE set0I.
- by have /trivIsetP := ih b t0 lt_bt dis_bt; apply.
Qed.

Lemma trivIset_disjoint h (t : seq (interval R)) :
  trivIset setT (fun i => set_of_itv (nth 0%O (h :: t) i)) ->
  path disjoint_itv h t.
Proof.
elim: t h => // t1 t2 ih h /= /trivIsetP tsht1t2.
apply/andP; split.
  by move: (tsht1t2 O 1%N Logic.I Logic.I erefl) => /= /eqP.
apply ih => //; apply/trivIsetP => i j _ _ ij.
by move: (tsht1t2 i.+1 j.+1 Logic.I Logic.I); apply.
Qed.

Lemma path_disjoint_pinfty_eq0 (t : seq (interval R)) j :
  all neitv t ->
  path lt_itv (Interval j +oo%O) t ->
  path disjoint_itv (Interval j +oo%O) t ->
  t = [::].
Proof.
case: t => // h t ne.
case: j => [b r|[]]; last 2 first.
  move=> _; apply: path_disjoint_setT_eq0.
  by rewrite (@eq_all _ _ neitv) // => i; rewrite set_of_itv_neq0.
  by case: h => h1 h2 in ne *; rewrite /= /lt_itv /= gt_pinfty andbF.
case: h => h1 h2 /= in ne *; rewrite /lt_itv /= gt_pinfty andbF orbF.
move=> /andP[rh1 ht] /= /andP[rooh Hdis].
apply: (absurd rooh); apply/negP/set0P; rewrite -set_of_itv_meet /=.
rewrite joinEtotal maxElt rh1 meetEtotal minElt /=.
by case/andP : ne; rewrite -set_of_itv_neq0 => /set0P.
Qed.

Lemma sorted_le_itv_bound (s : seq (interval R)) :
  all neitv s ->
  sorted le_itv s ->
  path disjoint_itv (head 0%O s) (behead s) ->
  sorted <=%O (map bnd2eta s) /\ sorted <=%O (map bnd1eta s).
Proof.
elim: s => // -[h1 h2] [//|[t11 t12] t2] ih /= ne ht Hdis; split.
  apply/andP; split.
    case/andP : ht => + _.
    move/orP => -[/eqP[_ <-]//|].
    rewrite /lt_itv /=; case: ltgtP => //= [|_ /ltW] // h11t11 _.
    move/andP : Hdis => [H _].
    rewrite leNgt; apply/negP => t12h2.
    move: H; apply/negP/set0P.
    have : neitv (Interval t11 t12) by move/and3P : ne => [_].
    rewrite -set_of_itv_neq0 => /set0P[x t11t12x].
    exists x; split => //.
    apply/set_of_itv_mem; rewrite itv_boundlr.
    move/set_of_itv_mem : t11t12x; rewrite itv_boundlr => /andP[t11x xt12].
    by rewrite (le_trans (ltW _) t11x) // (le_trans xt12) // ltW.
  apply: (proj1 (ih _ _ _)).
  - by move/andP : ne => [].
  - by case/andP : ht => ? ht.
  - by rewrite /=; move/andP : Hdis => // -[].
apply/andP; split.
- move/andP : ht => -[] /orP[/eqP[<-//]|].
  by rewrite /lt_itv /=; case: ltgtP.
- apply: (proj2 (ih _ _ _)).
  + by move/andP : ne => [].
  + by case/andP : ht.
  + by rewrite /=; move/andP : Hdis => // -[].
Qed.

End lt_itv_disjoint.

Lemma itv_subset1 (R : numDomainType) (i : interval R) c : {subset i <= `[c, c]} ->
  forall r, r \in i -> r = c.
Proof.
by move/subset_of_itvP; rewrite set_of_itvE => ir r /ir; rewrite -eq_le => /eqP.
Qed.

Lemma itv_subset1'_side_pinfty (R : numFieldType) b r (c : R) : ~ {subset Interval (BSide b r) +oo%O <= `[c, c]}.
Proof.
set i := Interval (BSide b r) +oo%O.
move=> ic; have : itv_center i < itv_center i + 1 by rewrite ltr_spaddr.
rewrite lt_neqAle => /andP[/negP r1 _]; apply/r1/eqP.
transitivity c.
  move/itv_subset1 : ic; apply.
  by rewrite mem_itv_center // set_of_itv_neq0.
apply/esym; move/itv_subset1 : ic; apply; rewrite in_itv /= andbT.
by case: b => /= in i r1 *; [rewrite -addrA ler_addl|rewrite -addrA ltr_addl].
Qed.

Lemma itv_subset1'_ninfty_side (R : numFieldType) b r (c : R) : ~ {subset Interval -oo%O (BSide b r) <= `[c, c]}.
Proof.
move=> ic; set i := Interval -oo%O (BSide b r).
have : itv_center i - 1 < itv_center i by rewrite ltr_subl_addr ltr_spaddr.
rewrite lt_neqAle => /andP[/negP r1 _]; apply/r1/eqP.
transitivity c.
  move/itv_subset1 : ic; apply.
  rewrite in_itv /=.
  case: b => /= in i r1 *.
  by rewrite -addrA -opprD ltr_subl_addl ltr_addr.
  by rewrite -addrA -opprD ler_subl_addl ler_addr.
apply/esym; move/itv_subset1 : ic; apply.
by rewrite mem_itv_center // set_of_itv_neq0.
Qed.

(* NB: not used *)
Lemma itv_subset1' (R : numFieldType) (i : interval R) c : {subset i <= `[c, c]} ->
  i =i pred0 \/ i = `[c, c].
Proof.
move=> ic; have [/eqP i0|i0] := boolP (set_of_itv i == set0).
  by left => r; apply/idP/idP => //; apply/negP; rewrite -(set_of_itv_mem i) i0.
move: i ic i0 => [[[]a|[]] [[]b|[]]] //= ic i0.
- right; have ab : a < b by move: i0; rewrite set_of_itv_neq0.
  have : a < itv_center `[a, b[ by rewrite midf_lt.
  rewrite lt_neqAle => /andP[/negP ab2 _]; apply: (absurdnot ab2); apply/eqP.
  transitivity c.
    by move/itv_subset1 : ic; apply; rewrite in_itv /= lexx ab.
  apply/esym; move/itv_subset1 : ic; apply.
  by rewrite mem_itv_center // set_of_itv_neq0.
- right; suff : a = c /\ b = c by move=> [-> ->].
  have ab : a <= b by move: i0; rewrite set_of_itv_neq0 /= => /ltW.
  split.
    by move/itv_subset1 : ic; apply; rewrite in_itv /= lexx /=.
  by move/itv_subset1 : ic; apply; rewrite in_itv /= ab lexx.
- by left; apply itv_ge.
- by have := itv_subset1'_side_pinfty ic.
- left; move/set0P in i0; apply: (absurd i0) => -[r ir].
  have : r < (r + b) / 2 by rewrite midf_lt //; move: ir; rewrite set_of_itv_mem in_itv /= => /andP[_ ].
  rewrite lt_neqAle => /andP[/negP rb2 _]; apply rb2; apply/eqP.
  transitivity c.
    move/itv_subset1 : ic; apply; rewrite in_itv /=.
    by move: ir; rewrite set_of_itv_mem !in_itv /=.
  apply/esym; move/itv_subset1 : ic; apply; rewrite in_itv /=.
  apply/andP; split.
    rewrite (@lt_le_trans _ _ r) //.
      by move: ir; rewrite set_of_itv_mem in_itv /= => /andP[].
    rewrite midf_le // ltW //.
    by move: ir; rewrite set_of_itv_mem in_itv /= => /andP[].
  rewrite midf_lt //.
  by move: ir; rewrite set_of_itv_mem in_itv /= => /andP[].
- right; have ab : a < b by move: i0; rewrite set_of_itv_neq0 /=.
  have : itv_center `]a, b] < b by rewrite midf_lt.
  rewrite lt_neqAle=> /andP[/negP + _]; apply: absurd; apply/eqP.
  transitivity c.
    move/itv_subset1 : ic; apply.
    by rewrite in_itv /= midf_lt //= (midf_le (ltW _)).
  apply/esym; move/itv_subset1 : ic; apply.
  by rewrite in_itv /= lexx ab.
- by left; apply itv_ge.
- by have := itv_subset1'_side_pinfty ic.
- by have := itv_subset1'_ninfty_side ic.
- by have := itv_subset1'_ninfty_side ic.
- by move: i0; rewrite set_of_itvE eqxx.
- move/set0P : i0 => -[r ir].
  have rr1 : r < r + 1 by rewrite ltr_spaddr.
  apply (absurd rr1).
  rewrite lt_neqAle => /andP[/negP r1 _]; apply/r1/eqP.
  transitivity c.
    by move/itv_subset1 : ic; apply; rewrite -set_of_itv_mem.
  by apply/esym; move/itv_subset1 : ic; apply; rewrite in_itv.
- by move: i0; rewrite set_of_itvE eqxx.
- by move: i0; rewrite set_of_itvE eqxx.
- by move: i0; rewrite set_of_itvE eqxx.
- by move: i0; rewrite set_of_itvE eqxx.
Qed.

Section decomposition.
Variable R : realType.
Implicit Types (i j : interval R) (s t : seq (interval R)).

Program Definition decompose' s
    (f : forall t, (size t < size s)%N -> seq (interval R)) :=
  match s with
  | [::] => [::] | [:: i] => [:: i]
  | [:: i, j & tl] => if (i <= j)%O then f (j :: tl) _ else
                    if (j <= i)%O then f (i :: tl) _ else
                    itv_diff i j :: f (j :: tl) _
  end.

Lemma decompose'_ext s
  (f g : forall t, (size t < size s)%N -> seq (interval R)) :
    (forall t (h : (size t < size s)%N), f t h = g t h) ->
  decompose' f = decompose' g.
Proof.
move=> fg; congr decompose'.
by apply functional_extensionality_dep => ?; apply functional_extensionality_dep.
Qed.

Lemma wf_size : well_founded (fun t s => (size t < size s)%N).
Proof. by apply: (@Wf_nat.well_founded_lt_compat _ size) => s t /ssrnat.ltP. Qed.

Definition decompose : seq (interval R) -> seq (interval R) :=
  Fix wf_size (fun _ => _ _) decompose'.

Lemma decompose_nil : decompose [::] = [::].
Proof. by rewrite /decompose Fix_eq //=; exact decompose'_ext. Qed.

Lemma decompose_one i : decompose [:: i] = [:: i].
Proof. rewrite /decompose Fix_eq //=; exact: decompose'_ext. Qed.

Lemma decompose_two i j t : decompose [:: i, j & t] =
  if (i <= j)%O then decompose (j :: t) else
  if (j <= i)%O then decompose (i :: t) else
  itv_diff i j :: decompose (j :: t).
Proof.
rewrite {1}/decompose Fix_eq; last exact: decompose'_ext.
by move: i j => [? ?] [? ?] //=; case: ifPn => //; case: ifPn.
Qed.

Local Lemma decompose_eq0' s : decompose s = [::] -> s = [::].
Proof.
move Hn : (size s) => n.
elim: n s Hn => [[]//|n ih [//|i [|j t] [tn]]]; first by rewrite decompose_one.
rewrite decompose_two; case: ifPn => [_ /ih|ij]; first by move => /(_ tn).
by case: ifPn => // ji /ih => /(_ tn).
Qed.

Lemma decompose_eq0 s : (decompose s == [::]) = (s == [::]).
Proof.
by apply/idP/idP => [/eqP/decompose_eq0'/eqP //|/eqP ->]; rewrite decompose_nil.
Qed.

Lemma cover_decompose s :
  sorted le_itv s -> [sset of decompose s] = [sset of s].
Proof.
move sn : (size s) => n; elim: n s sn => [|n ih [//|i [|j t]]].
  by case=> // _ _; rewrite decompose_nil.
  by move=> _ _; rewrite decompose_one.
move=> [tn] /= /andP[le_ij le_jt]; rewrite decompose_two; case: ifPn => ij.
  rewrite /= ih // 3!sset_cons setUA; congr setU.
  by rewrite setUC; apply/esym/setUidPl/subitvP.
case: ifPn => ji.
  rewrite /= ih //; last first.
    by rewrite (mask_second j) (sorted_mask le_itv_trans) //= le_ij.
  by rewrite 3!sset_cons setUA; congr setU; apply/esym/setUidPl/subitvP.
rewrite (sset_cons _ (decompose (j :: t))) ih //.
rewrite [in RHS]sset_cons sset_cons !setUA; congr (_ `|` _).
rewrite set_of_itv_diff // ?ji// eqEsubset; split.
- apply: subsetU; last by move=> x; right.
  by move=> x ix; left; case: ix.
- move=> x [ix|jx]; last by right.
  by have [jx|jx] := pselect ((set_of_itv j) x); [right|left].
Qed.

Local Lemma decompose_nonempty_helper i j :
  neitv i -> neitv j -> ~~ (i <= j)%O -> ~~ (j <= i)%O ->
  neitv (itv_diff i j).
Proof.
move: i j => [a b] [c d]; rewrite /itv_diff /neitv !itv_leEmeet /= => ab cd.
rewrite -leNgt; case: ifPn => //=; rewrite -ltNge; case: (leP c a) => ca.
  rewrite ltxI ab /= => ad; case: (leP d b) => db /=; last by rewrite eqxx.
  by  rewrite lt_neqAle db andbT => + _; apply: contra => /eqP ->.
by rewrite ltxI cd andbT; case: (leP d b) => //=; rewrite eqxx.
Qed.

Lemma decompose_nonempty s : all neitv s -> all neitv (decompose s).
Proof.
move sn : (size s) => n; elim: n s sn => [|n ih [//|i [|j t]] ].
  by move=> s /size0nil ->{} _; rewrite decompose_nil.
  by move=> _ i0; rewrite decompose_one.
move=> [tn] /= /and3P[i0 j0 ne]; rewrite decompose_two.
case: ifPn => ij; first by rewrite ih //= ne andbT.
case: ifPn => ji; first by rewrite ih //= ne andbT.
apply/allP => k; rewrite inE => /orP[/eqP ->|].
  exact: decompose_nonempty_helper.
by move: k; apply/allP; rewrite ih //= ne andbT.
Qed.

Local Lemma path_disjoint_itv_decompose_helper i j t
  (ijt : sorted le_itv [:: i, j & t])
  (ij : ~~ (i <= j)%O)
  (ji : ~~ (j <= i)%O) :
  forall j0, j0 \in j :: t -> disjoint_itv (itv_diff i j) j0.
Proof.
move=> c cjtl.
apply/eqP; rewrite set_of_itv_diff ?ji//.
move: cjtl; rewrite inE => /orP[/eqP ->|ctl].
  by rewrite setDE -setIA setICl setI0.
rewrite predeqE => x; split => // -[].
rewrite setDE => -[] /set_of_itv_mem ix /set_of_itv_mem/negP jx /set_of_itv_mem cx.
have jc : le_itv j c.
  move: ctl; rewrite -sub1seq.
  move/subseq_path_in => /(_ le_itv j) /=; rewrite andbT; apply => //.
    by move=> ? ? ? ? ? ?; exact: le_itv_trans.
  by move: ijt => /= /andP[].
have le_ij : le_itv i j by move: ijt; rewrite /= => /andP[].
move/negP in ji; apply: ji.
have [|//] := le_itv_subset ix cx jx le_ij jc.
by rewrite (negbTE ij).
Qed.

Lemma path_disjoint_itv_decompose s : sorted le_itv s ->
  forall i, (forall j, j \in s -> disjoint_itv i j) ->
  path disjoint_itv i (decompose s).
Proof.
move sn : (size s) => n.
elim: n s sn => [|n ih [//|i [|j t]] []].
  by move=> _ /size0nil ->{} _ t tc; rewrite decompose_nil.
  by move=> _ _ t tc; rewrite decompose_one /= tc ?mem_head // eqxx.
case: n => [//|n] in ih * => -[] tn ijt k disj_k.
rewrite decompose_two; case: ifPn => ij.
  rewrite ih //= ?tn//; first by case/andP : ijt.
  by move=> c cjt; rewrite disj_k // inE cjt orbT.
case: ifPn => // ji.
  rewrite ih//; first by rewrite /= tn.
    by rewrite (mask_second j) (sorted_mask le_itv_trans).
  by move=> c; rewrite inE => citl; rewrite disj_k // !inE orbCA citl orbT.
rewrite /=; apply/andP; split.
  apply/eqP; rewrite set_of_itv_diff ?ji// setDE setIA.
  by rewrite (eqP (disj_k _ _)) ?set0I // mem_head.
rewrite ih //; first by rewrite /= tn.
  exact/(subseq_sorted le_itv_trans _ ijt)/subseq_cons.
exact: path_disjoint_itv_decompose_helper.
Qed.

Lemma path_disjoint_itv_decompose_head_behead s : sorted le_itv s ->
  path disjoint_itv (head 0%O (decompose s)) (behead (decompose s)).
Proof.
move sn : (size s) => n.
elim: n s sn => [|n ih [//|i [|j t]] []].
  by move=> _ /size0nil ->{} _; rewrite decompose_nil.
  by move=> ic _; rewrite decompose_one /=.
case: n => [//|n] in ih *=> -[] tn ijt.
rewrite decompose_two; case: ifPn => ij.
  rewrite ih//; first by rewrite /= tn.
  by case/andP : ijt.
case: ifPn => // ji.
  rewrite ih //; first by rewrite /= tn.
  by rewrite (mask_second j) (sorted_mask le_itv_trans).
rewrite /= path_disjoint_itv_decompose //; first by move: ijt => /= /andP[].
exact: path_disjoint_itv_decompose_helper.
Qed.

Lemma all_decompose s y : sorted le_itv s ->
  all (fun x => le_itv y x && disjoint_itv y x) s ->
  all (fun x => le_itv y x && disjoint_itv y x) (decompose s).
Proof.
move: y.
have [n] := ubnP (size s); elim: n s => // n ih.
case; first by move=> _ k _ _; rewrite decompose_nil.
move=> i [|j t]; first by move=> /= m k _; rewrite decompose_one /= andbT.
move=> /=; rewrite ltnS => tn y /andP[le_ij le_jt] /and3P[/andP[yi iy] /andP[yj jy] yt'].
rewrite decompose_two; case: ifPn => [ij|ij].
  apply ih => //; apply/allP => z.
  rewrite inE => /orP[/eqP -> //| zt]; rewrite ?yj//.
  by move/allP : yt'; apply.
case: ifPn => ji.
  apply ih => //.
  - by rewrite (mask_second j) (sorted_mask le_itv_trans) //= le_ij.
  - apply/allP => z.
    rewrite inE => /orP[/eqP -> //|zt]; rewrite ?yi//.
    by move/allP : yt' ; apply.
apply/allP => z.
rewrite inE => /orP[/eqP ->{z}|zbt]; last first.
  have : all (fun x => le_itv y x && (disjoint_itv y x)) (decompose (j :: t)).
    apply ih => //; apply/allP => u.
    rewrite inE => /orP[/eqP -> //|ut]; rewrite ?yj//.
    by move/allP : yt'; apply.
  by move/allP; apply.
rewrite le_itv_itv_diff //= /disjoint_itv set_of_itv_diff ?ji//.
apply/eqP; apply: (@subsetI_eq0 _ _ (set_of_itv y)_ (set_of_itv i)) => //.
- by move=> x [].
- by apply/eqP.
Qed.

Lemma sorted_decompose s : sorted le_itv s -> sorted le_itv (decompose s).
Proof.
have [n] := ubnP (size s); elim: n s => // n ih.
case.
  by move=> _ _; rewrite decompose_nil.
move=> a [|b t].
  by move=> _ _; rewrite decompose_one.
rewrite ltnS => abtn abt.
rewrite decompose_two.
case: ifPn => ab.
  apply ih => //.
  by move: abt => /= /andP[].
case: ifPn => [ba|ba/=].
  by rewrite ih // (mask_second b) (sorted_mask le_itv_trans).
have bt : sorted le_itv (decompose (b :: t)).
  by apply ih => //; move: abt => /= /andP[].
rewrite path_min_sorted //.
have bt' : sorted le_itv (b :: t).
  by move: abt => /= /andP[].
have : all (fun x => le_itv (itv_diff a b) x && (disjoint_itv (itv_diff a b) x)) (b :: t).
  rewrite /= le_itv_diff //=; last first.
    by move: abt => /= => /andP[].
  apply/andP; split.
    by apply/eqP; rewrite set_of_itv_diff ?ba// setDE -setIA setICl setI0.
  apply/allP => z zt.
  apply/andP; split.
    rewrite (@le_itv_trans _ b) //.
      apply le_itv_diff => //.
      by move: abt => /= /andP[].
    move: abt => /= /andP[_ bt''].
    by move/order_path_min : bt'' => /(_ le_itv_trans) /allP; apply.
  rewrite /disjoint_itv set_of_itv_diff ?ba//.
  apply/negPn/negP => /set0P[x] -[[] ].
  move/set_of_itv_mem => xa bx /set_of_itv_mem zx.
  move: a b z => [a1 a2] [b1 b2] [z1 z2] in zt zx abtn abt ab ba bt bt' bx xa *.
  apply: bx.
  apply/set_of_itv_mem.
  rewrite itv_boundlr in xa.
  rewrite itv_boundlr in zx.
  rewrite itv_boundlr.
  case/andP : zx => zx1 zx2.
  rewrite (le_trans _ zx1) //=; last first.
     have : le_itv (Interval b1 b2) (Interval z1 z2).
       have : path le_itv (Interval b1 b2) t by [].
       by move/order_path_min => /(_ le_itv_trans)/allP; apply.
     by rewrite /le_itv /lt_itv /= => /orP[/eqP[ <- //]|/=]; case: ltgtP.
   rewrite leNgt; apply/negP => b2x.
   case/andP : xa => xa1 xa2.
   move/negP in ba; apply: ba.
   rewrite itv_leEmeet/= meet_l; last by rewrite (le_trans (ltW b2x)).
   rewrite join_l//.
   move: abt; rewrite /= /le_itv => /andP[/orP[/eqP[<- //]| /=]].
   by rewrite /lt_itv /=; case: ltgtP.
move/(@all_decompose (b :: t) (itv_diff a b) bt').
by apply sub_all => z /andP[].
Qed.

Lemma trivIset_decompose s :
  sorted le_itv s -> all neitv s ->
  trivIset setT (fun k => set_of_itv (nth 0%O (decompose s) k)).
Proof.
move=> sorteds smem0.
have [/eqP|s0] := boolP (size (decompose s) == 0%N).
  move/size0nil => ->; apply/trivIsetP => /= i j _ _ ij.
  by rewrite nth_nil set_of_itvNlt_set0 // set0I.
have head_behead : decompose s = head 0%O (decompose s) :: behead (decompose s).
  by move: s0; case: (decompose s).
rewrite head_behead.
apply: nonempty_sorted_disjoint_itv_trivIset.
by have := decompose_nonempty smem0; rewrite head_behead /= => /andP[].
by rewrite -head_behead sorted_decompose.
suff : path disjoint_itv 0%O (head 0%O (decompose s) :: behead (decompose s)).
  by rewrite /= => /andP[].
rewrite -head_behead path_disjoint_itv_decompose => // c cs.
by apply/eqP; rewrite set_of_itvNlt_set0 // set0I.
Qed.

Definition Decompose s := decompose (sort le_itv [seq x <- s | neitv x]).

Lemma itv_cplt_decomposeE s :
  [sset of itv_cplt_ne (Decompose s)] = ~` [sset of s].
Proof.
have [H1 H2 H3] : [/\ all neitv (Decompose s), sorted le_itv (Decompose s) &
    path disjoint_itv (head 0%O (Decompose s)) (behead (Decompose s))].
  split.
  - by rewrite decompose_nonempty // all_sort; apply/allP => i; rewrite mem_filter => /andP[].
  - by apply: sorted_decompose; exact: (sort_sorted total_le_itv).
  - by apply: path_disjoint_itv_decompose_head_behead; exact: (sort_sorted total_le_itv).
have [? ?] := sorted_le_itv_bound H1 H2 H3.
rewrite itv_cplt_neE // cover_decompose //; last exact: (sort_sorted total_le_itv).
by rewrite sset_sort_le_itv // sset_filter_neitv.
Qed.

Definition decomposition_of s : seq (interval R) -> Prop :=
  fun x => [/\ sorted le_itv x,
           path disjoint_itv (head 0%O x) (behead x) &
           [sset of x] = [sset of s] ].

Lemma decomposition_of_Decompose s : decomposition_of s (Decompose s).
Proof.
split.
- by apply sorted_decompose; exact: (sort_sorted total_le_itv).
- by apply: path_disjoint_itv_decompose_head_behead; exact: (sort_sorted total_le_itv).
- rewrite cover_decompose; last exact: (sort_sorted total_le_itv).
  by rewrite sset_sort_le_itv sset_filter_neitv.
Qed.

Lemma mem_Decompose (j : interval R) s (r : R) :
  j \in s -> set_of_itv j r ->
  exists j', j' \in Decompose s /\ set_of_itv j' r.
Proof.
move=> js jr.
have : [sset of s] r by rewrite sset_bigcup; exists j.
have [_ _] := decomposition_of_Decompose s.
by move=> <-; rewrite sset_bigcup => -[j' sj' j'r]; exists j'.
Qed.

Lemma trivIset_Decompose s :
  trivIset setT (fun k => set_of_itv (nth 0%O (Decompose s) k)).
Proof.
have [/eqP ->|s0] := boolP (Decompose s == [::]).
  by apply/trivIsetP => i j _ _ ?; rewrite nth_nil set_of_itvE set0I.
rewrite -(head_behead 0%O s0).
apply nonempty_sorted_disjoint_itv_trivIset.
- apply/allP => /= j /mem_behead; rewrite /Decompose.
  set s' := sort _ _.
  have /decompose_nonempty/allP sne : all neitv s'.
    by rewrite all_sort all_filter; apply/allP => i ia /=; exact: implybb.
  by move/sne.
- rewrite head_behead //.
  by have [] := decomposition_of_Decompose s.
- by have [] := decomposition_of_Decompose s.
Qed.

Lemma Decompose_nonempty s : all neitv (Decompose s).
Proof.
rewrite /Decompose; apply/decompose_nonempty.
by rewrite all_sort; apply/allP => i; rewrite mem_filter => /andP[].
Qed.

Lemma Decompose_nil : Decompose [::] = [::].
Proof. by rewrite /Decompose /= sortE /= decompose_nil. Qed.

End decomposition.
Arguments Decompose {R}.

Definition contiguous_itv (R : realType) (i j : interval R) : bool :=
  (i.2 == j.1 :> itv_bound R).

(* simple sets *)
Module Sset.
Section is_sset.
Variable R : realType.
Implicit Types A B : set R.

Definition is_sset A : Prop := exists s, A = [sset of s].

Lemma is_sset0 : is_sset set0. Proof. by exists fset0; rewrite sset_nil. Qed.

Lemma is_ssetU A B : is_sset A -> is_sset B -> is_sset (A `|` B).
Proof.
move=> [a aA] [b bB]; exists (a ++ b)%fset.
rewrite eqEsubset; split => [r [Ar|Br]|r].
  move: Ar; rewrite aA => /ssetP[/= j ja jr].
  by apply/ssetP; exists j => //; rewrite /mkset mem_cat ja.
  move: Br; rewrite bB => /ssetP[/= j jb jr].
  by apply/ssetP; exists j => //; rewrite /mkset mem_cat jb orbT.
move/ssetP => [j]; rewrite /mkset mem_cat => /orP[ja|jb] jr.
by left; rewrite aA; apply/ssetP; exists j.
by right; rewrite bB; apply/ssetP; exists j.
Qed.

Lemma is_ssetC A : is_sset A -> is_sset (~` A).
Proof.
move=> [a aA].
set s := itv_cplt_ne (Decompose a).
exists [fset x | x in s]%fset.
rewrite (@sseti _ _ s) //; last by move=> i; rewrite inE.
by rewrite /s itv_cplt_decomposeE aA.
Qed.

End is_sset.

Section ring_of_sets_instance.
Variable R : realType.

HB.instance Definition sset_algebraOfSets := @isAlgebraOfSets.Build (Real.sort R)
    (@is_sset R) (@is_sset0 R) (@is_ssetU R) (@is_ssetC R).

Definition sset_algebraOfSetsType := [the algebraOfSetsType of (Real.sort R)].

Lemma is_sset_itv (i : interval R) : is_sset (set_of_itv i).
Proof. by exists [:: i]; rewrite sset_cons1. Qed.

Lemma is_sset_sset (s : seq (interval R)) : is_sset [sset of s].
Proof.
by apply: (@bigsetU_measurable sset_algebraOfSetsType) => i _; exact: is_sset_itv.
Qed.

End ring_of_sets_instance.
End Sset.
Notation sset_algebraOfSetsType := Sset.sset_algebraOfSetsType.

Section conv_Rhull.
Variable R : realType.

Lemma N01 (t : R) : (0 <= t <= 1) = (0 <= 1 - t <= 1).
Proof.
apply/idP/idP => /andP[t0 t1]; apply/andP; split; first by rewrite subr_ge0.
by rewrite ler_subl_addr addrC -ler_subl_addr subrr.
by move: t1; rewrite ler_subl_addr addrC -ler_subl_addr subrr.
by move: t0; rewrite subr_ge0.
Qed.

Definition conv (t : R) (a b : R) : R := (1 - t) * a + t * b.

Lemma conv0 (a b : R) : conv 0 a b = a.
Proof. by rewrite /conv subr0 mul1r mul0r addr0. Qed.

Lemma conv1 (a b : R) : conv 1 a b = b.
Proof. by rewrite /conv subrr mul0r add0r mul1r. Qed.

Lemma convN (a b t : R) : conv t a b = conv (1 - t) b a.
Proof. by rewrite /conv opprB addrCA subrr addr0 addrC. Qed.

Lemma le_conv (a b t : R) : a <= b -> 0 <= t <= 1 -> a <= conv t a b <= b.
Proof.
move=> ab /andP[].
rewrite le_eqVlt => /orP[/eqP/esym ->{t} _|t0]; first by rewrite conv0 lexx.
rewrite le_eqVlt => /orP[/eqP ->{t0 t}|t1]; first by rewrite conv1 lexx andbT.
have t1t : 1 - t + t = 1 by rewrite subrK.
rewrite /conv; apply/andP; split.
  by rewrite -{1}(mul1r a) -{1}t1t [in X in X <= _]mulrDl ler_add // ler_pmul2l.
by rewrite -{2}(mul1r b) -{2}t1t [in X in _ <= X]mulrDl ler_add // ler_pmul2l // subr_gt0.
Qed.

Definition factor (a b x : R) := (x - a) / (b - a).

Lemma factor01 (a b x : R) : a != b -> a <= x -> x <= b -> 0 <= factor a b x <= 1.
Proof.
move=> ab ax xb; rewrite divr_ge0 // ?subr_ge0 // ?(le_trans ax) //=.
by rewrite ler_pdivr_mulr ?mul1r ?ler_sub// subr_gt0 lt_neqAle ab (le_trans ax).
Qed.

Lemma conv_factor (a b x : R) : a != b -> conv (factor a b x) a b = x.
Proof.
move=> ab; rewrite /conv -(@divff _ (b - a)) ?subr_eq0 1?eq_sym// -mulrBl.
rewrite opprB addrA subrK mulrAC (mulrAC (x - a)) -mulrDl 2!mulrBl.
rewrite -addrA (addrC (b * a)) -addrA (mulrC a b) subrK.
by rewrite -mulrN addrC -mulrDr -mulrA mulfV ?mulr1 // subr_eq0 eq_sym.
Qed.

Lemma conv_subset_Rhull (A : set R) :
  [set x | exists (a b t : R), [/\ A a, A b, 0 <= t <= 1 & x = conv t a b]]
    `<=` set_of_itv (Rhull A).
Proof.
move=> r -[a [b [t [Aa Ab /andP[t0 t1] ->{r}]]]].
have /is_intervalPle iRhullA := @interval_is_interval _ (Rhull A).
have [ab|/ltW ba] := leP a b.
  apply: (iRhullA a b); rewrite ?set_of_itv_mem; try exact/sub_Rhull.
  by rewrite le_conv // t0.
apply: (iRhullA b a); rewrite ?set_of_itv_mem; try exact/sub_Rhull.
by rewrite convN le_conv => //; rewrite -N01 t0.
Qed.

Lemma Rhull_subset_conv (A : set R) : A !=set0 -> set_of_itv (Rhull A) `<=`
  [set x | exists (a b t : R), [/\ A a, A b, 0 <= t <= 1 & x = conv t a b]].
Proof.
move=> A0 r; rewrite set_of_itv_mem /Rhull; set i : R := inf A; set s : R := sup A.
have [|] := boolP (`[< has_lbound A >]) => /asboolP lA.
- have [|]:= boolP (`[< has_ubound A >]) => /asboolP uA.
  + have [|] := boolP (`[< A i >]) => /asboolP Ai.
    * have [|] := boolP (`[< A s >]) => /asboolP As; rewrite in_itv /= => /andP[ir rs].
      - have [/eqP si|si] := boolP (i == s).
        + have /eqP <- : i == r by rewrite eq_le {2}si ir.
          by exists i, s, 0; rewrite conv0 lexx ler01.
        + by exists i, s, (factor i s r); rewrite factor01 // conv_factor.
      - pose e := s - r.
        have [u ? seu] : exists2 u, A u & s - e < u by apply sup_adherent; rewrite ?subr_gt0.
        have ? : i < u by rewrite (le_lt_trans _ seu)// (le_trans ir)// opprB addrCA subrr addr0.
        exists i, u, (factor i u r); rewrite factor01 ?conv_factor// ?lt_eqF//.
        by rewrite (le_trans _ (ltW seu))// /e opprB addrCA subrr addr0.
    * have [|] := boolP (`[< A s >]) => /asboolP As; rewrite in_itv /= => /andP[ir rs].
      - pose e := r - i.
        have [l ? lie] : exists2 l, A l & l < i + e by apply inf_adherent; rewrite ?subr_gt0.
        have ? : l < s by rewrite (lt_le_trans lie)// (le_trans _ rs)// addrCA subrr addr0.
        exists l, s, (factor l s r); rewrite factor01// ?conv_factor// ?lt_eqF//.
        by rewrite (le_trans (ltW lie)) // /e addrCA subrr addr0.
      - pose e := ((r - i) `&` (s - r))%O.
        have [u ? seu] : exists2 u, A u & s - e < u by apply sup_adherent; rewrite ?ltxI 2?subr_gt0 ?ir.
        have [l ? lie] : exists2 l, A l & l < i + e by apply inf_adherent; rewrite ?ltxI 2?subr_gt0 ?ir.
        have ? : i + e <= r by rewrite -ler_sub_addl leIx lexx.
        have ? : r <= s - e by rewrite -ler_sub_addr opprK -ler_sub_addl leIx lexx orbT.
        have ? : l < u by rewrite (lt_le_trans lie)// (le_trans _ (ltW seu))// (@le_trans _ _ r).
        exists l, u, (factor l u r); rewrite factor01// ?conv_factor// ?lt_eqF//.
        by rewrite (le_trans (ltW lie)).
        by rewrite (le_trans _ (ltW seu)).
  + have [|] := boolP (`[< A i >]) => /asboolP Ai; rewrite in_itv /= andbT => ir.
    * have [u Au ru] : exists2 u, A u & r < u by move/has_ubPn : uA => /(_ r).
      have ? : i < u by rewrite (le_lt_trans ir).
      by exists i, u, (factor i u r); rewrite factor01// ?conv_factor // ?lt_eqF// ltW.
    * pose e := r - i.
      have [l ? lie] : exists2 l, A l & l < i + e by apply inf_adherent; rewrite ?subr_gt0.
      have [u ? ru] : exists2 u, A u & r < u by move/has_ubPn : uA => /(_ r).
      have ? : l < u by rewrite (lt_le_trans lie) // addrCA subrr addr0 ltW.
      have ? : l <= r by rewrite (le_trans (ltW lie)) // addrCA subrr addr0.
      by exists l, u, (factor l u r); rewrite factor01// ?conv_factor// ?lt_eqF// ltW.
- have [|]:= boolP (`[< has_ubound A >]) => /asboolP uA; last move=> _.
  + have [|] := boolP (`[< A s >]) => /asboolP As; rewrite in_itv /= => rs.
    * have [l ? lr] : exists2 l, A l & l < r by move/has_lbPn : lA => /(_ r).
      have ? : l < s by rewrite (lt_le_trans lr).
      by exists l, s, (factor l s r); rewrite factor01// ?conv_factor// ?lt_eqF// ltW.
    * pose e := s - r.
      have [u ? seu] : exists2 u, A u & s - e < u by apply sup_adherent; rewrite ?subr_gt0.
      have [l ? lr] : exists2 l, A l & l < r by move/has_lbPn : lA => /(_ r).
      have ? : l < u by rewrite (le_lt_trans _ seu)// (le_trans (ltW lr))// opprB addrCA subrr addr0.
      have ? : r <= u by rewrite (le_trans _ (ltW seu))// opprB addrCA subrr addr0.
      by exists l, u, (factor l u r); rewrite factor01// ?conv_factor// ?lt_eqF// ltW.
  + have [l ? lr] : exists2 l, A l & l < r by move/has_lbPn : lA => /(_ r).
    have [u ? ru] : exists2 u, A u & r < u by move/has_ubPn : uA => /(_ r).
    have ? : l < u by rewrite (lt_trans lr).
    by exists l, u, (factor l u r); rewrite factor01// ?conv_factor// ?lt_eqF// ltW.
Qed.

Lemma le_Rhull : {homo (@Rhull R) : A B / (A `<=` B) >-> {subset A <= B}}.
Proof.
move=> A; have [/eqP A0 B AB r|/set0P A0 B AB r] := boolP (A == set0).
  by rewrite A0 Rhull0 in_itv /= lt_asym.
move/(Rhull_subset_conv A0) => -[a [b [t [Aa Ab /andP[t0 t1] ->]]]].
by apply/conv_subset_Rhull; exists a, b, t; split => //; try exact/AB; rewrite t0.
Qed.

Lemma Rhull_pred0 (a : set R) : Rhull a =i pred0 -> a = set0.
Proof.
by move=> a0; rewrite predeqE => r; split => // /sub_Rhull; rewrite /mkset a0 inE.
Qed.

Lemma Rhull_involutive (a : set R) : Rhull (set_of_itv (Rhull a)) = Rhull a.
Proof.
have [/asboolP/Rhull_pred0 ->|a0] := boolP (`[< Rhull a =i pred0 >]).
  by rewrite Rhull0 set_of_itvNlt_set0 /neitv //= ?lte_bnd -?leNgt // Rhull0.
have := @RhullK _ (set_of_itv (Rhull a)).
rewrite inE => /(_ (@interval_is_interval _ _)); rewrite set_of_itvK //.
by rewrite -topredE /= neitvNpred0.
Qed.

End conv_Rhull.

Coercion ereal_of_itv_bound T (b : itv_bound T) : \bar T :=
  match b with BSide _ y => y%:E | +oo%O => +oo%E | -oo%O => -oo%E end.
Arguments ereal_of_itv_bound T !b.

Lemma le_bnd_er (R : realDomainType) (a b : itv_bound R) : (a <= b)%O -> (a <= b)%E.
Proof.
move: a b => -[[] a|[]] [bb b|[]] //=; rewrite ?(lee_pinfty,lee_ninfty)//.
  by rewrite BLeft_BSide_leE lee_fin.
by case: bb => //; rewrite BRight_BLeft_leE => /ltW; rewrite lee_fin.
Qed.

Lemma lt_er_bnd (R : realDomainType) (a b : itv_bound R) : (a < b)%E -> (a < b)%O.
Proof.
by move: a b => -[[] a|[]] [[] b|[]] //=;
  rewrite ?(lee_pinfty,lee_ninfty,lte_fin)// => ab; rewrite lte_bnd ltW.
Qed.

Section hlength.
Variable R : realType.

Definition hlength {R : realType} (A : set R) : \bar R :=
  let i := Rhull A in (i.2 - i.1)%E.

Lemma hlength0 : hlength (set0 : set R) = 0%:E.
Proof. by rewrite /hlength Rhull0 /= subrr. Qed.

Lemma hlength_singleton (r : R) : hlength (set_of_itv `[r, r]) = 0%:E.
Proof.
rewrite /hlength /= asboolT // sup_closed_closed // {1}set_of_itvE lexx.
by rewrite asboolT // asboolT // inf_closed_closed // set_of_itvE lexx /= subrr.
Qed.

Lemma hlength_itv (i : interval R) :
  hlength (set_of_itv i) = if (i.2 > i.1)%E then (i.2 - i.1)%E else 0%:E.
Proof.
case: ltP => [i12|].
  rewrite /hlength set_of_itvK// inE; move: i12.
  by move/lt_er_bnd; rewrite ltNge; apply: contra.
rewrite le_eqVlt => /orP[|/lt_er_bnd i12]; last first.
  by rewrite set_of_itvNlt_set0 ?hlength0// -leNgt ltW.
case: i => -[ba a|[|]] [bb b|[|]] //=.
- rewrite /= => /eqP[->{b}]; move: ba bb => -[] []; try
    by rewrite set_of_itvNlt_set0 ?hlength0 //= /neitv /= lte_bnd -leNgt.
  by rewrite hlength_singleton.
- by move=> _; rewrite set_of_itvE hlength0.
- by move=> _; rewrite set_of_itvE hlength0.
Qed.

(* NB: not used *)
Lemma le_hlength0 (a b : itv_bound R) : (b <= a)%O ->
  hlength (set_of_itv (Interval a b)) = 0%:E.
Proof.
move=> /= /le_bnd_er ba; rewrite hlength_itv.
by case: ifPn => //; rewrite ltNge ba.
Qed.

Lemma hlength_setT : hlength setT = +oo%E :> \bar R.
Proof. by rewrite -set_of_itv_ninfty_pinfty hlength_itv. Qed.

Lemma hlength_ninfty b r :
  hlength (set_of_itv (Interval -oo%O (BSide b r))) = +oo%E :> \bar R.
Proof. by rewrite hlength_itv /= lte_ninfty. Qed.

Lemma hlength_pinfty b r :
  hlength (set_of_itv (Interval (BSide b r) +oo%O)) = +oo%E :> \bar R.
Proof. by rewrite hlength_itv /= lte_pinfty. Qed.

Lemma hlength_oo (i : interval R) : hlength (set_of_itv i) = +oo%E ->
  (exists s r, i = Interval -oo%O (BSide s r) \/ i = Interval (BSide s r) +oo%O)
  \/ i = `]-oo, +oo[.
Proof.
rewrite hlength_itv; case: i => -[ba a|[]] [bb b|[]] //= => [|_|_|].
- by case: ifPn.
- by left; exists ba, a; right.
- by left; exists bb, b; left.
- by right.
Qed.

Lemma hlength_ge0 (i : interval R) : (0%:E <= hlength (set_of_itv i))%E.
Proof.
rewrite hlength_itv; case: ifPn => //; case: (i.1 : \bar _) => [r||].
by rewrite suber_ge0 => /ltW.
by rewrite ltNge lee_pinfty.
by case: (i.2 : \bar _) => //=; rewrite lee_pinfty.
Qed.
Local Hint Extern 0 (0%:E <= hlength _) => solve[apply: hlength_ge0] : core.

Lemma hlength_Rhull (a : set R) : hlength (set_of_itv (Rhull a)) = hlength a.
Proof. by rewrite /hlength Rhull_involutive. Qed.

Lemma le_hlength_itv (i j : interval R) : {subset i <= j} ->
 (hlength (set_of_itv i) <= hlength (set_of_itv j))%E.
Proof.
set I := set_of_itv i; set J := set_of_itv j.
have [/eqP ->|/set0P I0] := boolP (I == set0).
  by rewrite hlength0 hlength_ge0.
have [/eqP J0|/set0P J0] := boolP (J == set0).
  by move/subset_of_itvP; rewrite -/J J0 subset0 -/I => ->.
move=> /subset_of_itvP ij; apply: lee_sub => /=.
- have [/asboolP ui|/asboolP ui] := boolP (`[< has_ubound I >]).
  + have [/asboolP uj /=|/asboolP uj] := boolP (`[< has_ubound J >]); last by rewrite lee_pinfty.
    by rewrite lee_fin le_sup // => r Ir; exists r; split => //; move : ij; apply.
  + have [/asboolP uj /=|//] := boolP (`[< has_ubound J >]).
    by apply: (absurdnot ui); apply: subset_has_ubound uj.
- have [/asboolP lj /=|/asboolP lj] := boolP (`[< has_lbound J >]); last by rewrite lee_ninfty.
  have [/asboolP li /=|/asboolP li] := boolP (`[< has_lbound I >]).
    rewrite lee_fin ler_oppl opprK le_sup // -?has_inf_supN//.
    - by move=> r [r' Ir' <-{r}]; exists (- r'); split => //; exists r' => //; apply: ij.
    - by case: I0 => x Ix; exists (- x), x.
  by apply: (absurdnot li); apply: subset_has_lbound lj.
Qed.

Lemma le_hlength : {homo (@hlength R) : A B / (A `<=` B) >-> (A <= B)%E}.
Proof.
by move=> a b /le_Rhull /le_hlength_itv; by rewrite (hlength_Rhull a) (hlength_Rhull b).
Qed.

End hlength.
Hint Extern 0 (0%:E <= hlength _) => solve[apply: hlength_ge0] : core.

Lemma IntervalE (R : numDomainType) (i : interval R) : i = Interval i.1 i.2.
Proof. by case: i. Qed.

Section seq_interval_bounds.
Variable R : realType.

Lemma le_itv_bnd1 (i j : interval R) : le_itv i j -> (i.1 <= j.1)%O.
Proof.
move=> /orP[/eqP ->//|]; rewrite /lt_itv.
by move: i j => [i1 i2] [j1 j2] /=; case: ltgtP.
Qed.

Lemma le_itv_bnd2 (i j : interval R) : le_itv i j -> neitv j ->
  disjoint_itv i j -> (i.2 <= j.2)%O.
Proof.
move: i j => [i1 i2] [j1 j2] /=.
rewrite /le_itv /lt_itv /= => /orP[/eqP[-> -> //]|] /=.
case: ltgtP => // [i1j1 _ j0 ij|->{i1} /ltW //].
rewrite leNgt; apply/negP => j2i2.
move/eqP : ij; apply/eqP.
by rewrite -set_of_itv_meet /= (join_r (ltW _))// (meet_r (ltW _))// set_of_itv_neq0.
Qed.

Lemma le_itv_disjoint_bnd2_bnd1 (i j : interval R) :
  neitv i -> neitv j ->
  le_itv i j -> disjoint_itv i j ->
  (i.2 <= j.1)%O.
Proof.
move=> i0 j0 le_ij dis_ij; rewrite leNgt; apply/negP => i1i.
move: (dis_ij); apply/negP.
move: (le_ij) => /orP[/eqP <-|]; first by rewrite /disjoint_itv setIid set_of_itv_neq0.
move: i1i.
have : (i.1 <= j.1)%O by exact: le_itv_bnd1.
have i2j2 : (i.2 <= j.2)%O by apply le_itv_bnd2.
rewrite /lt_itv le_eqVlt => /orP[/eqP i1j1 K1I2|I1K1 K1I2].
  rewrite i1j1 ltxx eqxx => /= {}I2K2.
  rewrite /disjoint_itv -set_of_itv_meet set_of_itv_neq0 /=.
  by rewrite (IntervalE i) (IntervalE j) /= i1j1 join_l // meet_l.
rewrite I1K1 => _; rewrite /disjoint_itv -set_of_itv_meet (IntervalE i).
by rewrite (IntervalE j) /= (join_r (ltW I1K1)) meet_l // set_of_itv_neq0.
Qed.

Lemma le_itv_disjoint_bnd2Noo (i j : interval R) :
  neitv i -> neitv j ->
  le_itv i j -> disjoint_itv i j ->
  i.2 != +oo%O.
Proof.
move=> i0 j0 ss ts.
have ii1 := le_itv_disjoint_bnd2_bnd1 i0 j0 ss ts.
apply/negP => /eqP ioo.
rewrite ioo ge_pinfty in ii1.
move: j0; rewrite /neitv /=; apply/negP.
by rewrite (eqP ii1) -leNgt bound_lex1.
Qed.

Lemma le_itv_disjoint_bnd2r (i j : interval R) :
  neitv i -> neitv j ->
  le_itv i j -> disjoint_itv i j ->
  exists b r, i.2 = BSide b r.
Proof.
move=> i0 j0 les ts.
move i2E : (i.2) => i2.
case: i2 => [b i2|[]] in i2E *.
- by exists b, i2.
- apply: (absurd i2E); apply/eqP.
  by rewrite (@non_empty_bnd2 _ [:: i]) //= ?andbT// ?inE.
- by apply: (absurd i2E); apply/eqP/(le_itv_disjoint_bnd2Noo _ j0).
Qed.

Lemma le_itv_disjoint_bnd1Noo (i j : interval R) :
  neitv i -> neitv j ->
  le_itv i j -> disjoint_itv i j ->
  j.1 != -oo%O.
Proof.
move=> i0 j0 ss ts.
have ii1 := le_itv_disjoint_bnd2_bnd1 i0 j0 ss ts.
apply/negP => /eqP ioo.
rewrite ioo le_ninfty in ii1.
by move: i0; rewrite /neitv /=; apply/negP; rewrite (eqP ii1) -leNgt.
Qed.

Lemma le_itv_disjoint_bnd1r (i j : interval R) :
  neitv i -> neitv j ->
  le_itv i j -> disjoint_itv i j ->
  exists b a, j.1 = BSide b a.
Proof.
move=> i0 j0 sle str.
move i1E : (j.1) => i1.
case: i1 => [b i1|[]] in i1E *.
- by exists b, i1.
- by apply (absurd i1E); apply/eqP/(@le_itv_disjoint_bnd1Noo i).
- apply (absurd i1E); apply/eqP.
  move: j0; rewrite /neitv /= ltNge; apply: contra => /eqP ->.
  by rewrite bound_lex1.
Qed.

Lemma le_itv_disjoint_contiguous (i j : interval R) :
  neitv i -> neitv j ->
  le_itv i j -> disjoint_itv i j ->
  is_interval (set_of_itv i `|` set_of_itv j) ->
  contiguous_itv i j.
Proof.
move=> ine jne ij dij sin.
rewrite /contiguous_itv eq_le; apply/andP; split.
  exact: le_itv_disjoint_bnd2_bnd1.
have [b [x bx]] := le_itv_disjoint_bnd2r ine jne ij dij.
have [c [y cy]] := le_itv_disjoint_bnd1r ine jne ij dij.
set m := (x + y) / 2.
rewrite leNgt bx cy; apply/negP => xy.
have xyW : x <= y.
  by move: b c {cy bx} xy => [] [] /=; rewrite lte_bnd // => /ltW.
have xys : Interval (BSide b x) (BSide c y) \in itv_cplt [:: i; j].
  rewrite /itv_cplt; apply/mapP; exists (BSide b x, BSide c y) => //.
  apply/(nthP (+oo%O, -oo%O)); exists 1%N; first by rewrite size_zip.
  by rewrite !nth_zip //= -bx -cy.
have : m \in [sset of itv_cplt [:: i; j]].
  rewrite sset_bigcup in_setE.
  exists (Interval (BSide b x) (BSide c y)) => //.
  rewrite set_of_itv_mem /m -/(itv_center (Interval (BSide b x) (BSide c y))).
  by rewrite mem_itv_center // set_of_itv_neq0.
rewrite itv_cpltE; last 2 first.
  by rewrite /= !andbT; exact: le_itv_bnd2.
  by rewrite /= !andbT; exact: le_itv_bnd1.
rewrite inE; apply; rewrite sset_cons sset_cons1.
set midi := itv_center i; set midj := itv_center j.
move/is_intervalPle : sin => /(_ midi midj); apply.
- by left; rewrite set_of_itv_mem mem_itv_center // -set_of_itv_neq0 //; exact/set0P.
- by right; rewrite set_of_itv_mem mem_itv_center // -set_of_itv_neq0 ; exact/set0P.
- have := itv_center_bnd2 ine b; rewrite bx BSide_leE -/midi => midix.
  have := itv_center_bnd1 jne c; rewrite cy BSide_leE -/midj => midjy.
  by rewrite (le_trans midix) /= ?midf_le// (le_trans _ midjy) //= midf_le.
Qed.

End seq_interval_bounds.

Section seq_interval_rbnd.
Variable R : realType.

Lemma hlength_finite_fin_num (i : interval R) : neitv i ->
  (hlength (set_of_itv i) < +oo)%E ->
  ((i.1 : \bar R) \is a fin_num) /\ ((i.2 : \bar R) \is a fin_num).
Proof.
move: i => [[ba a|[]] [bb b|[]]] //=; do ?by rewrite ?set_of_itvE ?eqxx.
by move=> _; rewrite hlength_itv /= lte_pinfty.
by move=> _; rewrite hlength_itv /= lte_ninfty.
by move=> _; rewrite hlength_itv /=.
Qed.

Lemma set_of_itv_empty_erbnd (i : interval R) :
  (i.2 < i.1)%E -> set_of_itv i == set0.
Proof.
case: i => -[ba a|[]] [bb b|[]] //=.
- rewrite lte_fin => ab; rewrite set_of_itvNlt_set0 //= -leNgt.
  by move: ba bb => [] [] //; rewrite lte_bnd // ltW.
- by move=> _; rewrite set_of_itvNlt_set0.
- by move=> _; rewrite set_of_itvNlt_set0.
- by move=> _; rewrite set_of_itvNlt_set0.
Qed.

Lemma finite_hlengthE (i : interval R) : neitv i ->
  (hlength (set_of_itv i) < +oo)%E ->
  (hlength (set_of_itv i) = (real_of_extended i.2)%:E - (real_of_extended i.1)%:E)%E.
Proof.
move=> i0 ioo.
have [ri1 ri2] := hlength_finite_fin_num i0 ioo.
rewrite -!EFin_real_of_extended // hlength_itv; case: ifPn => //.
rewrite -leNgt le_eqVlt => /orP[/eqP ->|]; first by rewrite subee.
by move/set_of_itv_empty_erbnd; rewrite set_of_itv_eq0 i0.
Qed.

Lemma set_of_itvP (i j : interval R) : set_of_itv i = set_of_itv j :> set _ <-> i =i j.
Proof.
split => [ij x|ij].
- by apply/idP/idP; rewrite -set_of_itv_mem;
    [rewrite ij set_of_itv_mem | rewrite -ij set_of_itv_mem].
- by rewrite predeqE => r; split; rewrite set_of_itv_mem;
    [rewrite ij -set_of_itv_mem | rewrite -ij -set_of_itv_mem].
Qed.

Lemma set_of_itv0 : set_of_itv (0%O : interval R) = 0%O :> set _.
Proof. by rewrite set_of_itvE. Qed.

Lemma hlength_itv0 (i : interval R) : i =i pred0 -> hlength (set_of_itv i) = 0%:E.
Proof. by move=> /set_of_itv0P ->; rewrite hlength0. Qed.

Lemma hlength_set (i j : interval R) : i =i j ->
  hlength (set_of_itv i) = hlength (set_of_itv j).
Proof. by move=> /set_of_itvP->. Qed.

Lemma disjoint_itv_Rhull (A B : set R) : A `&` B = set0 ->
  is_interval A -> is_interval B ->
  disjoint_itv (Rhull A) (Rhull B).
Proof.
by move=> AB0 iA iB; rewrite /disjoint_itv RhullK ?inE// RhullK // inE.
Qed.

Lemma Rhull_setU2 (A B : set R) : B !=set0 -> A `&` B = set0 ->
  is_interval A -> is_interval B -> lt_itv (Rhull A) (Rhull B) ->
  (Rhull (A `|` B)).2 = (Rhull B).2.
Proof.
move=> B0 AB0 iA iB AB /=.
have [|] := boolP (`[< has_ubound (A `|` B) >]) => /asboolP uAB; last first.
  rewrite asboolF //.
  apply: contra_not uAB => -[x Bx].
  exists x => z [Az|Bz]; last exact: Bx.
  case: B0 => b0 Bb0.
  rewrite (@le_trans _ _ b0) //; last exact: Bx.
  apply/ltW/(lt_itv_le (ltW_itv AB)) => //; try exact: sub_Rhull.
  by rewrite disjoint_itv_Rhull.
have uB : has_ubound B.
  case: uAB => x ABx.
  by exists x => y By; apply ABx; right.
rewrite (asboolT uB) // sup_setU //; last first.
  move=> a b Aa Bb.
  apply/ltW/(lt_itv_le (ltW_itv AB)) => //; try exact/sub_Rhull.
  by rewrite disjoint_itv_Rhull.
congr (BSide (~~ `[< _ >]) _).
rewrite propeqE; split; last by right.
case => // AsB.
move/set0P in B0; apply: (absurdNb B0); apply/eqP.
rewrite predeqE => x; split => // Bx.
have : sup B < x.
  apply: (lt_itv_le (ltW_itv AB)) => //; try exact: sub_Rhull.
  by rewrite disjoint_itv_Rhull.
by apply/negP; rewrite -leNgt; exact: sup_ub.
Qed.

Lemma Rhull_setU1 (A B : set R) : A !=set0 -> A `&` B = set0 ->
  is_interval A -> is_interval B -> lt_itv (Rhull A) (Rhull B) ->
  (Rhull (A `|` B)).1 = (Rhull A).1.
Proof.
move=> A0 AB0 iA iB AB.
rewrite /=.
have [|] := boolP (`[< has_lbound (A `|` B) >]) => /asboolP uAB; last first.
  rewrite asboolF //.
  apply: contra_not uAB => -[x Ax].
  exists x => y [Ay|By].
    by apply Ax.
  case: A0 => a0 Aa0.
  rewrite (@le_trans _ _ a0) //; first exact: Ax.
  apply/ltW/(lt_itv_le (ltW_itv AB)); try exact: sub_Rhull.
  by rewrite disjoint_itv_Rhull.
have lA : has_lbound A.
  case: uAB => x ABx.
  by exists x => y Ay; apply ABx; left.
rewrite (asboolT lA) // inf_setU //; last first.
  move=> a b Aa Bb.
  apply/ltW/(lt_itv_le (ltW_itv AB)) => //; try exact/sub_Rhull.
  by rewrite disjoint_itv_Rhull.
congr (BSide (`[< _ >]) _).
rewrite propeqE; split; last by left.
case => // AsB.
apply: (absurd A0) => -[a0 Aa0].
have : a0 < inf A.
  apply: (lt_itv_le (ltW_itv AB)) => //; try exact: sub_Rhull.
  by rewrite disjoint_itv_Rhull.
by apply/negP; rewrite -leNgt; apply inf_lb.
Qed.

Lemma hlength_itvU (A B : set R) : A `&` B = set0 ->
    is_interval A -> is_interval B -> is_interval (A `|` B) ->
  hlength (A `|` B) = (hlength A + hlength B)%E.
Proof.
move=> AB0 iA iB iAUB.
have [/eqP ->|/set0P A0] := boolP (A == set0); first by rewrite set0U hlength0 add0e.
have [/eqP ->|/set0P B0] := boolP (B == set0); first by rewrite setU0 hlength0 adde0.
wlog : A B A0 B0 AB0 iA iB iAUB / lt_itv (Rhull A) (Rhull B).
  move=> H; have [/eqP AB|AB] := boolP (Rhull A == Rhull B).
      move/(congr1 set_of_itv) : AB AB0.
      rewrite RhullK ?inE// RhullK ?inE// => ->.
      by rewrite setIid => /eqP; move/set0P : B0 => /negbTE ->.
  have /orP[|] := total_le_itv (Rhull A) (Rhull B).
    by rewrite /le_itv (negbTE AB) orFb; exact: H.
  rewrite /le_itv eq_sym (negbTE AB) orFb => {}AB.
  by rewrite setUC H // 1?addeC// 1?setIC// 1?setU // setUC.
move=> AB.
have : contiguous_itv (Rhull A) (Rhull B).
  apply le_itv_disjoint_contiguous => //; try by rewrite -set_of_itv_neq0 RhullK ?inE//; exact/set0P.
  by rewrite ltW_itv.
  by rewrite disjoint_itv_Rhull.
  by rewrite RhullK ?inE// RhullK ?inE.
rewrite /contiguous_itv => /eqP A2B1.
rewrite /hlength A2B1 Rhull_setU2 // Rhull_setU1 // [in RHS]addeC ![in RHS]addeA.
congr (_ - _)%E.
rewrite subeK //.
destruct (Rhull B).1 as [b b1|[]] => //.
- move/set0P : A0; apply: absurdb.
 rewrite -(@RhullK _ A) ?inE //.
  rewrite set_of_itvNlt_set0 //.
  by rewrite /neitv topredE inE A2B1 -leNgt.
- apply: (absurd A2B1); apply/eqP.
  apply: (@le_itv_disjoint_bnd2Noo _ _ (Rhull B)) => //; try by rewrite -set_of_itv_neq0 RhullK ?inE//; exact/set0P.
  exact/ltW_itv.
  by rewrite disjoint_itv_Rhull.
Qed.

Lemma cover_restr T I D' D (F : I -> set T) :
  D `<=` D' -> (forall i, D' i -> ~ D i -> F i = set0) ->
  cover D F = cover D' F.
Proof.
move=> DD' D'DF; rewrite /cover eqEsubset; split=> [r [i Di Fit]|r [i D'i Fit]].
- by have [D'i|] := pselect (D' i); [exists i | have := DD' _ Di].
- by have [Di|Di] := pselect (D i); [exists i | move: Fit; rewrite (D'DF i)].
Qed.

Lemma perm_subset_set_of_itv_nth (D : set nat) (s s' : seq (interval R)) :
  [set k | (k < size s)%N] `<=` D -> perm_eq s s' ->
  [set set_of_itv (nth 0%O s i) | i in D] `<=`
    [set set_of_itv (nth 0%O s' i) | i in D].
Proof.
move=> sD ss' A [i Di iA].
have [/(mem_nth 0%O)|si] := ltnP i (size s); last first.
  move: iA; rewrite nth_default // => <-.
  by exists i => //; rewrite nth_default // -(perm_size ss').
move/perm_mem : (ss') => ->.
move/(nthP 0%O) => [j js' ji]; exists j; last by rewrite ji.
by apply sD; rewrite (perm_size ss').
Qed.

Lemma perm_set_of_itv_nth (D : set nat) (s s' : seq (interval R)) :
  [set k | (k < size s)%N] `<=` D -> perm_eq s s' ->
  [set set_of_itv (nth 0%O s i) | i in D] =
    [set set_of_itv (nth 0%O s' i) | i in D].
Proof.
move=> sD ss'; rewrite eqEsubset; split; apply perm_subset_set_of_itv_nth => //.
by rewrite -(perm_size ss').
by rewrite perm_sym.
Qed.

Lemma eqcover_r (D : set nat) (F G : nat -> set R) :
  [set F i | i in D] = [set G i | i in D] ->
  cover D F = cover D G.
Proof.
move=> FG.
rewrite eqEsubset; split => [t [i Di Fit]|t [i Di Git]].
  have [j Dj GF] : [set G i | i in D] (F i) by rewrite -FG /mkset; exists i.
  by exists j => //; rewrite GF.
have [j Dj GF] : [set F i | i in D] (G i) by rewrite FG /mkset; exists i.
by exists j => //; rewrite GF.
Qed.

Lemma cover_set_of_itv_nth_sort (D : set nat) (s : seq (interval R)) :
  [set k | (k < size s)%N] `<=` D ->
  cover D (fun i => set_of_itv (nth 0%O s i)) =
  cover D (fun i => set_of_itv (nth 0%O (sort le_itv s) i)).
Proof.
move=> sD.
apply eqcover_r.
apply perm_set_of_itv_nth => //.
by rewrite perm_sym perm_sort.
Qed.

Lemma cover_set_of_itv_nthE (s : seq (interval R)) (D : set nat) :
  [set k | (k < size s)%N] `<=` D ->
  cover D (fun i => set_of_itv (nth 0%O s i)) =
    \big[setU/set0]_(i <- s) (set_of_itv i).
Proof.
move=> sD; rewrite eqEsubset; split => [r [i Di ri]|r].
- rewrite -bigcup_set; exists (nth 0%O s i) => //; apply/mem_nth.
  by rewrite ltnNge; apply: contraPN ri => si; rewrite nth_default.
- rewrite -bigcup_set => -[/= i /(nthP 0%O)[k ks <-{i} kr]]; exists k => //.
  exact: sD.
Qed.

(* NB: not used*)
Lemma all_nonempty_set_of_itv_nth_sort (s : seq (interval R)) :
  (forall i, (i < size s)%N -> set_of_itv (nth 0%O s i) !=set0) ->
  (forall i, (i < size s)%N -> set_of_itv (nth 0%O (sort le_itv s) i) !=set0).
Proof.
move=> sne i /= si.
have [u us ->] := perm_iota_sort le_itv 0%O s.
rewrite (nth_map 0%O); last by rewrite (perm_size us) size_iota.
apply sne.
have : nth O u i \in iota 0 (size s).
  by rewrite -(perm_mem us) mem_nth // (leq_trans si) // (perm_size us) size_iota.
by rewrite mem_iota leq0n add0n.
Qed.

Lemma hlengthUitv (A : set R) (s : seq (interval R)) :
  is_interval A ->
  cover setT (fun i => set_of_itv (nth 0%O s i)) = A ->
  trivIset setT (fun i => set_of_itv (nth 0%O s i)) ->
  hlength A = (\sum_(i <- s) hlength (set_of_itv i))%E.
Proof.
move=> Aitv AE ts.
have Fmap (s' : seq (interval R)) :
    (fun i => set_of_itv (nth 0%O s' i)) =
      (fun i => nth 0%O (map set_of_itv s') i).
  apply/funext => i; have [is'|is'] := ltnP i (size s').
    by rewrite (nth_map 0%O).
  by rewrite !nth_default ?size_map// set_of_itv0.
wlog : s ts AE / sorted le_itv s => [hwlog|].
  have /permPl pss := perm_sort le_itv s.
  rewrite -(perm_big _ pss); apply: hwlog; [exact: trivIset_sort|
    by rewrite -cover_set_of_itv_nth_sort|exact: (sort_sorted total_le_itv)].
elim: (s : seq _) => [|j {}s IHs]/= in A Aitv ts AE *.
  rewrite /cover bigcup0 in AE; last by move=> i _; rewrite nth_nil set_of_itvE.
  by rewrite !big_nil/= in AE * => _; rewrite -AE hlength0.
rewrite (path_sortedE le_itv_trans) => /andP[/allP/= j_small s_sorted].
set K := \big[setU/set0]_(j <- s) set_of_itv j.
have K_itv : is_interval K.
  move=> x z Kx Kz y /andP[xy yz].
  have: A y.
    apply: (Aitv x z); rewrite ?xy//;
      by rewrite -AE cover_set_of_itv_nthE// big_cons; right.
  rewrite -AE /= cover_set_of_itv_nthE// big_cons=> -[]//.
  move=> /set_of_itv_mem jy; move: Kx; rewrite /K.
  rewrite -bigcup_set => -[k/= ks /set_of_itv_mem kx].
  suff: x > y by case: ltgtP xy.
  apply: (lt_itv_le (j_small k ks)) => //.
  have /(nthP 0%O)[ik ik_small <-] := ks.
  rewrite /disjoint_itv; apply/eqP.
  by have /trivIsetP-/(_ 0%N ik.+1 I I isT) := ts.
transitivity (hlength (set_of_itv j) + hlength K)%E; last first.
  rewrite big_cons; congr (_ + _)%E; rewrite IHs// ?cover_set_of_itv_nthE//.
  by move=> i0 i1 _ _ /(ts i0.+1 i1.+1 I I)[].
rewrite -AE cover_set_of_itv_nthE// big_cons /= hlength_itvU//.
- rewrite big_distrr/= big1_seq => //= i /(nthP 0%O)[ii ii_lt <-].
  by apply: contraTeq isT => /set0P-/(ts 0%N ii.+1 I I).
- exact: interval_is_interval.
- by move: AE; rewrite cover_set_of_itv_nthE// big_cons => ->.
Qed.

Lemma trivIset_itv_meet (J : seq (interval R)) (i : interval R) :
  trivIset setT (fun i : nat => set_of_itv (nth 0%O J i)) ->
  trivIset setT (fun i0 : nat => set_of_itv (nth 0%O [seq itv_meet i j | j <- J] i0)).
Proof.
move=> tJ.
rewrite -(@trivIset_restr _ _ _ [set k | (k < size J)%N]) //; last first.
  by move=> k _ /negP; rewrite -leqNgt => Jk; rewrite nth_default ?size_map// set_of_itvE.
apply/trivIsetP => a b aJ bJ ab.
rewrite (nth_map 0%O) // (nth_map 0%O) // !set_of_itv_meet setIACA setIid.
by move/trivIsetP : tJ => -> //; rewrite setI0.
Qed.

Lemma cover_hlength_set_of_itv (I J : seq (interval R)) :
  cover setT (fun i => set_of_itv (nth 0%O I i)) =
    cover setT (fun i => set_of_itv (nth 0%O J i)) ->
  trivIset setT (fun i => set_of_itv (nth 0%O J i)) ->
  forall i, i \in I ->
  hlength (set_of_itv i) = (\sum_(j <- J) hlength (set_of_itv (itv_meet i j)))%E.
Proof.
move=> IJ tJ i iI.
have h : set_of_itv i = \big[setU/set0]_(j <- J) (set_of_itv i `&` set_of_itv j).
  rewrite -big_distrr /= (big_nth 0%O) big_mkord.
  move/esym: (IJ); rewrite -(@cover_restr _ _ _ [set k | (k < size J)%N]) //; last first.
    by move=> k _ /negP; rewrite -leqNgt => Jk; rewrite nth_default // set_of_itvE.
  rewrite /cover -bigcup_ord => ->; apply/esym; rewrite setIidPl.
  move: iI => /(nthP 0%O)[k kI <-].
  exact: (@bigcup_sup _ _ k setT (fun i => set_of_itv (nth 0%O I i))).
rewrite h (@hlengthUitv _ [seq (itv_meet i j) | j <- J]) // ?big_map//.
- by rewrite -h; apply: interval_is_interval.
- rewrite -(@cover_restr _ _ _ [set k | (k < size J)%N]) //; last first.
    by move=> k _ /negP; rewrite -leqNgt => Jk; rewrite nth_default ?size_map// set_of_itvE.
  rewrite /cover -bigcup_ord (big_nth 0%O) big_mkord.
  by apply eq_bigr => k _; rewrite (nth_map 0%O) // set_of_itv_meet.
- exact: trivIset_itv_meet.
Qed.

Lemma hlengthUset (I J : seq (interval R)) :
  cover setT (fun i => set_of_itv (nth 0%O I i)) =
    cover setT (fun i => set_of_itv (nth 0%O J i)) ->
  trivIset setT (fun i => set_of_itv (nth 0%O I i)) ->
  trivIset setT (fun i => set_of_itv (nth 0%O J i)) ->
  (\sum_(i <- I) hlength (set_of_itv i) = \sum_(i <- J) hlength (set_of_itv i))%E.
Proof.
move=> IJ tI tJ.
rewrite big_seq [RHS]big_seq.
(under eq_bigr) => [i /(cover_hlength_set_of_itv IJ tJ) ->|]; first over.
rewrite /= exchange_big /=; apply/esym.
(under eq_bigr) => [j /(cover_hlength_set_of_itv (esym IJ) tI) ->|]; first over.
rewrite -big_seq; apply eq_bigr => j _; rewrite -big_seq.
by under eq_bigr do rewrite itv_meetC.
Qed.

Lemma hlength_bigcup_finite_cond (j : nat -> interval R) (P : set nat) :
  (hlength (\bigcup_(k in P) set_of_itv (j k)) < +oo)%E ->
  forall k, P k -> (hlength (set_of_itv (j k)) < +oo)%E.
Proof.
move=> joo k Pk; rewrite ltNge lee_pinfty_eq; apply/negP => /eqP jkoo.
have /le_hlength : set_of_itv (j k) `<=` \bigcup_(k in P) (set_of_itv (j k)).
  by move=> r jkr; exists k.
by rewrite {}jkoo leNgt => /negP; apply.
Qed.

Lemma hlength_bigcup_finite (j : nat -> interval R) :
  (hlength (\bigcup_k set_of_itv (j k)) < +oo)%E ->
  forall k, (hlength (set_of_itv (j k)) < +oo)%E.
Proof.
move=> joo k; rewrite ltNge lee_pinfty_eq; apply/negP => /eqP jkoo.
have /le_hlength : set_of_itv (j k) `<=` \bigcup_k (set_of_itv (j k)).
  by move=> r jkr; exists k.
by rewrite {}jkoo leNgt => /negP; apply.
Qed.

End seq_interval_rbnd.

Lemma ereal_mem_Interval (R : realDomainType) (r : R) (a b : itv_bound R) :
  (a < r%:E < b)%E -> r \in Interval a b.
Proof.
move: a b => [[]a|[]] [[]b|[]] //=; rewrite ?lte_fin ?in_itv //= => /andP[] //.
- by move=> /ltW ->.
- by move=> /ltW -> /ltW ->.
- by move=> /ltW ->.
- by move=> -> /ltW.
- by move=> ->.
- by move=> _ /ltW.
Qed.

Lemma Interval_ereal_mem (R : realDomainType) (r : R) (a b : itv_bound R) :
  r \in Interval a b -> (a <= r%:E <= b)%E.
Proof.
move: a b => [[]a|[]] [[]b|[]] //=; rewrite ?lee_fin ?in_itv ?(andbT,andbF) //=.
- by move=> /andP[-> /ltW ->].
- by move=> ->; rewrite lee_pinfty.
- by move=> /andP[/ltW -> /ltW ->].
- by move=> /andP[/ltW ->].
- by move=> /ltW ->; rewrite lee_pinfty.
- by move=> /ltW ->; rewrite lee_ninfty.
- by move=> ->; rewrite lee_ninfty.
- by move=> _; rewrite lee_pinfty lee_ninfty.
Qed.

Lemma Decompose_set0 (R : realType) (s : seq (interval R)) : [sset of s] = set0 ->
  forall i, i \in Decompose s -> i =i pred0.
Proof.
move=> s0 i si x; apply/idP/idP; apply/negP => xi.
have : [sset of Decompose s] = [sset of s].
  rewrite /Decompose cover_decompose //; last exact: (sort_sorted total_le_itv).
  by rewrite sset_sort_le_itv sset_filter_neitv.
by rewrite s0 =>/eqP; apply/negP/set0P; exists x; rewrite sset_bigcup; exists i.
Qed.

Lemma le_sum_measure_bigcup (R : realType)
   (S : nat -> set (sset_algebraOfSetsType R))
   (l : {additive_measure set (sset_algebraOfSetsType R) -> \bar R}) :
   (forall k, measurable (S k)) -> measurable (\bigcup_n S n) -> trivIset setT S ->
  forall n, (\sum_(k < n) l (S k) <= l (\bigcup_k S k))%E.
Proof.
move=> mS US tS n.
have : \big[setU/set0]_(i < n) S i `<=` \bigcup_i S i.
  by move=> /= r; rewrite -bigcup_set => -[/= k _ Skr]; exists k.
move: (@bigsetU_measurable _ _ (enum 'I_n) xpredT _ (fun k _ => mS k)).
rewrite [in X in X -> _]big_enum => mU /(le_measure l) /=.
rewrite !inE /=.
move=> /(_ mU US); apply: le_trans.
by rewrite measure_additive.
Qed.

Section slength_definition.
Variable R : realType.
Implicit Types i : interval R.

Definition slength (X : set R) : \bar R :=
  let s := xget [::] [set s | X = [sset of s] ] in
  (\sum_(i <- Decompose s) hlength (set_of_itv i))%E.

Lemma slength_ge0 (X : set (sset_algebraOfSetsType R)) : (0 <= slength X)%E.
Proof.
rewrite /slength; case: xgetP => [/= x _ _|_]; last first.
  by rewrite Decompose_nil big_nil.
by apply/sume_ge0 => i _; apply hlength_ge0.
Qed.

Lemma slength0 : slength set0 = 0%E.
Proof.
rewrite /slength; case: xgetP => [|_]; last by rewrite Decompose_nil big_nil.
move=> /= x _ /esym/Decompose_set0 x0; rewrite big_seq big1//.
by move=> i /x0/set_of_itv0P ->; rewrite hlength0.
Qed.

Lemma slength_itv i : slength (set_of_itv i) = hlength (set_of_itv i).
Proof.
have [/eqP ->|i0] := boolP (set_of_itv i == set0).
  by rewrite slength0 hlength0.
rewrite /slength; case: xgetP => [/= s _ si|]; last first.
  by move=> /(_ [fset i]%fset) /=; rewrite ssetE big_seq_fset1.
rewrite -[RHS]/((hlength \o set_of_itv) i) -[RHS](big_seq1 adde_monoid i).
apply: hlengthUset.
+ do 2 rewrite cover_set_of_itv_nthE//.
  case: (decomposition_of_Decompose s) => sorted_s disjoint_s cover_s.
  by rewrite -!ssetE cover_s -si ssetE big_seq1.
+ apply: (trivIset_decompose (sort_sorted total_le_itv _)); apply/allP => j.
  by rewrite mem_sort /= mem_filter => /andP[].
+ apply/trivIsetP => -[|a] [|b] //=;
    by rewrite nth_nil set_of_itvE ?(setI0,set0I).
Qed.

End slength_definition.
Arguments slength {R}.
Arguments slength0 {R}.

Section slength_sigma_finite.
Variable R : realType.
Implicit Types (i : interval R) (n : nat).

(* centered closed interval *)
Definition ccitv n : interval R := `[ (-(n%:R))%R, n%:R].

Lemma slength_ccitv n : slength (set_of_itv (ccitv n)) = n.*2%:R%:E.
Proof.
rewrite slength_itv hlength_itv /= lte_fin -{1}(add0r (-n%:R)) ltr_subl_addl.
rewrite -natrD ltr0n addnn double_gt0 lt0n; case: ifPn => [|/negPn/eqP->//].
by rewrite -addnn natrD 2!addEFin opprK.
Qed.

Lemma slength_ccitv_sym b r n :
  slength (set_of_itv (Interval (BSide b r) +oo%O) `&` set_of_itv (ccitv n)) =
  slength (set_of_itv (Interval -oo%O (BSide b (- r))) `&` set_of_itv (ccitv n)).
Proof.
rewrite -2!set_of_itv_meet 2!slength_itv 2!hlength_itv /= 2!lte_fin; case: ifPn.
- rewrite ltUx => /andP[rn _]; case: ifPn.
  + rewrite ltxI => /andP[_ _]; congr (_%:E); rewrite opprK addrC.
    congr (_ + _)%R; rewrite joinEtotal meetEtotal /maxr /minr {rn}.
    have [rn|rn|rn] := ltgtP r (- n%:~R).
    * by rewrite ifF // ?opprK //; apply/negbTE; rewrite -leNgt -ler_oppr ltW.
    * by rewrite ifT // ltr_oppl.
    * by rewrite {2}rn opprK ltxx rn opprK.
   + rewrite ltxI negb_and -2!leNgt ler_oppl opprK (leNgt _ r) rn /=.
     rewrite -subr_le0 opprK -natrD lern0 addnn double_eq0 => /eqP n0.
     by rewrite n0 sub0r join_r // ?opprK // ltW //; move: rn; rewrite n0 oppr0.
- case: ifPn => //.
  rewrite ltxI => /andP[]; rewrite -ltr_oppl opprK => rn _.
  rewrite -leNgt lexU leNgt rn /= -subr_le0 opprK -natrD lern0 addnn double_eq0.
  move=> /eqP n0; rewrite n0 addr0 meet_r // ler_oppr oppr0 ltW //; move: rn.
  by rewrite n0.
Qed.

Lemma slength_sigma_finite :
  sigma_finite setT (slength : set (sset_algebraOfSetsType R) -> \bar R).
Proof.
exists (set_of_itv \o ccitv).
  rewrite predeqE => /= r; split => // _; have [r0|r0] := leP 0 r.
  - exists (absz (ceil r)) => //; apply/set_of_itv_mem.
    rewrite itv_boundlr/= 2!lte_bnd (le_trans _ r0)/= ?oppr_le0 ?ler0n//.
    by rewrite natr_absz ger0_norm ?ceil_ge0// ceil_ge.
  - exists (absz (floor r)) => //; apply/set_of_itv_mem.
    rewrite itv_boundlr/= 2!lte_bnd (le_trans (ltW r0)) ?ler0n// andbT.
    by rewrite natr_absz ltr0_norm ?floor_lt0// mulrNz opprK floor_le.
move=> n; split.
  by exists [fset (ccitv n)]%fset; rewrite ssetE big_seq_fset1.
by rewrite slength_itv hlength_itv /= -(fun_if (@EFin _)) lte_pinfty.
Qed.

End slength_sigma_finite.

Section slength_additive.
Variable R : realType.
Implicit Types i : interval R.

Local Lemma slength_additive_seq (s : seq (interval R)) :
  trivIset setT (fun k => set_of_itv (nth 0%O s k)) ->
  slength [sset of s] = (\sum_(j <- s) slength (set_of_itv j))%E.
Proof.
move=> ts.
rewrite {1}/slength; case: xgetP => [/= s' _ Xs'|/(_ s)]; last first.
  by rewrite /=; tauto.
apply/esym; under eq_bigr do rewrite slength_itv; apply/esym.
apply: hlengthUset => //.
- do 2 rewrite cover_set_of_itv_nthE//.
  have [_ _ cover_s'] := decomposition_of_Decompose s'.
  by rewrite -ssetE cover_s' -Xs'.
- apply/(trivIset_decompose (sort_sorted total_le_itv _))/allP => j.
  by rewrite mem_sort /= mem_filter => /andP[].
Qed.

Lemma slength_additive :
  additive (slength : set (sset_algebraOfSetsType R) -> \bar R).
Proof.
apply/additive2P; first by rewrite slength0.
move=> A B /= [a Aa] [b Bb] AB0.
set a' := Decompose a; set b' := Decompose b.
have ABE : A `|` B = [sset of a' ++ b'].
  rewrite Aa Bb.
  have [_ _ <-] := decomposition_of_Decompose a.
  have [_ _ <-] := decomposition_of_Decompose b.
  by rewrite [in RHS]ssetE big_cat.
have tAB : trivIset setT (fun k => set_of_itv (nth 0%O (a' ++ b') k)).
  apply/trivIsetP => k1 k2 _ _.
  wlog : k1 k2 / (k1 < k2)%N.
    move=> h; rewrite eqn_leq negb_and -2!ltnNge => /orP[k2k1|k1k2].
      by rewrite setIC h // lt_eqF.
    by rewrite h // lt_eqF.
  move=> k1k2 _.
  have [k2a'b'|a'b'k2] := ltnP k2 (size (a' ++ b')); last first.
    by rewrite setIC nth_default // set_of_itvE set0I.
  have [k2a'|a'k2] := ltnP k2 (size a').
    rewrite nth_cat (ltn_trans k1k2) // nth_cat k2a'.
    have /trivIsetP := @trivIset_Decompose _ a.
    by apply => //; rewrite ltn_eqF.
  have [k1a'|a'k1] := ltnP k1 (size a').
    rewrite nth_cat k1a' nth_cat ltnNge a'k2 /=; apply: subsetI_eq0 AB0.
    - rewrite Aa; have [_ _ <-] := decomposition_of_Decompose a.
      rewrite sset_bigcup => r /set_of_itv_mem ra'.
      by exists (nth 0%O a' k1) => //; exact/mem_nth.
    - rewrite Bb; have [_ _ <-] := decomposition_of_Decompose b.
      rewrite sset_bigcup => r /set_of_itv_mem rb'.
      exists (nth 0%O b' (k2 - size a')) => //.
      by apply/mem_nth; rewrite ltn_subLR // -size_cat.
  rewrite nth_cat ltnNge a'k1 /= nth_cat ltnNge a'k2 /=.
  have /trivIsetP := @trivIset_Decompose _ b.
  by apply => //; rewrite -(eqn_add2r (size a')) (subnK a'k1) (subnK a'k2) ltn_eqF.
rewrite ABE slength_additive_seq // (_ : A = [sset of a']); last first.
  rewrite /a' /Decompose (cover_decompose (sort_sorted total_le_itv _)) //.
  by rewrite sset_sort_le_itv sset_filter_neitv.
rewrite slength_additive_seq; last first.
  apply/trivIsetP => i j _ _ ij.
  move/trivIsetP : tAB => /(_ i j Logic.I Logic.I ij).
  rewrite nth_cat; case: ifPn => [ia'|]; last first.
    by rewrite -leqNgt => a'i; rewrite (nth_default _ a'i) set_of_itvE set0I.
  rewrite nth_cat; case: ifPn => [//|].
  by rewrite -leqNgt => b'i; rewrite (nth_default _ b'i) set_of_itvE setI0.
rewrite (_ : B = [sset of b']); last first.
  rewrite (cover_decompose (sort_sorted total_le_itv _)) //.
  by rewrite sset_sort_le_itv sset_filter_neitv.
rewrite slength_additive_seq ?big_cat//.
apply/trivIsetP => i j _ _ ij.
move/trivIsetP : tAB => /(_ (size a' + i)%N (size a' + j)%N Logic.I Logic.I).
rewrite eqn_add2l => /(_ ij).
rewrite nth_cat -ltn_subRL subnn ltn0 addnC addnK.
by rewrite nth_cat -ltn_subRL subnn ltn0 addnC addnK.
Qed.

Lemma semi_additive_slength :
  semi_additive (slength : set (sset_algebraOfSetsType R) -> _).
Proof. by rewrite semi_additiveE; exact: slength_additive. Qed.

Lemma semi_additive2_slength :
  semi_additive2 (slength : set (sset_algebraOfSetsType R) -> _).
Proof. exact/(semi_additive2P slength0)/semi_additive_slength. Qed.

Definition slength_additive_measure :
    {additive_measure set (sset_algebraOfSetsType R) -> \bar R} :=
  AdditiveMeasure.Pack _ (AdditiveMeasure.Axioms slength0
    (fun X _ => slength_ge0 X) semi_additive2_slength).
Canonical slength_additive_measure.

Corollary le_slengthU_sumslength (A : seq (set R)) :
  (forall a : set R, a \in A -> Sset.is_sset a) ->
  (slength (\big[setU/set0]_(a <- A) a) <= \sum_(a <- A) (slength a))%E.
Proof.
move=> mA.
do 2 rewrite (big_nth set0) big_mkord.
apply: (Boole_inequality [additive_measure of (slength : set (sset_algebraOfSetsType R) -> _)]) => /= k.
have [kA|kA] := ltnP k (size A).
  case: k kA=> [? |k kA]; first exact/mA/mem_nth.
  exact/mA/mem_nth.
by rewrite nth_default //; exact: measurable0.
Qed.

End slength_additive.

(* NB: really useful? *)
Lemma is_cvg_sum_slength (R : realType) (F : (set (sset_algebraOfSetsType R))^nat) (P : pred nat) m :
  (forall k, P k -> measurable (F k)) -> cvg (fun n => (\sum_(m <= k < n | P k) slength (F k))%E).
Proof.
by move=> mF; apply: is_cvg_ereal_nneg_natsum_cond => n mn Pn; exact/slength_ge0.
Qed.

Lemma sum_slength_neitv (R : realType) (j : (interval R)^nat) :
  ((fun n => \sum_(0 <= k < n) slength (set_of_itv (j k))) =
   (fun n => \sum_(0 <= k < n | neitv (j k)) slength (set_of_itv (j k))))%E.
Proof.
rewrite funeqE => n; rewrite 2!big_mkord (bigID (fun k : 'I_n => neitv (j k))) /=.
rewrite addeC big1 ?add0e // => k; rewrite -set_of_itv_neq0 => /negPn/eqP ->.
by rewrite slength0.
Qed.

Lemma measurable_itv (R : realType) (i : interval R) :
  measurable (set_of_itv i : set (sset_algebraOfSetsType R)).
Proof. exact/Sset.is_sset_itv. Qed.

Section slength_sigma_additive_on_intervals.
Variable R : realType.
Implicit Types i : interval R.

Lemma slength_sigma_subadditive_on_finite_intervals i (j : (interval R)^nat)
    (P : pred nat) :
  (hlength (set_of_itv i) < +oo)%E ->
  P `<=` neitv \o j ->
  set_of_itv i `<=` \bigcup_(k in P) set_of_itv (j k) ->
  (slength (set_of_itv i) <= \sum_(k <oo | P k) slength (set_of_itv (j k)))%E.
Proof.
move=> iNoo jne ij.
set l := lim _; have := lee_pinfty l.
rewrite le_eqVlt => /orP[/eqP ->|loo]; first by rewrite lee_pinfty.
have [j_finite|] := pselect (forall k, P k -> hlength (set_of_itv (j k)) < +oo)%E; last first.
  move/existsNP => -[k /not_implyP[Pk] /negP].
  rewrite -leNgt lee_pinfty_eq => /eqP jkoo.
  rewrite /l (ereal_nneg_series_pinfty _ Pk) // ?lee_pinfty// ?slength_itv//.
  by move=> n _; apply/measure_ge0/measurable_itv.
have [/eqP->|] := boolP (set_of_itv i == set0).
  by rewrite slength0 ereal_nneg_series_lim_ge0// => k _; apply/measure_ge0/measurable_itv.
rewrite set_of_itv_neq0 => i0.
have [ri1 ri2] := hlength_finite_fin_num i0 iNoo.
set a := real_of_extended i.1; set b := real_of_extended i.2.
have [ab|ba] := ltP a b; last first.
  rewrite slength_itv hlength_itv ltNge {1}(EFin_real_of_extended ri1).
  rewrite {1}(EFin_real_of_extended ri2) -/a -/b lee_fin ba /=.
  by rewrite ereal_nneg_series_lim_ge0// => k _; apply/measure_ge0/measurable_itv.
suff baj : forall e : {posnum R},
    (b%:E - a%:E <= \sum_(k <oo | P k) slength (set_of_itv (j k)) + e%:num%:E)%E.
  rewrite (@le_trans _ _ (b%:E - a%:E)%E) //.
    rewrite slength_itv hlength_itv (EFin_real_of_extended ri1).
    by rewrite (EFin_real_of_extended ri2) -/a -/b lte_fin ab.
  by apply lee_adde => e; exact: baj.
move=> e.
set a' := (a + e%:num/4%:R)%R.
set b' := (b - e%:num/4%:R)%R.
have a'b'i : {subset `[a', b'] <= i}.
  apply/subset_of_itvP => r /set_of_itv_mem; rewrite in_itv /= => /andP[a'r rb'].
  apply/set_of_itv_mem; rewrite (IntervalE i).
  apply: ereal_mem_Interval.
  rewrite (EFin_real_of_extended ri1) (EFin_real_of_extended ri2).
  rewrite -/a -/b 2!lte_fin; apply/andP; split.
    by rewrite (lt_le_trans _ a'r) // /a' ltr_addl.
  by rewrite (le_lt_trans rb') // /b' ltr_subl_addl ltr_addr.
set a_ := fun k => real_of_extended (j k).1.
set b_ := fun k => real_of_extended (j k).2.
set a'_ := (fun k => a_ k - e%:num / (2 ^ k.+3)%:R)%R.
set b'_ := (fun k => b_ k + e%:num / (2 ^ k.+3)%:R)%R.
have ia_b_ : set_of_itv i `<=` \bigcup_(k in P) set_of_itv `] (a'_ k) , (b'_ k) [.
  move/subset_trans : ij; apply => r [k Pk].
  have [/eqP ->//|jk0 /set_of_itv_mem] := boolP (set_of_itv (j k) == set0).
  rewrite (IntervalE (j k)) => /Interval_ereal_mem /andP[jk1r rjk2].
  move: (j_finite _ Pk).
  rewrite set_of_itv_neq0 in jk0; move/(hlength_finite_fin_num jk0) => [jk1 jk2].
  exists k => //; apply/set_of_itv_mem; rewrite in_itv /=; apply/andP; split.
    rewrite -lte_fin (lt_le_trans _ jk1r) // /a'_ /a_.
    rewrite subEFin lte_subl_addr {2}(EFin_real_of_extended jk1) //.
    by rewrite -addEFin lte_fin ltr_addl divr_gt0 // ltr0n expn_gt0.
  rewrite -lte_fin (le_lt_trans rjk2) // /b'_ /b_.
  rewrite {1}(EFin_real_of_extended jk2) // lte_fin ltr_addl.
  by rewrite divr_gt0 // ltr0n expn_gt0.
have a'b'a'_b'_ : [set x | x \in `[a', b']] `<=` \bigcup_(k in P) (set_of_itv `](a'_ k), (b'_ k)[).
  by move/subset_of_itvP : a'b'i => /subset_trans; apply.
have [F [HF HF_]] : exists F : {fset nat},
  (set_of_itv `[a', b'] `<=` \bigcup_(k in [set x | (x \in F) && (P x)]) set_of_itv `] (a'_ k), (b'_ k) [) /\
  [set x | x \in F] `<=` P.
  have h : forall j, P j -> @open [topologicalType of R^o] (set_of_itv `](a'_ j), (b'_ j)[).
    by move=> k _; exact: interval_open.
  have := @segment_compact _ a' b'.
  (* NB: Borel-Lebesgue theorem *)
  rewrite compact_cover => /(_ _ _ _ h a'b'a'_b'_) => -[F FP a'b'F]; exists F.
  split; last by move=> x /FP; rewrite inE.
  move=> r /a'b'F[k Fk kr]; exists k => //=.
  by rewrite Fk /=; move/FP : Fk; rewrite inE.
set F' := [fset k in F | neitv `](a'_ k), (b'_ k)[]%fset.
have HF' : set_of_itv `[a', b'] `<=` \bigcup_(k in [set x | x \in F']) set_of_itv `](a'_ k), (b'_ k)[.
  move/subset_trans : HF; apply.
  move=> r [/= k /andP[kF Pk]].
  have [/eqP -> //|a'b'kr] := boolP (set_of_itv `](a'_ k), (b'_ k)[ == set0).
  rewrite set_of_itv_neq0 in a'b'kr.
  by exists k => //; rewrite /mkset /F' !inE /= a'b'kr andbT.
have : (b'%:E - a'%:E <= \sum_(k <oo | P k) slength (set_of_itv (j k)) + (e%:num / 2)%:E)%E.
  have [a'b'|b'a'] := ltP a' b'; last first.
    rewrite (@le_trans _ _ 0%:E) //; first by rewrite sube_le0 lee_fin.
    rewrite adde_ge0 // ?lee_fin//.
    by apply: ereal_nneg_series_lim_ge0 => k _; exact/slength_ge0.
  rewrite (@le_trans _ _ (slength (set_of_itv `[a', b']))) //.
    by rewrite slength_itv hlength_itv /= lte_fin a'b'.
  have F'_ringOfSets : forall x, x \in [seq set_of_itv `](a'_ k), (b'_ k)[ | k <- F'] -> Sset.is_sset x.
    by move=> x /mapP[/= p pF' ->{x}]; exists [:: `](a'_ p), (b'_ p)[ ]; rewrite sset_cons1.
  rewrite (@le_trans _ _ (slength (\big[setU/set0]_(k <- F') set_of_itv `] (a'_ k), (b'_ k) [))) //.
    apply/le_measure => //.
      by rewrite inE /=; exact/Sset.is_sset_itv.
      by rewrite inE /=; apply: bigsetU_measurable => n _; exact/Sset.is_sset_itv.
    by move/subset_trans : HF'; apply; rewrite bigcup_set.
  rewrite (@le_trans _ _ (\sum_(k <- F') (b'_ k - a'_ k)%:E)%E) //.
    move: (@le_slengthU_sumslength _ [seq (set_of_itv `](a'_ k), (b'_ k)[) | k <- F'] F'_ringOfSets).
    rewrite big_map => /le_trans; apply.
    rewrite big_map /F' 2!big_fset /= ; apply: lee_sum => k.
    rewrite /neitv /= lte_bnd => a'b'k0.
    by rewrite slength_itv hlength_itv /= lte_fin a'b'k0.
  apply: (le_trans _ (@epsilon_trick _ (slength \o set_of_itv \o j) _ P _)) => //; last first.
    by move=> n; apply/slength_ge0.
  rewrite [X in (X <= _)%E](_ : _ = (\sum_(k <- F') ((b_ k - a_ k) + (e%:num / (2 ^ k.+2)%:R))%:E)%E); last first.
    apply eq_bigr => /= k ?.
    rewrite /a'_ /b'_; congr (_ %:E).
    rewrite opprB addrA addrC 2!addrA (addrC _ (b_ k)) -addrA; congr (_ + _)%R.
    by rewrite -mulrDl -mulr2n -mulr_natl expnS natrM -mulf_div divff // mul1r.
  under eq_bigr do rewrite addEFin.
  rewrite big_split /=.
  (* TODO: lemma *)
  have cvggeo : (fun n => \sum_(i < n) (e%:num / (2 ^ i.+2)%:R)%:E)%E --> (e%:num / 2)%:E.
    rewrite (_ : (fun n => _) = (@EFin _) \o series (fun k => e%:num / (2 ^ (k + 2))%:R)); last first.
      rewrite funeqE => n; rewrite /series /=.
      rewrite (@big_morph _ _ (@EFin _) 0%:E adde) // big_mkord.
      by under eq_bigr do rewrite -[in X in (_ ^X)%:R]addn2.
    apply: cvg_comp; last apply cvg_refl.
    have := @cvg_geometric_series_half _ e%:num 1.
    by rewrite expr1.
  have ? : cvg (fun n => \sum_(k < n | P k) (e%:num / (2 ^ k.+2)%:R)%:E)%E.
    under eq_fun do rewrite -(big_mkord P (fun k => (e%:num / (2 ^ k.+2)%:R)%:E)).
    by apply: is_cvg_ereal_nneg_series => n _; rewrite lee_fin divr_ge0// ler0n.
  apply (@le_trans _ _ (\sum_(k <oo | P k) slength (set_of_itv (j k)) +
                        \sum_(k <oo | P k) (e%:num / (2 ^ k.+2)%:R)%:E))%E; last first.
    rewrite -ereal_limD //; last 3 first.
      by apply: is_cvg_sum_slength => k Pk; exact/measurable_itv.
      by under eq_fun do rewrite big_mkord.
      have /andP[l0 le2] : (0 <= \sum_(k <oo | P k) (e%:num / (2 ^ k.+2)%:R)%:E <= (e%:num / 2)%:E)%E.
        apply/andP; split.
          rewrite (@ereal_nneg_series_lim_ge0 _ (fun k => (e%:num / (2 ^ k.+2)%:R)%:E)) // => n _.
          by apply divr_ge0 => //; rewrite ler0n.
        move/cvg_lim : (cvggeo) => <- //=.
        apply lee_lim => //.
          by under eq_fun do rewrite big_mkord.
          under eq_fun do rewrite -(big_mkord xpredT (fun k => (e%:num / (2 ^ k.+2)%:R)%:E)).
          by apply: is_cvg_ereal_nneg_series => n _; rewrite lee_fin divr_ge0 // ler0n.
        near=> n.
        rewrite (big_mkord P (fun k => (e%:num / (2 ^ k.+2)%:R)%:E)).
        move: (@lee_sum_nneg R _ (enum 'I_n) xpredT P (fun k => (e%:num / (2 ^ k.+2)%:R)%:E)).
        rewrite big_enum big_enum_cond; apply => k _ _.
        by apply divr_ge0 => //; rewrite ler0n.
      apply: fin_num_adde_def => //.
      rewrite fin_numE gt_eqF /=; last by rewrite (lt_le_trans _ l0) // lte_ninfty.
      by rewrite lt_eqF // (le_lt_trans le2) // lte_pinfty.
    rewrite (_ : (fun x => _) = (fun x => \sum_(0 <= k < x | P k) (slength (set_of_itv (j k)) + (e%:num / 2 / (2 ^ k.+1)%:R)%:E)))%E //.
    rewrite funeqE => n; rewrite big_split => /=; congr (_ + _)%E.
    by apply eq_bigr => m Pm; rewrite expnS natrM invfM -mulrA.
  have sum_F'_P : forall f : nat -> \bar R, (\sum_(k <- F') f k = \sum_(k <- F' | P k) f k)%E.
    move=> f; apply eq_fbigl_cond => // k; apply/idP/idP => /=.
      rewrite !inE andbT => /andP[/= kF -> /=].
      by rewrite andbT kF /=; apply/HF_.
    by rewrite !inE andbT => /andP[].
  apply: lee_add; last first.
    set f := (fun i : nat => \sum_(k < i | P k) (e%:num / (2 ^ i.+2)%:R)%:E)%E.
    rewrite (@le_trans _ _ (\sum_(k <oo | P k) (e%:num / (2 ^ k.+2)%:R)%:E)%E) //.
    rewrite sum_F'_P.
    by apply: lee_sum_lim => n _; apply divr_ge0 => //; rewrite ler0n.
  rewrite [X in (X <= _)%E](_ : _ = (\sum_(k <- F') slength (set_of_itv (j k)))%E); last first.
    apply eq_fbigr => k /imfsetP[/= p]; rewrite !inE => /andP[pF a'b'p0 ->{k} ?].
    rewrite /b_ /a_ slength_itv hlength_itv.
    have [? ?] : (((j p).1 : \bar R) \is a fin_num) /\ (((j p).2 : \bar R) \is a fin_num).
      apply hlength_finite_fin_num.
        by apply: jne => //; exact: (HF_ _ pF).
      by apply j_finite => //; exact: (HF_ _ pF).
    rewrite subEFin -EFin_real_of_extended // -EFin_real_of_extended //.
    have /jne : P p := HF_ _ pF.
    rewrite /neitv => /ltW/le_bnd_er.
    rewrite le_eqVlt => /orP[/eqP ->|->//].
    by rewrite ltxx subee.
  by rewrite sum_F'_P; apply: lee_sum_lim => k _; exact/slength_ge0.
have -> : (b'%:E - a'%:E = (b%:E - a%:E) - (e%:num / 2)%:E)%E.
  rewrite /a' /b' (addEFin a) oppeD (subEFin b) -addeA.
  rewrite (addeCA (- (e%:num / 4%:R)%:E)%E) addeA; congr (_ + _)%E.
  rewrite -oppeD; congr oppe.
  rewrite -addEFin; congr (_%:E).
  by rewrite -mulrDl -mulr2n -mulr_natl (natrM _ 2 2) -mulf_div divff // mul1r.
rewrite lee_subl_addr => /le_trans; apply.
rewrite le_eqVlt; apply/orP; left; apply/eqP.
rewrite -addeA; congr adde.
by rewrite -addEFin -mulrDl -mulr2n -mulr_natr -mulrA divff ?mulr1.
Grab Existential Variables. all: end_near. Qed.

Lemma slength_sigma_additive_on_finite_intervals i (j : (interval R)^nat) :
  set_of_itv i = \bigcup_k set_of_itv (j k) ->
  trivIset setT (set_of_itv \o j) ->
  (hlength (set_of_itv i) < +oo)%E ->
  (slength (set_of_itv i) = \sum_(k <oo) slength (set_of_itv (j k)))%E.
Proof.
move=> ij tj iNoo.
apply/eqP; rewrite eq_le; apply/andP; split.
  pose P := neitv \o j.
  have : set_of_itv i `<=` \bigcup_(k in [set x | neitv (j x)]) set_of_itv (j k).
    suff : set_of_itv i = \bigcup_(k in [set x | neitv (j x)]) set_of_itv (j k) by move=> ->.
    rewrite ij; apply/predeqP => r; split => [[x _ jxr]|[x]].
      by exists x => //; rewrite /mkset; rewrite -set_of_itv_neq0; apply/set0P; exists r.
    by exists x.
  move/(@slength_sigma_subadditive_on_finite_intervals _ j P iNoo (fun x => id)).
  move/le_trans; apply; apply: lee_lim.
  + by apply: is_cvg_sum_slength => n jn0; exact/Sset.is_sset_itv.
  + by apply: is_cvg_sum_slength => n _; exact/Sset.is_sset_itv.
  + near=> n.
    rewrite 2!big_mkord.
    move: (@lee_sum_nneg R _ (enum 'I_n) xpredT (neitv \o j) (slength \o set_of_itv \o j)).
    rewrite /= big_enum_cond big_enum; apply.
    by move=> x _ _; exact/slength_ge0.
apply: ereal_lim_le.
  by apply: is_cvg_sum_slength => n _; exact/Sset.is_sset_itv.
near=> n.
rewrite [X in (X <= _)%E](_ : _ = slength (\big[setU/set0]_(k < n) set_of_itv (j k))) //; last first.
  rewrite big_mkord.
  apply/esym/(@measure_additive(*slength_additive*) _ _ (@slength_additive_measure R) (set_of_itv \o j)) => // k.
  by exists [:: j k]; rewrite sset_cons1.
apply: le_measure.
- by rewrite inE /=; apply: bigsetU_measurable => k _; exact/Sset.is_sset_itv.
- by rewrite inE /=; exact/Sset.is_sset_itv.
- by rewrite ij -bigcup_set /= => r [k /= _ jkr]; exists k.
Grab Existential Variables. all: end_near. Qed.

Lemma slength_sigma_subadditive_on_infinite_intervals i (j : (interval R)^nat) (P : pred nat) :
  (hlength (set_of_itv i) = +oo)%E ->
  (forall k, P k -> neitv (j k)) ->
  set_of_itv i `<=` \bigcup_(k in P) set_of_itv (j k) ->
  (slength (set_of_itv i) <= \sum_(k <oo | P k) slength (set_of_itv (j k)))%E.
Proof.
move=> ioo jne ij.
suff h : forall M, M > 0 -> \forall n \near \oo,
    (M%:E <= \sum_(0 <= k < n | P k) slength (set_of_itv (j k)))%E.
  rewrite slength_itv ioo lee_pinfty_eq; apply/eqP.
  apply/cvg_lim => //; apply/ereal_cvgPpinfty => M M0.
  exact: h.
set iIccitv := fun n => set_of_itv i `&` set_of_itv (ccitv R n).
have len_iIccitv_dvg : forall M, M > 0 -> exists n, (n >= 1)%N /\ (M%:E < slength (iIccitv n))%E.
  move=> M M0.
  move/hlength_oo : ioo => [[b [r iroo]]|ioo]; last first.
    have ? : (0 < `|ceil M|)%N by rewrite absz_gt0 gt_eqF // ceil_gt0.
    exists `|ceil M|%N; split=> //; rewrite /iIccitv ioo set_of_itvE setTI.
    rewrite slength_ccitv lte_fin (le_lt_trans (ceil_ge _)) // -muln2 natrM.
    by rewrite natr_absz gtr0_norm ?ceil_gt0// ltr_pmulr ?ltr1n// ltr0z ceil_gt0.
  rewrite /iIccitv.
  wlog : i {ij iIccitv} b r {iroo} / i = Interval -oo%O (BSide b r).
    move=> h; move: iroo => [->|iroo]; first exact: h.
    have [N [N0 MN]] := h _ b (- r) erefl.
    by exists N; split => //; rewrite iroo slength_ccitv_sym.
  move=> ->{i}.
  have [r0|r0] := ler0P r.
    exists (`|ceil (`| r | + M) |%N.+1); split => //.
    rewrite -set_of_itv_meet slength_itv hlength_itv /= lte_fin ltxI ltz_opp //.
    rewrite andbT ltr_oppl opprK meet_l ?(le_trans r0)//.
    rewrite -addn1 natrD natr_absz ger0_norm ?ceil_ge0// ?(addr_ge0 _ (ltW _))//.
    case: ifPn => [_|/negP].
      rewrite lte_fin -ltr_subl_addl ltr_spaddr//.
      by rewrite (le_trans _ (ceil_ge _))// addrC ler_add2r ler0_norm.
    apply: absurd; rewrite ltr_spaddr//.
    by rewrite (le_trans _ (ceil_ge _)) // (ler_paddr (ltW _))// ler0_norm.
  move=> [:crM]; exists (`|ceil (`| r | + M)|%N); split.
    abstract: crM.
    by rewrite absz_gt0 gt_eqF // ceil_gt0 // -(addr0 0) ler_lt_add.
  rewrite -set_of_itv_meet slength_itv hlength_itv /= lte_fin ltxI ltz_opp //.
  rewrite ltr_oppl opprK andbT.
  rewrite natr_absz ger0_norm ?ceil_ge0// ?(addr_ge0 _ (ltW _))// gtr0_norm//.
  rewrite meet_l; last first.
    by rewrite (le_trans (ceil_ge _)) // ler_int le_ceil // ler_addl ltW.
  case: ifPn => [_|/negP].
    rewrite lte_fin -{1}(add0r M) ltr_le_add//.
    by rewrite (le_trans (ceil_ge _)) // ler_int le_ceil // ler_addr ltW.
  apply: absurd; rewrite -oppr_lt0 in r0.
  by rewrite (lt_le_trans r0)// ler0z ceil_ge0// addr_ge0// ?ltW// -oppr_lt0.
move=> M M0.
have {len_iIccitv_dvg}[N [N0 MN]] := len_iIccitv_dvg _ M0.
set jIccitv := fun N k => set_of_itv (j k) `&` set_of_itv (ccitv R N).
have len_jIccitv_dvg : \forall n \near \oo, (M%:E <= \sum_(k < n | P k) slength (jIccitv N k))%E.
  have iUj : forall N, iIccitv N `<=` \bigcup_(k in P) (jIccitv N k).
    move=> n.
    by move/(@setSI _ _ _ (set_of_itv (ccitv R n))) : ij; rewrite bigcup_distrl.
  apply lte_lim => //.
  + apply: (@lee_sum_nneg_ord _ (slength \o jIccitv N)) => n Pn.
    by apply: slength_ge0; rewrite /jIN -set_of_itv_meet; exact/Sset.is_sset_itv.
  + under eq_fun do rewrite -(big_mkord P (slength \o jIccitv N)).
    apply: is_cvg_ereal_nneg_series => n _.
    by apply: slength_ge0; rewrite /jIN -set_of_itv_meet; exact/Sset.is_sset_itv.
  + rewrite (lt_le_trans MN) // /iIccitv -set_of_itv_meet.
    under eq_fun do rewrite -(big_mkord P (slength \o jIccitv N)).
    rewrite [X in (_ <= X)%E](_ : _ = (\sum_(k <oo | P k)
      slength (set_of_itv (itv_meet (j k) (ccitv R N))))); last first.
      congr (lim _).
      by rewrite funeqE => /= n; under eq_bigr do rewrite /jIccitv -set_of_itv_meet.
    rewrite (_ : (fun n => _) =
      (fun n => \sum_(k < n | P k && (neitv (itv_meet (j k) (ccitv R N))))
      slength (set_of_itv (itv_meet (j k) (ccitv R N))))%E); last first.
      rewrite funeqE => /= n.
      rewrite big_mkord.
      rewrite (bigID (fun k : 'I_n => neitv (itv_meet (j k) (ccitv R N)))) /=.
      rewrite addeC big1 ?add0e // => k /andP[?].
      by rewrite -set_of_itv_neq0 => /negPn/eqP ->; rewrite slength0.
    under eq_fun do rewrite -(big_mkord (fun k => P k && (neitv (itv_meet (j k) (ccitv R N))))
      (fun k => slength (set_of_itv (itv_meet (j k) (ccitv R N))))).
    apply: (@slength_sigma_subadditive_on_finite_intervals _ (fun k => itv_meet (j k) (ccitv R N))
      (fun k => P k && (neitv (itv_meet (j k) (ccitv R N))))) => //.
    + rewrite (@le_lt_trans _ _ (hlength (set_of_itv (ccitv R N)))) //.
      by apply le_hlength; rewrite set_of_itv_meet; apply subIset; right.
    + by rewrite -slength_itv slength_ccitv lte_pinfty.
    + by move=> k /andP[].
    + apply: (@subset_trans _ (\bigcup_(k in P) (set_of_itv (itv_meet (j k) (ccitv R N))))).
        by move=> x; rewrite set_of_itv_meet => /iUj [k ? Hk]; exists k => //; rewrite set_of_itv_meet.
      move=> r [k Pk kr]; exists k => //; rewrite Pk /=.
      by rewrite -set_of_itv_neq0; apply/set0P; exists r.
have [m _ Hm] : \forall n \near \oo, (M%:E <= \sum_(k < n | P k) slength (set_of_itv (j k)))%E.
  case: len_jIccitv_dvg => m [mN]; exists m => // p /= mp.
  have /le_trans := mN _ mp; apply; apply: lee_sum => /= q _.
  rewrite /jIccitv; apply: le_measure => //.
  - by rewrite inE /=; apply: measurableI => //; exact/Sset.is_sset_itv.
  - by rewrite inE /=; exact/Sset.is_sset_itv.
  - by apply: subIset; left.
near=> n.
rewrite big_mkord.
by have /Hm mn : (m <= n)%N by near: n; exists m.
Grab Existential Variables. all: end_near. Qed.

Lemma slength_sigma_subadditive_on_intervals i (j : (interval R)^nat) (P : pred nat) :
  (forall k, P k -> neitv (j k)) ->
  set_of_itv i `<=` \bigcup_(k in P) set_of_itv (j k) ->
  (slength (set_of_itv i) <= \sum_(k <oo | P k) slength (set_of_itv (j k)))%E.
Proof.
move=> jne ij.
have := lee_pinfty (hlength (set_of_itv i)).
rewrite le_eqVlt => /orP[/eqP ioo|ioo]; last first.
  exact: slength_sigma_subadditive_on_finite_intervals.
exact: slength_sigma_subadditive_on_infinite_intervals.
Qed.

Lemma slength_sigma_additive_on_intervals i (j : (interval R)^nat) :
  set_of_itv i = \bigcup_k set_of_itv (j k) ->
  trivIset setT (set_of_itv \o j) ->
  slength (set_of_itv i) = \sum_(k <oo) slength (set_of_itv (j k)).
Proof.
move=> ij tj.
have := lee_pinfty (hlength (set_of_itv i)).
rewrite le_eqVlt => /orP[/eqP ioo|iNoo]; last exact: slength_sigma_additive_on_finite_intervals.
rewrite slength_itv ioo sum_slength_neitv; apply/esym/eqP.
rewrite -lee_pinfty_eq -ioo -slength_itv.
apply: slength_sigma_subadditive_on_intervals => //.
move=> r; rewrite ij => -[n _ jnr]; exists n => //=.
by rewrite -set_of_itv_neq0; apply/set0P; exists r.
Qed.

End slength_sigma_additive_on_intervals.

Section addressing_sequence_of_simple_sets.
Variables (R : realType) (s : nat -> seq (interval R)).
Hypothesis s0 : forall n, size (s n) != O. (* no empty intervals *)

(* indirect address *)
Fixpoint indaddr (b p : nat) : nat * nat :=
  if p isn't p'.+1 then (b, O) else
    if (p'.+1 < size (s b))%N then (b, p'.+1) else
      indaddr b.+1 (p' - (size (s b)).-1)%N.

Lemma indaddrE b p : indaddr b p =
 if (p < size (s b))%N then (b, p) else indaddr b.+1 (p - size (s b))%N.
Proof.
case: p => [|p] /= in b *; first by rewrite lt0n s0.
case: ifPn => //; rewrite -leqNgt => sbp1.
by rewrite -{2}(@prednK (size (s b))) // lt0n.
Qed.

(* direct address *)
(* x.2 < size (s x.1) *)
Definition diraddr (x : nat * nat) := (\sum_(x < x.1) size (s x) + x.2)%N.

Lemma indaddrK (b p : nat) : (p < size (s b))%N ->
 diraddr (indaddr b p) = diraddr (b, p).
Proof.
elim: b p => [p s0p|b ih p psb1].
  by rewrite indaddrE s0p.
by rewrite indaddrE psb1.
Qed.

Lemma diraddrK (n p k : nat) : (p < size (s (n + k)))%N ->
  indaddr k (diraddr (n + k, p)%N - \sum_(i < k) size (s i)) = (n + k, p)%N.
Proof.
elim: n p k => [p k ps0|n ih p k psn1].
  by rewrite add0n {1}/diraddr (addnC _ p) addnK indaddrE ps0.
rewrite indaddrE ifF; last first.
  apply/negbTE.
  rewrite -leqNgt /diraddr (addnC _ p) (addnC _ k).
  rewrite -(big_mkord xpredT (size \o s)) /index_iota subn0 iotaD big_cat.
  rewrite -{2}(subn0 k) big_mkord add0n.
  rewrite [n.+1]lock /= -lock (addnC (\sum_(i < k) size (s i))%N) addnA addnK.
  by rewrite /= big_cons addnCA leq_addr.
rewrite {1}addSnnS.
rewrite (_ : _ - _ = diraddr (n + k.+1, p)%N - \sum_(i < k.+1) size (s i))%N; last first.
  by rewrite big_ord_recr /= subnDA.
by rewrite ih ?addSnnS // -addSnnS.
Qed.

Definition nth_interval (n : nat) : interval R :=
  let: (b, k) := indaddr O n in nth 0%O (s b) k.

Lemma nth_interval_diraddr (n p : nat) : (p < size (s n))%N ->
  nth_interval (diraddr (n, p)) = nth 0%O (s n) p.
Proof.
move=> psn.
rewrite /nth_interval (_ : indaddr _ _ = (n, p)) //.
by move: (@diraddrK n p O); rewrite addn0 big_ord0 subn0 => ->.
Qed.

Lemma map_nth_interval (n : nat) :
  [seq nth_interval (diraddr (n, i)) | i <- iota 0 (size (s n))] = s n.
Proof.
apply(@eq_from_nth _ 0%O).
  by rewrite size_map size_iota.
move=> i; rewrite size_map size_iota => isn.
rewrite [in LHS](nth_map 0%O) ?size_iota// -[in RHS]nth_interval_diraddr //.
by rewrite nth_iota.
Qed.

Lemma map_nth_interval_diraddr n k : flatten [seq s i | i <- iota k n] =
  [seq nth_interval i | i <- iota (diraddr (k, O)) (\sum_(x < (k + n)) size (s x) - \sum_(x < k) size (s x))].
Proof.
have [m nm] := ubnP n; elim: m => // m ih in n k nm *.
destruct n as [|n].
  by rewrite /= addn0 subnn.
rewrite /= ih //.
rewrite -map_nth_interval map_comp -map_cat; congr map.
rewrite {1}/diraddr [in LHS]/= -iotaDl.
rewrite -/(diraddr (k, O)) {2}/diraddr big_ord_recr /= addnAC -/(diraddr _) -iotaD; congr iota.
rewrite addnC addSnnS subnDA subnK //.
have lem : forall a b, (\sum_(i < a) size (s i) <= \sum_(x < a + b) size (s x))%N.
  move=> a b.
  rewrite -[X in (_ <= X)%N](big_mkord xpredT (fun x => size (s x))) /index_iota subn0 iotaD big_cat.
  by rewrite -[in X in (_ <= X)%N](subn0 a) -/(index_iota _ _) big_mkord leq_addr.
rewrite leq_subRL.
  by rewrite -(big_ord_recr k (size \o s)) /= -addSnnS lem.
by rewrite lem.
Qed.

Lemma flatten_map_nth_interval n :
  exists u, flatten [seq s i | i <- iota 0 n] = [seq nth_interval i | i <- iota 0 n] ++ u.
Proof.
exists [seq nth_interval i | i <- iota n (diraddr (n, O) - n)].
rewrite -map_cat -iotaD /diraddr addn0 (addnC n) subnK; last first.
  rewrite -{1}(muln1 n) -{1}(subn0 n) -sum_nat_const_nat big_mkord leq_sum // => a _.
  by rewrite lt0n.
by rewrite map_nth_interval_diraddr big_ord0 subn0 add0n /diraddr big_ord0 /= addn0.
Qed.

End addressing_sequence_of_simple_sets.

Lemma bigcup_bigU_bigcup (R : realType) (f : (seq (interval R))^nat) :
  (forall n, size (f n) != O) ->
  \bigcup_k \big[setU/set0]_(i <- f k) set_of_itv i = \bigcup_k set_of_itv (nth_interval f k).
Proof.
move=> f0; rewrite eqEsubset; split => r.
  move=> -[n Hn]; rewrite -bigcup_set => -[/= I].
  move=> /(nthP 0%O)[p pn <-{I}] /set_of_itv_mem rnp.
  exists (diraddr f (n, p)) => //.
  apply/set_of_itv_mem.
  by rewrite nth_interval_diraddr.
move=> [n _ /set_of_itv_mem] ; rewrite /nth_interval.
move Hx : (indaddr _ _ _) => x.
destruct x as [x1 x2] => rx2.
exists x1 => //.
rewrite -bigcup_set.
exists (nth 0%O (f x1) x2); last by apply/set_of_itv_mem.
rewrite /mkset; apply/(nthP 0%O); exists x2 => //.
rewrite ltnNge; apply: contraPN rx2 => /(nth_default 0%O) ->.
by rewrite in_itv.
Qed.

Lemma sum_nth_interval_sum_sum (R : realType) (f : (seq (interval R))^nat) (l : set R -> \bar R) :
  (forall x, 0 <= l x)%E ->
  (forall n, size (f n) != O) ->
  (\sum_(k <oo) l (set_of_itv (nth_interval f k)) <=
   \sum_(k <oo) \sum_(x <- f k) l (set_of_itv x))%E.
Proof.
move=> l_ge0 f0; apply: lee_lim.
- by apply: is_cvg_ereal_nneg_natsum_cond => n _ _; apply: l_ge0.
- apply: is_cvg_ereal_nneg_natsum_cond => n _ _; apply: sume_ge0 => i _.
  exact: l_ge0.
- near=> n.
  rewrite 2!big_mkord.
  have -> : (\sum_(k < n) \sum_(x <- f k) l(set_of_itv x) =
            \sum_(k <- flatten (map f (iota 0 n))) l (set_of_itv k))%E.
    by rewrite big_flatten /= big_map -[in RHS](subn0 n) -/(index_iota _ _) big_mkord.
  have -> : (\sum_(k < n) l (set_of_itv (nth_interval f k)) =
            \sum_(k <- map (nth_interval f) (iota 0 n)) l (set_of_itv k))%E.
    by rewrite big_map -[in RHS](subn0 n) -/(index_iota _ _) big_mkord.
  have [s' ->] := flatten_map_nth_interval f0 n.
  rewrite big_cat /= lee_addl //.
  by apply: sume_ge0 => I _; apply: l_ge0.
Grab Existential Variables. all: end_near. Qed.

Section slength_measure.
Variable R : realType.
Implicit Types i : interval R.

Definition nil_cons0 (f : (seq (interval R))^nat) :=
  fun k => if size (f k) == O then [:: 0%O] else f k.

Lemma nil_cons0P (f : (seq (interval R))^nat) : forall n, size (nil_cons0 f n) != O.
Proof. by move=> n; rewrite /nil_cons0; case: ifPn. Qed.

Lemma nil_cons0_bigU (f : (seq (interval R))^nat) k :
  \big[setU/set0]_(x <- f k) set_of_itv x =
  \big[setU/set0]_(x <- nil_cons0 f k) set_of_itv x.
Proof.
rewrite /nil_cons0.
case: (f k) => /= [|h t].
  by rewrite big_nil big_seq1 set_of_itvE.
by rewrite big_cons.
Qed.

Lemma nil_cons0_bigcup_bigU (f : (seq (interval R))^nat) :
  \bigcup_k \big[setU/set0]_(x <- f k) set_of_itv x =
  \bigcup_k \big[setU/set0]_(x <- nil_cons0 f k) set_of_itv x.
Proof. by congr bigcup; rewrite funeqE => j; exact: nil_cons0_bigU. Qed.

Lemma nil_cons0_sum (f : (seq (interval R))^nat) k :
  (\sum_(x <- f k) slength (set_of_itv x) =
   \sum_(x <- nil_cons0 f k) slength (set_of_itv x))%E.
Proof.
rewrite /nil_cons0.
case: (f k) => //=.
by rewrite big_nil big_seq1 set_of_itvE slength0.
Qed.

Lemma nil_cons0_lim (f : (seq (interval R))^nat) :
  \sum_(k <oo) \sum_(x <- f k) slength (set_of_itv x) =
  \sum_(k <oo) \sum_(x <- nil_cons0 f k) slength (set_of_itv x).
Proof.
rewrite (_ : (fun n => \sum_(0 <= k < n) (\sum_(x <- f k) slength (set_of_itv x))) =
    (fun n => \sum_(0 <= k < n) (\sum_(x <- nil_cons0 f k) slength (set_of_itv x))))%E //.
by rewrite funeqE => n; apply eq_bigr => j _; rewrite nil_cons0_sum.
Qed.

Local Lemma le_slength_itv_sumI (F : (set R)^nat)
  (s : (seq (interval R))^nat) : (forall k, F k = [sset of s k]) ->
  forall i, set_of_itv i `<=` \bigcup_k (F k) ->
  (slength (set_of_itv i) <= \sum_(k <oo) slength (set_of_itv i `&` F k))%E.
Proof.
move=> Fs i iF.
have {iF}iiF : set_of_itv i `<=` \bigcup_k (set_of_itv i `&` F k).
  by move=> r ir; move/iF : (ir) => [k _ Skr]; exists k.
pose Ds := Decompose \o s.
pose iDs := fun k => [seq itv_meet i x | x <- Ds k].
have {iiF} :
    set_of_itv i `<=` \bigcup_k (\big[setU/set0]_(x <- iDs k) set_of_itv x).
  move/subset_trans : iiF; apply => r [n _].
  rewrite [in X in X -> _]Fs ssetE big_distrr /= => sir.
  exists n => //; rewrite /iDs big_map.
  under eq_bigr do rewrite set_of_itv_meet.
  move: sir; rewrite -bigcup_set => -[/= j jsn [ir jr]].
  have [i' [i'sn i'r]] := mem_Decompose jsn jr.
  by rewrite -bigcup_set; exists i'.
rewrite nil_cons0_bigcup_bigU bigcup_bigU_bigcup //; last exact: nil_cons0P.
move=> iiF.
rewrite (_ : (fun _ => _) = (fun n => \sum_(0 <= k < n)
    (\sum_(x <- iDs k) slength (set_of_itv x)))%E); last first.
  rewrite funeqE => k; apply eq_bigr => {}k _.
  have -> : forall n, set_of_itv i `&` F n =
      \big[setU/set0]_(x <- iDs n) (set_of_itv x).
    move=> n; rewrite big_map.
    have [_ _] := decomposition_of_Decompose (s n).
    rewrite {1}ssetE -[Decompose _]/(Ds n) -(Fs n) => <-.
    rewrite big_distrr /=.
    by under eq_bigr do rewrite -set_of_itv_meet.
  rewrite (big_nth 0%O) big_mkord.
  rewrite (@measure_additive(*slength_additive*) _ _ (@slength_additive_measure R)
      (fun n => set_of_itv (nth 0%O (iDs k) n))) //; last 2 first.
    by move=> m; apply: Sset.is_sset_itv.
    exact/trivIset_itv_meet/trivIset_Decompose.
  by rewrite (big_nth 0%O) big_mkord.
rewrite nil_cons0_lim.
rewrite (le_trans _ (@sum_nth_interval_sum_sum _ (nil_cons0 iDs) slength _ _))//; last 2 first.
  by move=> x; apply: slength_ge0.
  exact: nil_cons0P.
rewrite sum_slength_neitv slength_sigma_subadditive_on_intervals => //.
apply: (subset_trans iiF) => r [k _ kr]; exists k => //.
by rewrite -set_of_itv_neq0; apply/set0P; exists r.
Grab Existential Variables. all: end_near. Qed.

Lemma seq_of_Sseq_of (S : (set (sset_algebraOfSetsType R))^nat) :
  (forall n, measurable (S n)) ->
  {seq_of : nat -> seq (interval R) & forall k, S k = [sset of seq_of k]}.
Proof. exact: (@choice _ _ (fun k s => S k = [sset of s])). Qed.

Lemma slength_semi_sigma_additive :
  semi_sigma_additive (slength : set (sset_algebraOfSetsType R) -> \bar R).
Proof.
move=> F mF tF mUF.
suff -> : slength (\bigcup_k F k) = \sum_(k <oo) slength (F k).
  under eq_fun do rewrite -(big_mkord xpredT (slength \o F)).
  exact/is_cvg_sum_slength.
apply/eqP; rewrite eq_le; apply/andP; split; last first.
  apply: (ereal_lim_le (is_cvg_sum_slength _)) => //.
  by near=> n; rewrite big_mkord; exact: le_sum_measure_bigcup.
have [seq_of Fseq_of] := seq_of_Sseq_of mF.
have [j [Fj tj]] : exists j : seq (interval R), \bigcup_k (F k) = [sset of j] /\
    trivIset setT (fun k => set_of_itv (nth 0%O j k)).
  have [j Fj] := mUF.
  exists (Decompose j); split.
    by rewrite Fj; have [_ _ ->] := decomposition_of_Decompose j.
  exact: trivIset_Decompose.
rewrite Fj ssetE (big_nth 0%O) big_mkord.
rewrite (@measure_additive(*slength_additive*) _ _ (@slength_additive_measure R)
    (fun n => set_of_itv (nth 0%O j n))) //; last first.
  by move=> i; exact/measurable_itv.
rewrite (@le_trans _ _ (\sum_(0 <= n < size j) (\sum_(k <oo) slength (set_of_itv (nth 0%O j n) `&` F k))))%E //.
  rewrite big_mkord; apply: lee_sum => n _.
  rewrite (@le_slength_itv_sumI F seq_of) // Fj ssetE (big_nth 0%O) big_mkord => r jnr.
  by rewrite -bigcup_set; exists n => //=; rewrite mem_index_enum.
rewrite (@le_trans _ _ (\sum_(n <oo) (\sum_(0 <= k < size j) slength (set_of_itv (nth 0%O j k) `&` F n))))%E //.
  rewrite (@ereal_pseries_sum_nat _ (size j) (fun n k => slength (set_of_itv (nth 0%O j n) `&` F k))) //.
  by move=> a b; apply slength_ge0.
apply lee_lim.
- apply: is_cvg_ereal_nneg_series => n _.
  by apply: sume_ge0 => /= i _; apply: slength_ge0.
- by apply/is_cvg_sum_slength => ? _; exact/mF.
- near=> n.
  apply: lee_sum => /= k _.
  have Fkj : F k = \bigcup_k0 (set_of_itv (nth 0%O j k0) `&` F k).
    rewrite -bigcup_distrl setIC; apply/esym/setIidPl.
    rewrite (_ : \bigcup_ _ _ = [sset of j]).
      by rewrite -Fj; apply: bigcup_sup.
    rewrite ssetE (big_nth 0%O) big_mkord (bigcup_recl (size j)) bigcup0 ?setU0// => i _.
    by rewrite nth_default ?set_of_itvE// leq_addr.
  rewrite {2}Fkj big_mkord le_sum_measure_bigcup//.
  + by move=> i; apply: measurableI => //; exact/measurable_itv.
  + by rewrite -Fkj.
  + by rewrite trivIset_setIC; exact: trivIset_setI.
Grab Existential Variables. all: end_near. Qed.

Definition slength_measure : {measure set (sset_algebraOfSetsType R) -> \bar R} :=
  Measure (Measure.Axioms slength0 (fun X _ => slength_ge0 X) slength_semi_sigma_additive).

Definition slength_ext_outer_measure
    : {outer_measure set (sset_algebraOfSetsType R) -> \bar R} :=
  [outer_measure of mu_ext slength_measure].

Definition length
    : {measure set (caratheodory_type slength_ext_outer_measure) -> \bar R} :=
  caratheodory_measure slength_ext_outer_measure.

End slength_measure.
Arguments slength_ext_outer_measure {R}.
Arguments length {R}.

Section intervals_are_measurable.
Variable R : realType.
Let M := [the measurableType of caratheodory_type (@slength_ext_outer_measure R)].

Lemma measurable_itv' (i : interval M) : (@measurable M) (set_of_itv i : set M).
Proof.
exact/subset_g_salgebra_caratheodory/g_salgebra_self/measurable_itv.
Qed.

End intervals_are_measurable.

Section lebesgue_measure.
Variable R : realType.
Let ssets := @measurable (@sset_algebraOfSetsType R).
Let gssets := g_salgebra_measurableType ssets.

Definition lebesgue_measure : {measure set gssets -> \bar R} :=
  Hahn_ext (@slength_measure R).

Lemma lebesgue_measure_unique :
  forall mu : {measure set gssets -> \bar R},
    (forall X, ssets X -> mu X = slength X) ->
    (forall X, measurable X -> lebesgue_measure X = mu X).
Proof.
move=> mu muslength X mX; apply: Hahn_ext_unique => //.
exact: slength_sigma_finite.
Qed.

End lebesgue_measure.

(* PR in progress *)
Definition measurable_fun (T U : measurableType) (D : set T) (f : T -> U) : Prop :=
  forall Y, measurable Y -> measurable ((f @^-1` Y) `&` D).
(* /PR in progress *)

Lemma bigcup_setU (T I : Type) (P : set I) (F G : I -> set T) :
  \bigcup_(i in P) (F i `|` G i) = (\bigcup_(i in P) F i) `|` (\bigcup_(i in P) G i).
Proof.
rewrite predeqE => x; split=> [[i Pi [Fix|Gix]]|[[i Pi Fix]|[i Pi Gix]]];
  by [left; exists i | right; exists i | exists i => //; left | exists i => //; right].
Qed.

Lemma orA : associative or.
Proof. by move=> P Q R; rewrite propeqE; split=> [|]; tauto. Qed.

Lemma subset_set2 T (A : set T) a b : A `<=` [set a; b] ->
  A = set0 \/ A = [set a] \/ A = [set b] \/ A = [set a; b].
Proof.
have [<-|ab Aab] := pselect (a = b).
  by rewrite setUid => Aa; have [|] := subset_set1 Aa; tauto.
have [Aa|Aa] := pselect (A `<=` [set a]).
  by rewrite orA; left; exact/subset_set1.
have [Ab|Ab] := pselect (A `<=` [set b]).
  have [A0|{}Ab] := subset_set1 Ab; first by left.
  by rewrite orA; right; left.
rewrite 2!orA; right; rewrite eqEsubset; split => //.
move/nonsubset : Ab => -[y [Ay yb]].
have <- : y = a by apply: contrapT => ya; move/Aab : Ay => [|].
move/nonsubset : Aa => -[z [Az za]].
have <- : z = b by apply: contrapT => zb; move/Aab : Az => [|].
by move=> _ [|] ->.
Qed.

Lemma EFin_inj (R : numDomainType) : injective (@EFin R).
Proof. by move=> a b; case. Qed.

Section sigma_algebra_R_Rbar.
Variable R : realType.

Fail Check forall (T : measurableType) (f : T -> R), measurable_fun setT f.

Let measurableTypeR :=
  g_salgebra_measurableType (@measurable (@sset_algebraOfSetsType R)).

Definition measurableR : set (set R) := @measurable measurableTypeR.

Definition R_isMeasurable : isMeasurable R :=
  isMeasurable.Build measurableTypeR
  measurable0 (@measurableC _) (@measurable_bigcup _).

HB.instance (Real.sort R) R_isMeasurable.

Check forall (T : measurableType) (f : T -> R), measurable_fun setT f.

(* powerset to extend the sigma-algebra for R *)
Definition PSoo : set (set \bar R) :=
  [set set0; [set -oo]; [set +oo]; [set -oo; +oo]]%E.

Inductive PSoo' : set \bar R -> Prop :=
| PS0 : PSoo' set0
| PSnoo : PSoo' [set -oo]%E
| PSpoo : PSoo' [set +oo]%E
| PSnpoo : PSoo' [set -oo; +oo]%E.

Lemma PSoo'P (A : set \bar R) : PSoo' A <-> A `<=` [set -oo; +oo]%E.
Proof.
split => [[]//|Aoo]; [by left|by right| ].
by have [|[|[|]]] := subset_set2 Aoo; move=> ->; constructor.
Qed.

Definition measurableRbar : set (set \bar R) :=
  [set (@EFin _ @` A) `|` B | A in measurableR & B in PSoo'].

Lemma measurableRbar0 : measurableRbar set0.
Proof.
exists set0; first exact: measurable0.
by exists set0; rewrite ?setU0// ?image_set0//; constructor.
Qed.

Lemma setCU_R_Rbar (A : set R) (B : set \bar R) : PSoo' B ->
  ~` ([set x%:E | x in A] `|` B) =
  [set x%:E | x in ~` A] `|` [set -oo%E; +oo%E] `&` ~` B.
Proof.
move=> PSoo'B; rewrite setCU.
have -> : ~` [set x%:E | x in A] = [set x%:E | x in ~` A] `|` [set -oo; +oo]%E.
  rewrite predeqE => -[x| |]; split.
  - by move=> Ax; left; exists x => //; apply: contra_not Ax => Ax; exists x.
  - by move=> [[r Ar [<-{x}]]|[]//]; apply: contra_not Ar => -[x Ax [<-]].
  - by move=> _; right; right.
  - by move=> [[]|[] _ []].
  - by move=> _; right; left.
  - by move=> [[]|[_ []|]].
rewrite setIUl; congr (_ `|` _).
rewrite predeqE => -[x| |]; split; try by case.
move=> [] x' Ax' [] <-{x}; split; first by exists x'.
by case: PSoo'B => // -[].
Qed.

Lemma measurableRbarC (X : set \bar R) :
  measurableRbar X -> measurableRbar (~` X).
Proof.
move => -[A mA] [B PooB <-]; rewrite setCU_R_Rbar //.
exists (~` A); first exact: measurableC.
exists ([set -oo%E; +oo%E] `&` ~` B) => //.
case: PooB.
- by rewrite setC0 setIT; constructor.
- rewrite setIUl setICr set0U -setDE.
  have [_ ->] := @setDidPl (\bar R) [set +oo%E] [set -oo%E].
    by constructor.
  by rewrite predeqE => x; split => // -[->].
- rewrite setIUl setICr setU0 -setDE.
  have [_ ->] := @setDidPl (\bar R) [set -oo%E] [set +oo%E].
    by constructor.
  by rewrite predeqE => x; split => // -[->].
- by rewrite setICr; constructor.
Qed.

Lemma measurableRbar_bigcup (F : (set \bar R)^nat) :
  (forall i, measurableRbar (F i)) ->
  measurableRbar (\bigcup_i (F i)).
Proof.
move=> mF.
pose P := fun i j => measurable j.1 /\ PSoo' j.2 /\
                  F i = [set x%:E | x in j.1] `|` j.2.
have [f fi] : {f : nat -> (set R) * (set \bar R) & forall i, P i (f i) }.
  by apply: choice => i; have [x mx [y PSoo'y] xy] := mF i; exists (x, y).
exists (\bigcup_i (f i).1).
  by apply: measurable_bigcup => i; exact: (fi i).1.
exists (\bigcup_i (f i).2).
  apply/PSoo'P => x [n _] fn2x.
  have /PSoo'P : PSoo' (f n).2 by have [_ []] := fi n.
  exact.
rewrite [RHS](@eqbigcup_r _ _ _ _
    (fun i => [set x%:E | x in (f i).1] `|` (f i).2)); last first.
  by move=> i; have [_ []] := fi i.
rewrite bigcup_setU; congr (_ `|` _).
rewrite predeqE => i /=; split=> [[r [n _ fn1r <-{i}]]|[n _ [r fn1r <-{i}]]];
 by [exists n => //; exists r | exists r => //; exists n].
Qed.

Definition Rbar_isMeasurable : isMeasurable \bar R :=
  isMeasurable.Build _ measurableRbar0 measurableRbarC measurableRbar_bigcup.

HB.instance (\bar (Real.sort R)) Rbar_isMeasurable.

Check forall (T : measurableType) (f : T -> \bar R), measurable_fun setT f.

End sigma_algebra_R_Rbar.
