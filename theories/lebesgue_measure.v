(* -*- company-coq-local-symbols: (("`&`" . ?∩) ("`|`" . ?∪) ("set0" . ?∅)); -*- *)
(* mathcomp analysis (c) 2017 Inria and AIST. License: CeCILL-C.              *)
From mathcomp Require Import all_ssreflect ssralg ssrnum ssrint interval.
From mathcomp Require Import finmap.
Require Import boolp reals ereal classical_sets posnum nngnum topology.
Require Import normedtype.
From HB Require Import structures.
Require Import sequences measure csum cardinality.

(******************************************************************************)
(*                         Lebesgue Measure (WIP)                             *)
(*                                                                            *)
(* This file contains a formalization of the Lebesgue measure using the       *)
(* Caratheodory's theorem available in measure.v and develops the theory of   *)
(* measurable functions.                                                      *)
(*                                                                            *)
(*           setI_closed G == the set of sets G is closed under finite        *)
(*                            intersection                                    *)
(*           setU_closed G == the set of sets G is closed under finite union  *)
(*           setC_closed G == the set of sets G is closed under complement    *)
(*           setD_closed G == the set of sets G is closed under difference    *)
(*          ndseq_closed G == the set of sets G is closed under               *)
(*                            non-decreasing countable union                  *)
(*       trivIset_closed G == the set of sets G is closed under               *)
(*                            pairwise-disjoint countable union               *)
(* are_measurable_sets D G == the set of sets G forms a sigma algebra on D    *)
(*         gen_class T G P == class generated from G satisfying P, i.e.,      *)
(*                            \bigcap_(A in [set M | P M /\ G `<=` M]) A      *)
(*             s<| D, G |> == sigma-algebra generated by G on D               *)
(*                s<< G >> := s<| setT, G |>                                  *)
(*      g_measurableType G == the measurableType corresponding to s<< G >>    *)
(*    preimage_class D f G == class generated by the preimages of G by f      *)
(*       image_class D f G == class generated by the images of G by f         *)
(*   is_monotone_class D C == C is a monotone class of subsets of D           *)
(*                dynkin G == G is a set of sets that form a Dynkin (or a     *)
(*                            lambda) system                                  *)
(*                d<< G >> == Dynkin system generated by G, i.e.,             *)
(*                            gen_class G dynkin                              *)
(*             Hahn_ext mu == extension of the measure mu over a ring of sets *)
(*                            to a measure of the generated sigma algebra     *)
(*                                                                            *)
(*                miditv i == middle point of interval i                      *)
(*                 neitv i == the interval i is non-empty                     *)
(*                            when the support type is a numFieldType, this   *)
(*                            is equivalent to (i.1 < i.2)%O (lemma neitvE)   *)
(*                                                                            *)
(*             [sset of s] == the finite union of the list of intervals s     *)
(*                            (a "simple set")                                *)
(*                                                                            *)
(*              itv_cplt s == complement of the list of intervals s           *)
(*            itv_diff i j == i \ j where i and j are intervals assuming      *)
(*                            ~ j <= i                                        *)
(*        disjoint_itv i j == intervals i and j are disjoint                  *)
(*      contiguous_itv i j == intervals i and j are contiguous                *)
(*              lt_itv i j == total ordering of intervals: the left bound of  *)
(*                            i is smaller than the one of j, and if it is    *)
(*                            equal then the right bound of i is smaller than *)
(*                            the one of j                                    *)
(*              le_itv i j := (i = j) \/ lt_itv i j                           *)
(*                 ccitv n == the centered closed interval [-n, n]            *)
(*                                                                            *)
(*      sorted_decompose s == turns a *sorted* list of intervals s into a     *)
(*                            list of non-overlapping intervals with the same *)
(*                            cover                                           *)
(*             decompose s == turn a list of intervals into a sequence of     *)
(*                            non-overlapping intervals with the same cover   *)
(*                                                                            *)
(*             Module Sset == simple sets form an algebra of sets             *)
(*                                                                            *)
(*               hlength A == length of the hull of the set of real numbers A *)
(*             hlengthUitv == (lemma) hlength is additive on intervals        *)
(*                                                                            *)
(*               slength A == measure of the set A when it is a simple set,   *)
(*                            and 0 o.w.                                      *)
(*    slength_sigma_finite == (lemma) slength is sigma-finite                 *)
(*                                                                            *)
(*        nth_interval f k == kth interval in the sequence f of lists of      *)
(*                            intervals                                       *)
(*                                                                            *)
(* The main proof is the proof that slength is sigma-additive. We list up the *)
(* several lemmas that make up this:                                          *)
(*   slength_additive == slength is additive                                  *)
(*   slength_sigma_subadditive_finite_itv == slength is sigma-subadditive     *)
(*     on finite intervals                                                    *)
(*   slength_sigma_additive_finite_itv == slength is additive on finite       *)
(*     intervals                                                              *)
(*   slength_sigma_subadditive_infinite_itv == slength is sigma-subadditive   *)
(*     on infinite intervals                                                  *)
(*   slength_sigma_subadditive_itv == slength is sigma-subadditive on         *)
(*     intervals                                                              *)
(*   slength_sigma_additive_itv == slength is sigma-additive on intervals     *)
(*   slength_semi_sigma_additive == slength is sigma-additive on simple sets  *)
(*                                                                            *)
(*      lebesgue_measure == the Lebesgue measure                              *)
(*                                                                            *)
(*              ps_infty == inductive definition of the powerset              *)
(*                          {0, {-oo}, {+oo}, {-oo,+oo}}                      *)
(*         emeasurable G == sigma-algebra over \bar R built out the           *)
(*                          measurables G of a sigma-algebra over R           *)
(*     elebesgue_measure == the Lebesgue measure extended to \bar R           *)
(*                                                                            *)
(* The modules RGenOInfty, RGenInftyO, RGenCInfty, RGenOpens provide proofs   *)
(* of equivalence between the sigma-algebra generated by list of intervals    *)
(* and the sigma-algebras generated by open rays, closed rays, and open       *)
(* intervals.                                                                 *)
(* The modules ErealGenOInfty and ErealGenCInfty provide proofs of            *)
(* equivalence between emeasurable and the sigmaa-algebras generated open     *)
(* rays and closed rays.                                                      *)
(*                                                                            *)
(*             sdrop u n := {u_k | k >= n}                                    *)
(*                sups u := [sequence sup (sdrop u n)]_n                      *)
(*                infs u := [sequence inf (sdrop u n)]_n                      *)
(*         lim_{inf,sup} == limit inferior/superior for realType              *)
(*               esups u := [sequence ereal_sup (sdrop u n)]_n                *)
(*               einfs u := [sequence ereal_inf (sdrop u n)]_n                *)
(*        elim_{inf,sup} == limit inferior/superior for \bar R                *)
(*                                                                            *)
(* Several properties of measurable functions                                 *)
(*                                                                            *)
(*   prod_measurableType == product of measurableType                         *)
(*                                                                            *)
(******************************************************************************)

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.
Import Order.TTheory GRing.Theory Num.Def Num.Theory.
Import numFieldTopology.Exports.

Local Open Scope classical_set_scope.
Local Open Scope ring_scope.
Local Open Scope ereal_scope.

(* NB: in MathComp 1.13.0 *)
Lemma natr_absz (R : numDomainType) i : `|i|%:R = `|i|%:~R :> R.
Proof. by rewrite -abszE. Qed.

Lemma ge_pinfty (R : numDomainType) (x : itv_bound R) :
  (+oo <= x)%O = (x == +oo)%O.
Proof. by move: x => [[]|[]]. Qed.

Lemma le_ninfty (R : numDomainType) (x : itv_bound R) :
  (x <= -oo)%O = (x == -oo%O).
Proof. by case: x => // -[]. Qed.

Lemma gt_pinfty (R : numDomainType) (x : itv_bound R) : (+oo%O < x)%O = false.
Proof. by case: x. Qed.

Lemma lt_ninfty (R : numDomainType) (x : itv_bound R) : (x < -oo%O)%O = false.
Proof. by case: x => // -[]. Qed.
(* /NB: in MathComp 1.13.0 *)

(******************************************************************************)
(*                         lemmas waiting to be PRed                          *)
(******************************************************************************)

(* TODO: move to classical_sets *)
Lemma memNset (T : Type) (A : set T) (u : T) : ~ A u -> u \in A = false.
Proof. by apply: contra_notF; rewrite inE. Qed.

Lemma in_set0 (T : Type) (x : T) : (x \in set0) = false.
Proof. by rewrite memNset. Qed.

Lemma in_setT T (x : T) : x \in setT.
Proof. by rewrite mem_set. Qed.

Lemma in_setC (T : Type) (x : T) (A : set T) : (x \in ~` A) = (x \notin A).
Proof.
have [xA|/negP xA] := boolP (x \in ~` A).
  by rewrite memNset//; rewrite inE in xA.
by rewrite mem_set//; move: xA; rewrite inE; apply: contrapT.
Qed.

Lemma in_setI (T : Type) (x : T) (A B : set T) :
  (x \in A `&` B) = (x \in A) && (x \in B).
Proof.
have [|] := boolP (x \in A `&` B).
  by rewrite inE => -[Ax Bx]; rewrite mem_set// mem_set.
rewrite notin_set -[~ _ _]/((~` (A `&` B)) x) setCI => -[Ax|Bx].
  by rewrite memNset.
by rewrite andbC memNset.
Qed.

Lemma in_setD (T : Type) (x : T) (A B : set T) :
  (x \in A `\` B) = (x \in A) && (x \notin B).
Proof.
have [|] := boolP (x \in A `\` B).
  by rewrite inE => -[Ax Bx]; rewrite mem_set// memNset.
rewrite setDE in_setI negb_and => /orP[xA|].
  by rewrite (negbTE xA).
by rewrite in_setC negbK => ->; rewrite andbC.
Qed.

Arguments preimage : simpl never.

Lemma comp_preimage T1 T2 T3 (A : set T3) (g : T1 -> T2) (f : T2 -> T3) :
  (f \o g) @^-1` A = g @^-1` (f @^-1` A).
Proof. by []. Qed.

Lemma preimage_id T (A : set T) : id @^-1` A = A. Proof. by []. Qed.

Lemma preimage_comp T1 T2 rT (g : T1 -> rT) (f : T2 -> rT) (C : set T1) :
  f @^-1` [set g x | x in C] = [set x | f x \in g @` C].
Proof.
rewrite predeqE => t; split => /=.
  by move=> -[r Cr <-]; rewrite inE;  exists r.
by rewrite /preimage /= inE => -[r Cr <-]; exists r.
Qed.

Lemma empty_preimage_setI {aT rT : Type} (f : aT -> rT) (Y1 Y2 : set rT) :
  f @^-1` (Y1 `&` Y2) = set0 <-> f @^-1` Y1 `&` f @^-1` Y2 = set0.
Proof.
by split; apply: contraPP => /eqP/set0P/(nonempty_preimage_setI f _ _).2/set0P/eqP.
Qed.

Lemma empty_preimage {aT rT : Type} (f : aT -> rT) (Y : set rT) :
  Y = set0 -> f @^-1` Y = set0.
Proof.
move=> ->.
by rewrite preimage_set0.
Qed.

Lemma preimage_abse_pinfty (R : numDomainType) :
  @abse R @^-1` [set +oo%E] = [set -oo%E; +oo%E].
Proof.
by rewrite predeqE => y; split ; move: y => [y//| |]//=; [right | left | case].
Qed.

Lemma preimage_abse_ninfty (R : realDomainType) :
  @abse R @^-1` [set -oo%E] = set0.
Proof.
rewrite predeqE => t; split => //=; apply/eqP.
by rewrite gt_eqF// (lt_le_trans _ (abse_ge0 t))// lte_ninfty.
Qed.

(* TODO: move to reals.v *)
Lemma sup_gt (R : realType) (S : set R) (x : R) : S !=set0 ->
  (x < sup S -> exists2 y, S y & x < y)%R.
Proof.
move=> S0; rewrite not_exists2P => + g; apply/negP; rewrite -leNgt.
by apply sup_le_ub => // y Sy; move: (g y) => -[// | /negP]; rewrite leNgt.
Qed.

Lemma inf_lt (R : realType) (S : set R) (x : R) : S !=set0 ->
  (inf S < x -> exists2 y, S y & y < x)%R.
Proof.
move=> /nonemptyN S0; rewrite /inf ltr_oppl => /sup_gt => /(_ S0)[r [r' Sr']].
by move=> <-; rewrite ltr_oppr opprK => r'x; exists r'.
Qed.

Lemma ltz_opp (R : numDomainType) (n : nat) :
  (0 < n)%N -> (- n%:R < n%:R :> R)%R.
Proof.
by move=> n0; rewrite -subr_lt0 -opprD -natrD oppr_lt0 ltr0n addn_gt0 n0.
Qed.

Lemma ltr_add_invr (R : realType) (y x : R) :
  (y < x -> exists k, y + k.+1%:R^-1 < x)%R.
Proof.
move=> yx.
exists (`|floor (x - y)^-1|%N).
rewrite -ltr_subr_addl -{2}(invrK (x - y)%R) ltr_pinv ?inE.
- rewrite -addn1 natrD natr_absz ger0_norm; last first.
    by rewrite floor_ge0 invr_ge0 subr_ge0 ltW.
  by rewrite -RfloorE lt_succ_Rfloor.
- by rewrite ltr0n andbT unitfE pnatr_eq0.
- by rewrite invr_gt0 subr_gt0 yx andbT unitfE invr_eq0 gt_eqF// subr_gt0.
Qed.

(* TODO: move to ereal.v *)
Lemma hasNub_ereal_sup (R : realType) (A : set (\bar R)) : ~ has_ubound A ->
  A !=set0 -> ereal_sup A = +oo%E.
Proof.
move=> hasNubA A0.
apply/eqP; rewrite eq_le lee_pinfty /= leNgt.
apply: contra_notN hasNubA => Aoo.
by exists (ereal_sup A); exact: ereal_sup_ub.
Qed.

Lemma ereal_sup_EFin (R : realType) (A : set R) :
  has_ubound A -> A !=set0 -> ereal_sup (EFin @` A) = (sup A)%:E.
Proof.
move=> has_ubA A0; apply/eqP; rewrite eq_le; apply/andP; split.
  by apply: ub_ereal_sup => /= y [r Ar <-{y}]; rewrite lee_fin sup_ub.
set esup := ereal_sup _; have := lee_pinfty esup.
rewrite le_eqVlt => /predU1P[->|esupoo]; first by rewrite lee_pinfty.
have := lee_ninfty esup; rewrite le_eqVlt => /predU1P[/esym|ooesup].
  case: A0 => i Ai.
  by move=> /ereal_sup_ninfty /(_ i%:E) /(_ (ex_intro2 A _ i Ai erefl)).
have esup_fin_num : esup \is a fin_num.
  rewrite fin_numE -lee_ninfty_eq -ltNge ooesup /= -lee_pinfty_eq -ltNge.
  by rewrite esupoo.
rewrite -(@fineK _ esup) // lee_fin leNgt.
apply/negP => /(sup_gt A0)[r Ar]; apply/negP; rewrite -leNgt.
by rewrite -lee_fin fineK//; apply: ereal_sup_ub; exists r.
Qed.

Lemma ereal_inf_EFin (R : realType) (A : set R) :
  has_lbound A -> A !=set0 -> ereal_inf (EFin @` A) = (inf A)%:E.
Proof.
move=> has_lbA A0; rewrite /ereal_inf /inf EFinN; congr (- _)%E.
rewrite -ereal_sup_EFin; [|exact/has_lb_ubN|exact/nonemptyN].
by rewrite !image_comp.
Qed.

Lemma gt0_mulpinfty (R : realDomainType) (x : \bar R) : (0 < x -> +oo * x = +oo)%E.
Proof.
move: x => [x|_|//]; last by rewrite mule_pinfty_pinfty.
by rewrite lte_fin => x0; rewrite muleC mulrinfty gtr0_sg// mul1e.
Qed.

Lemma lt0_mulpinfty (R : realDomainType) (x : \bar R) : (x < 0 -> +oo * x = -oo)%E.
Proof.
move: x => [x|//|_]; last by rewrite mule_pinfty_ninfty.
by rewrite lte_fin => x0; rewrite muleC mulrinfty ltr0_sg// mulN1e.
Qed.

Lemma gt0_mulninfty (R : realDomainType) (x : \bar R) : (0 < x -> -oo * x = -oo)%E.
Proof.
move: x => [x|_|//]; last by rewrite mule_ninfty_pinfty.
by rewrite lte_fin => x0; rewrite muleC mulrinfty gtr0_sg// mul1e.
Qed.

Lemma lt0_mulninfty (R : realDomainType) (x : \bar R) : (x < 0 -> -oo * x = +oo)%E.
Proof.
move: x => [x|//|_]; last by rewrite mule_ninfty_ninfty.
by rewrite lte_fin => x0; rewrite muleC mulrinfty ltr0_sg// mulN1e.
Qed.

(* NB: not used? *)
Lemma EFin_inj (R : numDomainType) : injective (@EFin R).
Proof. by move=> a b; case. Qed.

Lemma mask_second (T : Type) (b : T) a t :
  a :: t = mask (true :: false :: nseq (size t) true) [:: a, b & t].
Proof. by rewrite /= mask_true. Qed.

Lemma cons_head_beheadE {T : eqType} (s : seq T) def :
  s != [::] -> head def s :: behead s = s.
Proof. by case: s. Qed.

Section eseries.
Variables (R : numDomainType) (u_ : (\bar R)^nat).

Definition eseries : (\bar R)^nat := [sequence \sum_(0 <= k < n) u_ k]_n.

Lemma eseriesEnat : eseries = [sequence \sum_(0 <= k < n) u_ k]_n.
Proof. by []. Qed.

Lemma eseriesEord : eseries = [sequence \sum_(k < n) u_ k]_n.
Proof. by rewrite /eseries /=; under eq_fun do rewrite big_mkord. Qed.
End eseries.

(* NB: how useful? *)
Lemma lim_mkord (R : realFieldType) (f : (\bar R)^nat) :
  lim (fun n => \sum_(k < n) f k)%E = \sum_(k <oo) f k.
Proof.
rewrite (_ : (fun n => _) = (fun n => \sum_(0 <= k < n) f k)%E) // funeqE => k.
by rewrite big_mkord.
Qed.

Lemma sum_fset_nat_ub (R : realDomainType) (f : (\bar R)^nat) (F : {fset nat})
    (P : pred nat) n :
  (forall i, P i -> 0%E <= f i) ->
  (F `<=` @nat_of_ord _ @` fsets_ord xpredT n)%fset ->
  \sum_(i <- F | P i) f i <= \sum_(i < n | P i) f i.
Proof.
move=> f0 /fsubsetP F_fsets_ord; apply (@le_trans _ _
    (\sum_(i <- @nat_of_ord _ @` [fset j : 'I_n | P j]) f i)%fset); last first.
  rewrite big_imfset /=; last by move=> i j _ _; apply: ord_inj.
  by rewrite big_fset /= big_enum_cond.
apply (@le_trans _ _
    (\sum_(i <- [fset nat_of_ord j | j in 'I_n]%fset | P i) f i)); last first.
  rewrite big_imfset /=; last by move=> i j _ _; apply/ord_inj.
  rewrite big_fset big_enum_cond /= big_mkcond /=.
  rewrite big_imfset /=; last by move=> i j _ _; apply/ord_inj.
  by rewrite -big_mkcond /= big_enum_cond.
apply/(lee_sum_nneg_subfset _ (fun m _ => f0 m)) => t /F_fsets_ord.
by move=> /imfsetP[/= j _ ->{t}]; apply/imfsetP; exists j.
Qed.

Lemma lee_sum_lim (R : realType) (f : (\bar R)^nat) (F : {fset nat})
    (P : pred nat) :
  (forall i, P i -> 0%E <= f i) ->
  \sum_(i <- F | P i) f i <= \sum_(i <oo | P i) f i.
Proof.
move=> f0; have [->|F0] := eqVneq F fset0.
  by rewrite big_mkcond big_seq_fset0 ereal_nneg_series_lim_ge0.
have [n FnS] : exists n, (F `<=` @nat_of_ord _ @` fsets_ord xpredT n)%fset.
  move/fset_nat_maximum : F0 => [i [iF Fi]]; exists i.+1.
  apply/fsubsetP => j jF; apply/imfsetP => /=.
  by move/Fi : jF; rewrite -ltnS => jF; exists (Ordinal jF) => //; rewrite inE.
apply/(le_trans _ (ereal_nneg_series_lim_ge n f0)).
by rewrite big_mkord sum_fset_nat_ub.
Qed.

(* TODO: PR along subset_set1? *)
Lemma subset_set2 T (A : set T) a b : A `<=` [set a; b] ->
  A = set0 \/ A = [set a] \/ A = [set b] \/ A = [set a; b].
Proof.
have [<-|ab Aab] := pselect (a = b).
  by rewrite setUid => Aa; have [|] := subset_set1 Aa; tauto.
have [Aa|Aa] := pselect (A `<=` [set a]).
  by rewrite orA; left; exact/subset_set1.
have [Ab|Ab] := pselect (A `<=` [set b]).
  have [A0|{}Ab] := subset_set1 Ab; first by left.
  by rewrite orA; right; left.
rewrite 2!orA; right; rewrite eqEsubset; split => //.
move/nonsubset : Ab => -[y [Ay yb]].
have <- : y = a by apply: contrapT => ya; move/Aab : Ay => [|].
move/nonsubset : Aa => -[z [Az za]].
have <- : z = b by apply: contrapT => zb; move/Aab : Az => [|].
by move=> _ [|] ->.
Qed.

Lemma trivIset_bigcup2 T (A B : set T) :
  (A `&` B = set0) = trivIset setT (bigcup2 A B).
Proof.
apply/propext; split=> [AB0|/trivIsetP/(_ 0%N 1%N Logic.I Logic.I erefl)//].
apply/trivIsetP => -[/=|]; rewrite /bigcup2 /=.
- by move=> [//|[_ _ _ //|j _ _ _]]; rewrite setI0.
- move=> [[j _ _|]|i j _ _ _]; [by rewrite setIC| |by rewrite set0I].
  by move=> [//|j _ _ _]; rewrite setI0.
Qed.

Lemma sub_bigcup T I (F : I -> set T) (D : set T) (P : set I) :
  (forall i, P i -> F i `<=` D) -> \bigcup_(i in P) F i `<=` D.
Proof. by move=> FD t [n Pn Fnt]; apply: (FD n). Qed.

(******************************************************************************)
(*                        /lemmas waiting to be PRed                          *)
(******************************************************************************)

Reserved Notation "'s<|' D , G '|>'" (at level 40, G, D at next level).
Reserved Notation "'s<<' A '>>'".
Reserved Notation "'d<<' D '>>'".
Reserved Notation "[ 'sset' 'of' s ]"
  (at level 0, format "[ 'sset'  'of'  s ]").

(* mu_ext mu and mu coincide on measurable sets *)
Lemma measurable_mu_extE (R : realType) (T : ringOfSetsType)
    (mu : {measure set T -> \bar R}) X :
  measurable X -> [outer_measure of mu_ext mu] X = mu X.
Proof.
move=> mX; apply/eqP; rewrite eq_le; apply/andP; split.
  apply ereal_inf_lb; exists (fun n => if n is 0%N then X else set0).
    by split=> [[]// _|t Xt]; exists 0%N.
  apply/cvg_lim => //; rewrite -cvg_shiftS.
  rewrite (_ : [sequence _]_n = cst (mu X)); first exact: cvg_cst.
  by rewrite funeqE => n /=; rewrite big_nat_recl//= big1 ?adde0.
apply/lb_ereal_inf => x [A [mA XA] <-{x}].
have XUA : X = \bigcup_n (X `&` A n).
  rewrite predeqE => t; split => [Xt|[i _ []//]].
  by have [i _ Ait] := XA _ Xt; exists i; split.
apply: (@le_trans _ _ (\sum_(i <oo) mu (X `&` A i))).
  by rewrite {1}XUA; apply: generalized_Boole_inequality => //;
    [move=> i; exact: measurableI | rewrite -XUA].
apply lee_lim.
- by apply: is_cvg_ereal_nneg_series => n _; exact/measure_ge0/measurableI.
- by apply: is_cvg_ereal_nneg_series => n _; exact/measure_ge0.
- by near=> n; apply: lee_sum => i  _; apply: le_measure => //; rewrite ?inE//=;
    [exact: measurableI | apply: subIset; right].
Grab Existential Variables. all: end_near. Qed.

Lemma caratheodory_measurable_mu_ext (R : realType) (T : measurableType)
    (mu : {measure set T -> \bar R}) A :
  measurable A -> [outer_measure of mu_ext mu].-measurable A.
Proof.
move=> mA; apply le_caratheodory_measurable => // X /=.
suff le_mu : forall B, measurable B -> X `<=` B ->
    mu_ext mu (X `&` A) + mu_ext mu (X `&` ~` A) <= mu B.
  apply lb_ereal_inf => Y [B [mB XB] <-{Y}].
  have /(_ XB)/le_trans := le_mu _ (measurable_bigcup _ mB); apply.
  by apply: generalized_Boole_inequality => //; exact: measurable_bigcup.
move=> B mB BX; apply (@le_trans _ _ (mu (B `&` A) + mu (B `&` ~` A))).
  apply: lee_add.
  - apply/ereal_inf_lb; exists (fun n => if n is 0%N then B `&` A else set0).
      split=> [[|_]|t [Xt At]]; [exact: measurableI|by []|].
      by exists 0%N => //; split => //; exact: BX.
    set F := (X in lim_in _ X); have : ProperFilter F by typeclasses eauto.
    move/(@cvg_lim _ _ _); apply => //.
    rewrite -cvg_shiftS (_ : [sequence _]_n = cst (mu (B `&` A))) /=.
      exact: cvg_cst.
    by rewrite funeqE => n /=; rewrite big_mkord big_ord_recl /= big1 ?adde0.
  - apply ereal_inf_lb; exists (fun n => if n is 0%N then B `&` ~` A else set0).
      split=> [[|_ //]|t [Xt At]].
      + by rewrite -setDE; apply: measurableD.
      + by exists 0%N; split => //; exact: BX.
    apply/cvg_lim => //.
    rewrite -cvg_shiftS (_ : [sequence _]_n = cst (mu (B `&` ~` A))).
      exact: cvg_cst.
    by rewrite funeqE => n /=; rewrite big_mkord big_ord_recl /= big1 ?adde0.
rewrite -measureU.
- by rewrite -setIUr setUCr setIT.
- exact: measurableI.
- by rewrite -setDE; apply: measurableD.
- by rewrite setICA -(setIA B) setICr 2!setI0.
Qed.

Definition setI_closed T (G : set (set T)) :=
  forall A B, G A -> G B -> G (A `&` B).

Definition setU_closed T (G : set (set T)) :=
  forall A B, G A -> G B -> G (A `|` B).

Definition setC_closed T (G : set (set T)) := forall A, G A -> G (~` A).

Definition setD_closed T (G : set (set T)) :=
  forall A B, B `<=` A -> G A -> G B -> G (A `\` B).

Definition ndseq_closed T (G : set (set T)) :=
  forall F, nondecreasing_seq F -> (forall i, G (F i)) -> G (\bigcup_i (F i)).

Definition trivIset_closed T (G : set (set T)) :=
  forall F : (set T)^nat, trivIset setT F -> (forall n, G (F n)) ->
                    G (\bigcup_k F k).

Definition are_measurable_sets T D (G : set (set T)) :=
  [/\ G set0, (forall A, G A -> G (D `\` A)) &
     (forall A : (set T)^nat, (forall n, G (A n)) -> G (\bigcup_k A k))].

Section are_measurable_sets_lemmas.

Lemma are_measurable_sets_bigcap T (I : choiceType) (D : set T)
    (F : I -> set (set T)) (J : set I) :
  (forall n, J n -> are_measurable_sets D (F n)) ->
  are_measurable_sets D (\bigcap_(i in J) F i).
Proof.
move=> mG; split=> [i Ji|A AJ i Ji|H GH i Ji]; first by have [] := mG i.
- by have [_ mGiC _] := mG i Ji; exact/mGiC/AJ.
- by have [_ _ mGiU] := mG i Ji; apply mGiU => j; exact: GH.
Qed.

Lemma are_measurable_setsP T U (C : set (set T)) :
  (forall X, C X -> X `<=` U) ->
  are_measurable_sets U C <->
  [/\ C U, setD_closed C, ndseq_closed C & setI_closed C].
Proof.
move=> C_subU; split => [[C0 CD CU]|[DT DC DU DI]]; split.
- by rewrite -(setD0 U); apply: CD.
- move=> A B BA CA CB; rewrite (_ : A `\` B = U `\` ((U `\` A) `|` B)).
    by apply CD; rewrite -bigcup2E; apply: CU => -[|[|[|]]] //=; exact: CD.
  rewrite setDUr setDD [in RHS]setDE setIACA setIid -setDE setIidr//.
  by rewrite setDE; apply: subIset; left; apply: C_subU.
- by move=> F ndF DF; exact: CU.
- move=> A B DA DB; rewrite (_ : A `&` B = U `\` ((U `\` A) `|` (U `\` B))).
    by apply CD; rewrite -bigcup2E; apply: CU => -[|[|[|]]] //; exact: CD.
  rewrite setDUr !setDD setIACA setIid (@setIidr _ U)//.
  by apply: subIset; left; exact: C_subU.
- by rewrite -(setDv U); exact: DC.
- by move=> A CA; apply: DC => //; exact: C_subU.
- move=> F DF.
  rewrite [X in C X](_ : _ = \bigcup_i \big[setU/set0]_(j < i.+1) F j).
    apply: DU; first by move=> *; exact/subsetPset/subset_bigsetU.
    elim=> [|n ih]; first by rewrite big_ord_recr /= big_ord0 set0U; exact: DF.
    have CU : setU_closed C.
      move=> A B DA DB; rewrite (_ : A `|` B = U `\` ((U `\` A) `&` (U `\` B))).
        apply DC => //; last by apply: DI; apply: DC => //; exact: C_subU.
        by apply: subIset; left; apply: subIset; left.
      by rewrite setDIr// !setDD (setIidr (C_subU _ DA)) (setIidr (C_subU _ _)).
    by rewrite big_ord_recr; exact: CU.
  rewrite predeqE => x; split => [[n _ Fnx]|[n _]].
    by exists n => //; rewrite big_ord_recr /=; right.
  by rewrite -bigcup_mkord => -[m /=]; rewrite ltnS => _ Fmx; exists m.
Qed.

Lemma are_measurable_sets_measurable (T : measurableType) :
  are_measurable_sets setT (@measurable T).
Proof. by split=> // [A|]; [exact: measurableD|exact: measurable_bigcup]. Qed.

End are_measurable_sets_lemmas.

Definition gen_class T (G : set (set T)) (P : set (set T) -> Prop) :=
  \bigcap_(A in [set M | P M /\ G `<=` M]) A.

Lemma subset_gen_class T (G : set (set T)) P : G `<=` gen_class G P.
Proof. by move=> A GA C /= [PC]; apply. Qed.

Lemma gen_class_smallest T (G : set (set T)) (P : set (set T) -> Prop) C :
  G `<=` C -> P C -> gen_class G P `<=` C.
Proof. by move=> GC PC A; apply. Qed.

Section generated_sigma_algebra.
Variable T : Type.
Implicit Types M G : set (set T).

Inductive g_salgebra (D : set T) G : set (set T) :=
| g_salgebra_self : G `<=` s<| D, G |>
| g_salgebra_set0 : s<| D, G |> set0
| g_salgebra_setC : forall A, s<| D, G |> A -> s<| D, G |> (D `\` A)
| g_salgebra_bigcup : forall A : (set T)^nat, (forall i, s<| D, G |> (A i)) ->
    s<| D, G |> (\bigcup_i (A i))
where "'s<|' D , G '|>'" := (g_salgebra D G).

Lemma g_salgebraE D G : s<| D, G |> = gen_class G (are_measurable_sets D).
Proof.
rewrite predeqE => A; split.
  by elim=>
  [ {}A ? N [?] | {}A [[]]| {}A ? MA N [[? NC ?] ?] | {}A ? MA N [[? ? NI] ?]];
  [exact | by [] | by apply/NC; apply: MA | by apply NI => i; exact: (MA i)].
apply; split; [split|]; [exact: g_salgebra_set0 | exact: g_salgebra_setC |
  exact: g_salgebra_bigcup | by move=> B MB; apply g_salgebra_self].
Qed.

Lemma are_measurable_sets_g_salgebra D G : are_measurable_sets D (s<| D, G |>).
Proof. by rewrite g_salgebraE; apply: are_measurable_sets_bigcap => ? []. Qed.

Lemma g_salgebra_smallest D G M : G `<=` M -> are_measurable_sets D M ->
  s<| D, G |> `<=` M.
Proof. by move=> GM DM; rewrite g_salgebraE; apply: gen_class_smallest. Qed.

Lemma subset_g_salgebra D M G : M `<=` G -> s<| D, M |> `<=` s<| D, G |>.
Proof.
move=> MG; apply: g_salgebra_smallest.
  by move=> C AC; exact/g_salgebra_self/MG.
exact: are_measurable_sets_g_salgebra.
Qed.

End generated_sigma_algebra.
Notation "'s<|' D , G '|>'" := (g_salgebra D G).
Notation "'s<<' G '>>'" := (g_salgebra setT G).

Definition g_measurable (T : Type) (G : set (set T)) := T.

Section g_salgebra_instance.
Variables (T : Type) (G : set (set T)).

Lemma g_salgebra_on_setC_setT (A : set T) : s<< G >> A -> s<< G >> (~` A).
Proof. by move=> sGA; rewrite -setTD; exact: g_salgebra_setC. Qed.

HB.instance Definition g_salgebra_mixin :=
  @isMeasurable.Build (g_measurable G) (g_salgebra setT G)
    (@g_salgebra_set0 _ setT G) (@g_salgebra_on_setC_setT)
    (@g_salgebra_bigcup _ setT G).

Definition g_measurableType := [the measurableType of g_measurable G].

End g_salgebra_instance.

Lemma measurable_g_measurableTypeE (T : Type) (G : set (set T)) :
  are_measurable_sets setT G -> @measurable (g_measurableType G) = G.
Proof.
move=> mM; rewrite eqEsubset; split; first exact: g_salgebra_smallest.
by move=> A MA; apply g_salgebra_self.
Qed.


(* TODO: move to measure.v *)
Section measurability.

Definition preimage_class (aT rT : Type) (D : set aT) (f : aT -> rT)
    (G : set (set rT)) : set (set aT) :=
  [set f @^-1` B `&` D | B in G].

(* f1 is measurable on the sigma-algebra generated by itself *)
Lemma preimage_class_measurable_fun (aT : Type) (rT : measurableType)
  (D : set aT) (f : aT -> rT) :
  @measurable_fun (g_measurableType (preimage_class D f measurable))
    rT D f.
Proof. by move=> A mA; apply: g_salgebra_self; exists A. Qed.

Lemma are_measurable_sets_preimage_class (aT rT : Type) (G : set (set rT))
    (D : set aT) (f : aT -> rT) :
  are_measurable_sets setT G -> are_measurable_sets D (preimage_class D f G).
Proof.
case=> h0 hC hU; split; first by exists set0 => //; rewrite preimage_set0 set0I.
- move=> A; rewrite /preimage_class /= => -[B mB <-{A}].
  exists (~` B); first by rewrite -setTD; exact: hC.
  rewrite predeqE => x; split=> [[Bfx Dx]|[Dx]]; first by split => // -[] /Bfx.
  by move=> /not_andP[].
- move=> F; rewrite /preimage_class /= => mF.
  have {}mF : forall n, exists x, G x /\ f @^-1` x `&` D = F n.
    by move=> n; have := mF n => -[B mB <-]; exists B.
  have [F' mF'] := @choice _ _ (fun x y => G y /\ f @^-1` y `&` D = F x) mF.
  exists (\bigcup_k (F' k)); first by apply: hU => n; exact: (mF' n).1.
  rewrite preimage_bigcup setI_bigcupl; apply eq_bigcupr => i _.
  exact: (mF' i).2.
Qed.

Definition image_class (aT rT : Type) (D : set aT) (f : aT -> rT)
    (G : set (set aT)) : set (set rT) :=
  [set B : set rT | G (f @^-1` B `&` D)].

Lemma are_measurable_sets_image_class (aT rT : Type) (D : set aT) (f : aT -> rT)
    (G : set (set aT)) :
  are_measurable_sets D G -> are_measurable_sets setT (image_class D f G).
Proof.
move=> [G0 GC GU]; split; rewrite /image_class.
- by rewrite /= preimage_set0 set0I.
- move=> A /= GfAD; rewrite setTD -preimage_setC setIC -setDE.
  rewrite (_ : _ `\` _ = D `\` (f @^-1` A `&` D)); first exact: GC.
  rewrite predeqE => x; split=> [[Dx fAx]|[Dx fADx]].
    by split => // -[] /fAx.
  by split => //; exact: contra_not fADx.
- by move=> F /= mF; rewrite preimage_bigcup setI_bigcupl; exact: GU.
Qed.

Lemma transfer (aT rT : Type) (D : set aT) (f : aT -> rT) (G' : set (set rT)) :
  s<| D, preimage_class D f G' |> =
  preimage_class D f (@measurable (g_measurableType G')).
Proof.
rewrite eqEsubset; split.
  have mG : are_measurable_sets D
      (preimage_class D f (@measurable (g_measurableType G'))).
    exact/are_measurable_sets_preimage_class/are_measurable_sets_measurable.
  have subset_preimage : preimage_class D f G' `<=`
                         preimage_class D f (@measurable (g_measurableType G')).
    by move=> A [B CCB <-{A}]; exists B => //; apply g_salgebra_self.
  exact: g_salgebra_smallest.
have G'pre A' : G' A' -> (preimage_class D f G') (f @^-1` A' `&` D).
  by move=> ?; exists A'.
pose I : set (set aT) := s<| D, preimage_class D f G' |>.
have G'sfun : G' `<=` image_class D f I.
  by move=> A' /G'pre[B G'B h]; apply: g_salgebra_self; exists B.
have sG'sfun : s<< G' >> `<=` image_class D f I.
  apply: g_salgebra_smallest => //; apply: are_measurable_sets_image_class.
  exact: are_measurable_sets_g_salgebra.
by move=> _ [B mB <-]; exact: sG'sfun.
Qed.

Lemma measurability (aT rT : measurableType) (D : set aT) (f : aT -> rT)
    (G' : set (set rT)) : measurable D ->
  @measurable rT = s<< G' >> -> preimage_class D f G' `<=` @measurable aT ->
  measurable_fun D f.
Proof.
move=> mD sG_rT fG_aT.
suff h : preimage_class D f (@measurable rT) `<=` @measurable aT.
  by move=> A mA; apply: h; exists A.
have -> : preimage_class D f (@measurable rT) =
         s<| D , (preimage_class D f G')|>.
  by rewrite [in LHS]sG_rT [in RHS]transfer.
apply: g_salgebra_smallest => //; split => //.
- by move=> A mA; exact: measurableD.
- by move=> F h; exact: measurable_bigcup.
Qed.

End measurability.

Definition is_monotone_class {T} E (G : set (set T)) :=
  [/\ (forall A, G A -> A `<=` E), G E, setD_closed G & ndseq_closed G].

Lemma is_monotone_class_g_salgebra T (G : set (set T)) (D : set T) :
  (forall X, s<| D, G |> X -> X `<=` D) -> G D ->
  is_monotone_class D (s<| D, G |>).
Proof.
move=> sDGD GD; split; [by move=> *; exact: sDGD|exact: g_salgebra_self| |].
- move=> A B BA sCA sCB; rewrite (_ : _ `\` _ = D `\` ((D `\` A) `|` B)).
    apply: g_salgebra_setC.
    rewrite -bigcup2E; apply: g_salgebra_bigcup => -[|[|[|]]] //=.
    + exact: g_salgebra_setC.
    + exact: g_salgebra_set0.
    + by move=> ?; exact: g_salgebra_set0.
  rewrite setDUr setDD [in RHS]setDE setIACA setIid -setDE setIidr//.
  by rewrite setDE; apply: subIset; left; apply: sDGD.
- by move=> *; exact: g_salgebra_bigcup.
Qed.

Section smallest_monotone_classE.
Variables (T : Type) (G : set (set T)) (setIG : setI_closed G).
Variables (D : set T) (GD : G D).
Variables (H : set (set T)) (monoH : is_monotone_class D H) (GH : G `<=` H).

Lemma smallest_monotone_classE : (forall X, s<| D, G |> X -> X `<=` D) ->
  (forall E, is_monotone_class D E -> G `<=` E -> H `<=` E) ->
  H = s<| D, G |>.
Proof.
move=> sDGD smallestH; rewrite eqEsubset; split.
  apply: (smallestH _ _ (@g_salgebra_self _ D G)).
  exact: is_monotone_class_g_salgebra.
suff: setI_closed H.
  move=> IH; apply: g_salgebra_smallest => //.
  by apply/are_measurable_setsP; by case: monoH.
pose H_ A := [set X | H X /\ H (X `&` A)].
have setDH_ A : setD_closed (H_ A).
  move=> X Y XY [HX HXA] [HY HYA]; case: monoH => h _ setDH _; split.
    exact: setDH.
  rewrite (_ : _ `&` _ = (X `&` A) `\` (Y `&` A)); last first.
    rewrite predeqE => x; split=> [[[? ?] ?]|]; first by split => // -[].
    by move=> [[? ?] YAx]; split => //; split => //; apply: contra_not YAx.
  by apply setDH => //; exact: setSI.
have ndH_ A : ndseq_closed (H_ A).
  move=> F ndF H_AF; split.
    by case: monoH => h _ _; apply => // => n; have [] := H_AF n.
  rewrite setI_bigcupl; case: monoH => h _ _; apply => //.
    by move=> m n mn; apply/subsetPset; apply: setSI; apply/subsetPset/ndF.
  by move=> n; have [] := H_AF n.
have GGH_ X : G X -> G `<=` H_ X.
  by move=> *; split; [exact: GH | apply: GH; exact: setIG].
have GHH_ X : G X -> H `<=` H_ X.
  move=> CX; apply: smallestH; [split => //; last exact: GGH_|exact: GGH_].
  by move=> ? [? ?]; case: monoH => + _ _ _; exact.
have HGH_ X : H X -> G `<=` H_ X.
  by move=> *; split; [exact: GH|rewrite setIC; apply GHH_].
have HHH_ X : H X -> H `<=` H_ X.
  move=> HX; apply: (smallestH _ _ (HGH_ _ HX)); split=> //.
  - by move=> ? [? ?]; case: monoH => + _ _ _; exact.
  - exact: HGH_.
by move=> *; apply HHH_.
Qed.

End smallest_monotone_classE.

Section monotone_class_subset.
Variables (T : Type) (G : set (set T)) (setIG : setI_closed G).
Variables (D : set T) (GD : G D).
Variables (H : set (set T)) (monoH : is_monotone_class D H) (GH : G `<=` H).

Lemma monotone_class_subset : (forall X, (s<| D, G |>) X -> X `<=` D) ->
  s<| D, G |> `<=` H.
Proof.
move=> sDGD; set M := gen_class G (@is_monotone_class T D).
rewrite -(@smallest_monotone_classE _ _ setIG _ _ M) //.
- exact: gen_class_smallest.
- split => [A MA | E [monoE] | A B BA MA MB E [[EsubD ED setDE ndE] GE] |].
  + by case: monoH => + _ _ _; apply; exact: MA.
  + exact.
  + by apply setDE => //; [exact: MA|exact: MB].
  + by move=> F ndF MF E [[EsubD ED setDE ndE] CE]; apply ndE=> // n; exact: MF.
- exact: subset_gen_class.
- by move=> ? ? ?; exact: gen_class_smallest.
Qed.

End monotone_class_subset.

Section g_salgebra_measure_unique_trace.
Variables (R : realType) (T : measurableType) (G : set (set T)).
Variables (D : set T) (mD : measurable D).
Let H := [set X | G X /\ X `<=` D] (* "trace" of G wrt D *).
Hypotheses (Hm : H `<=` measurable) (setIH : setI_closed H) (HD : H D).
Variables m1 m2 : {measure set T -> \bar R}.
Hypotheses (m1m2 : forall A, H A -> m1 A = m2 A) (m1oo : (m1 D < +oo)%E).

Lemma g_salgebra_measure_unique_trace :
  (forall X, (s<| D, H |>) X -> X `<=` D) -> forall X, s<| D, H |> X ->
  m1 X = m2 X.
Proof.
move=> sDHD; set E := [set A | [/\ measurable A, m1 A = m2 A & A `<=` D] ].
have HE : H `<=` E.
  by move=> X HX; rewrite /E /=; split; [exact: Hm|exact: m1m2|case: HX].
have setDE : setD_closed E.
  move=> A B BA [mA m1m2A AD] [mB m1m2B BD]; split; first exact: measurableD.
  - rewrite measureD//; last first.
      by rewrite (le_lt_trans _ m1oo)//; apply: le_measure => //=; rewrite inE.
    rewrite setIidr// m1m2A m1m2B measureD// ?setIidr//.
    by rewrite (le_lt_trans _ m1oo)// -m1m2A; apply: le_measure => //;
      rewrite inE.
  - by rewrite setDE; apply: subIset; left.
have ndE : ndseq_closed E.
  move=> A ndA EA; split; have mA n : measurable (A n) by have [] := EA n.
  - exact: measurable_bigcup.
  - transitivity (lim (m1 \o A)).
      by apply/esym/cvg_lim=> //; exact/(cvg_mu_inc mA _ ndA)/measurable_bigcup.
    transitivity (lim (m2 \o A)).
      by congr (lim _); rewrite funeqE => n; have [] := EA n.
    by apply/cvg_lim => //; exact/(cvg_mu_inc mA _ ndA)/measurable_bigcup.
  - by apply: sub_bigcup => n; have [] := EA n.
have sDHE : s<| D, H |> `<=` E.
  by apply: monotone_class_subset => //; split => //; [move=> A []|exact/HE].
by move=> X /sDHE[mX ?] _.
Qed.

End g_salgebra_measure_unique_trace.

Section g_salgebra_measure_unique.
Variables (R : realType) (T : measurableType) (G : set (set T)).
Hypothesis (Gm : G `<=` measurable).
Variable g : (set T)^nat.
Hypotheses (Gg : forall i, G (g i)) (nd_g : nondecreasing_seq g).
Hypothesis g_cover : \bigcup_k (g k) = setT.
Variables m1 m2 : {measure set T -> \bar R}.

Lemma g_salgebra_measure_unique_cover :
  (forall n A, s<< G >> A -> m1 (g n `&` A) = m2 (g n `&` A)) ->
  (forall A, s<< G >> A -> m1 A = m2 A).
Proof.
move=> sGm1m2 A sGA.
have -> : A = \bigcup_n (g n `&` A) by rewrite -setI_bigcupl g_cover setTI.
have sGm : s<< G >> `<=` measurable.
  by apply: g_salgebra_smallest => //; exact: are_measurable_sets_measurable.
transitivity (lim (fun n => m1 (g n `&` A))).
  apply/esym/cvg_lim => //; apply: cvg_mu_inc => //.
  - by move=> n; apply: measurableI; [exact/Gm|exact/sGm].
  - by apply: measurable_bigcup => k; apply: measurableI; [exact/Gm|exact/sGm].
  - by move=> ? ? ?; apply/subsetPset; apply: setSI; exact/subsetPset/nd_g.
transitivity (lim (fun n => m2 (g n `&` A))).
  by congr (lim _); rewrite funeqE => x; apply: sGm1m2 => //; exact/sGm.
apply/cvg_lim => //; apply: cvg_mu_inc => //.
- by move=> k; apply: measurableI => //; [exact/Gm|exact/sGm].
- by apply: measurable_bigcup => k; apply: measurableI; [exact/Gm|exact/sGm].
- by move=> a b ab; apply/subsetPset; apply: setSI; exact/subsetPset/nd_g.
Qed.

Hypothesis setIG : setI_closed G.
Hypothesis m1m2 : forall A, G A -> m1 A = m2 A.
Hypothesis m1goo : forall k, (m1 (g k) < +oo)%E.

Lemma g_salgebra_measure_unique : forall E, s<< G >> E -> m1 E = m2 E.
Proof.
pose G_ n := [set X | G X /\ X `<=` g n]. (* "trace" *)
have G_E n : G_ n = [set g n `&` C | C in G].
  rewrite eqEsubset; split.
    by move=> X [GX Xgn] /=; exists X => //; rewrite setIidr.
  by rewrite /G_ => X [Y GY <-{X}]; split; [exact: setIG|apply: subIset; left].
have gIsGE n : [set g n `&` A | A in s<< G >>] =
               s<| g n, preimage_class (g n) id G |>.
  rewrite transfer eqEsubset; split.
    by move=> _ /= [Y sGY <-]; exists Y => //; rewrite preimage_id setIC.
  by move=> _ [Y mY <-] /=; exists Y => //; rewrite preimage_id setIC.
have preimg_gGE n : preimage_class (g n) id G = G_ n.
  rewrite eqEsubset; split => [_ [Y GY <-]|].
    by rewrite preimage_id G_E /=; exists Y => //; rewrite setIC.
  by move=> X [GX Xgn]; exists X => //; rewrite preimage_id setIidl.
apply: g_salgebra_measure_unique_cover => //.
move=> n A sGA; apply: (@g_salgebra_measure_unique_trace _ _ G (g n)) => //.
- exact: Gm.
- by move=> ? [? _]; exact/Gm.
- by move=> ? ? [? ?] [? ?]; split; [exact: setIG|apply: subIset; tauto].
- by split.
- by move=> ? [? ?]; exact: m1m2.
- move=> X; rewrite -/(G_ n) -preimg_gGE -gIsGE.
  by case=> B sGB <-{X}; apply: subIset; left.
- by rewrite -/(G_ n) -preimg_gGE -gIsGE; exists A.
Qed.

End g_salgebra_measure_unique.

Section dynkin.
Variable T : Type.
Implicit Types G D : set (set T).

Definition dynkin G := [/\ G setT, setC_closed G & trivIset_closed G].

Lemma dynkinT G : dynkin G -> G setT. Proof. by case. Qed.

Lemma dynkinC G : dynkin G -> setC_closed G. Proof. by case. Qed.

Lemma dynkinU G : dynkin G -> (forall F : (set T)^nat, trivIset setT F ->
  (forall n, G (F n)) -> G (\bigcup_k F k)). Proof. by case. Qed.

Definition g_dynkin G := gen_class G dynkin.

End dynkin.
Notation "'d<<' D '>>'" := (g_dynkin D).

Section dynkin_lemmas.
Variable T : Type.
Implicit Types D G : set (set T).

Lemma dynkin_monotone G : dynkin G <-> is_monotone_class setT G.
Proof.
split => [[GT setCG trG]|[_ GT setDG ndG]]; split => //.
- move=> A B BA GA GB; rewrite setDE -(setCK (_ `&` _)) setCI; apply setCG.
  rewrite setCK -bigcup2E; apply: trG.
  + by rewrite -trivIset_bigcup2 setIC; apply subsets_disjoint.
  + by move=> [|[//|n]]; [exact: setCG|rewrite /bigcup2 -setCT; apply: setCG].
- move=> F ndF GF; rewrite eq_bigcup_seqD; apply trG.
    exact: trivIset_seqD.
  move=> [/=|n]; first exact: GF.
  rewrite /seqD setDE -(setCK (_ `&` _)) setCI; apply setCG.
  rewrite setCK -bigcup2E; apply trG.
  + rewrite -trivIset_bigcup2 setIC; apply subsets_disjoint.
    exact/subsetPset/ndF/ltnW.
  + move=> [|[|]]; rewrite /bigcup2 /=; [exact/setCG/GF|exact/GF|].
    by move=> _; rewrite -setCT; apply: setCG.
- by move=> A B; rewrite -setTD; apply: setDG.
- move=> F tF GF; pose A i := \big[setU/set0]_(k < i.+1) F k.
  rewrite (_ : bigcup _ _ = \bigcup_i A i); last first.
    rewrite predeqE => t; split => [[n _ Fn]|[n _]].
      by exists n => //; rewrite /A -bigcup_mkord; exists n=> //=; rewrite ltnS.
    by rewrite /A -bigcup_mkord => -[m /=]; rewrite ltnS => mn Fmt; exists m.
  apply ndG; first by move=> a b ab; exact/subsetPset/subset_bigsetU.
  elim=> /= => [|n ih].
    by rewrite /A big_ord_recr /= big_ord0 set0U; exact: GF.
  rewrite /A /= big_ord_recr /= -/(A n).
  rewrite (_ : _ `|` _ = ~` (~` A n `\` F n.+1)); last first.
    by rewrite setDE setCI !setCK.
  rewrite -setTD; apply setDG => //; apply setDG => //; last first.
    by rewrite -setTD; apply: setDG.
  apply/disjoints_subset; rewrite setIC.
  by apply: (@trivIset_bigsetUI _ predT) => //; rewrite /predT /= trueE.
Qed.

Lemma dynkin_g_dynkin G : dynkin (d<< G >>).
Proof.
split=> [D /= [] []//| | ].
- by move=> Y sGY D /= [dD GD]; exact/(dynkinC dD)/(sGY D).
- by move=> F tF gGF D /= [dD GD]; apply dD => // k; exact: gGF.
Qed.

Lemma are_measurable_sets_dynkin G : are_measurable_sets setT G -> dynkin G.
Proof.
case=> ? DC DU; split => [| |? ? ?]; last exact: DU.
- by rewrite -setC0 -setTD; exact: DC.
- by move=> A GA; rewrite -setTD; apply: DC.
Qed.

Lemma dynkin_setI_bigsetI G (F : (set T)^nat) : dynkin G -> setI_closed G ->
  (forall n, G (F n)) -> forall n, G (\big[setI/setT]_(i < n) F i).
Proof.
move=> dG GI GF; elim => [|n ih]; last by rewrite big_ord_recr /=; apply: GI.
by rewrite big_ord0; exact: (dynkinT dG).
Qed.

Lemma dynkin_setI_are_measurable_sets G : dynkin G -> setI_closed G ->
  are_measurable_sets setT G.
Proof.
move=> dG GI; split => [|//|F DF].
- by rewrite -setCT; exact/(dynkinC dG)/(dynkinT dG).
- by move=> A GA; rewrite setTD; exact: (dynkinC dG).
- rewrite seqDU_bigcup_eq; apply/(dynkinU dG) => //; first exact/trivIset_seqDU.
  move=> n; rewrite /seqDU setDE; apply GI => //.
  rewrite -bigcup_mkord setC_bigcup bigcap_mkord.
  by apply: (@dynkin_setI_bigsetI _ (fun x => ~` F x)) => // ?; exact/(dynkinC dG).
Qed.

Lemma setI_closed_gdynkin_salgebra G : setI_closed G -> d<< G >> = s<< G >>.
Proof.
move=> GI; rewrite eqEsubset; split.
  apply: (gen_class_smallest (@g_salgebra_self _ _ _)).
  by apply/are_measurable_sets_dynkin; exact/are_measurable_sets_g_salgebra.
pose delta (D : set T) := [set E | d<< G >> (E `&` D)].
have ddelta (D : set T) : d<< G >> D -> dynkin (delta D).
  move=> dGD; split; first by rewrite /delta /= setTI.
  - move=> E DE; rewrite /delta /=.
    have -> : (~` E) `&` D = ~` ((E `&` D) `|` (~` D)).
      by rewrite -[LHS]setU0 -(setICl D) -setIUl -setCI -{2}(setCK D) -setCU.
    have : d<< G >> ((E `&` D) `|` ~` D).
      rewrite -bigcup2E => S [dS GS]; apply (dynkinU dS).
        move=> [|[|i]] [|[|j]] => // _ _; rewrite /bigcup2 /=.
        + by rewrite -setIA setICr setI0 => /set0P; rewrite eqxx.
        + by rewrite setI0 => /set0P; rewrite eqxx.
        + by rewrite setICA setICl setI0 => /set0P; rewrite eqxx.
        + by rewrite setI0 => /set0P; rewrite eqxx.
        + by rewrite set0I => /set0P; rewrite eqxx.
        + by rewrite set0I => /set0P; rewrite eqxx.
        + by rewrite set0I => /set0P; rewrite eqxx.
      move=> [|[|n]] //; rewrite /bigcup2 /=; [exact: DE| |].
      + suff: d<< G >> (~` D) by exact.
        by move=> F [dF GF]; apply (dynkinC dF) => //; exact: dGD.
      + by rewrite -setCT; apply/(dynkinC dS)/(dynkinT dS).
    by move=> dGEDD S /= [+ GS] => dS; apply/(dynkinC dS); exact: dGEDD.
  - move=> F tF deltaDF; rewrite /delta /= => S /= [dS GS].
    rewrite setI_bigcupl; apply (dynkinU dS) => //.
      by under eq_fun do rewrite setIC; exact: trivIset_setI.
    by move=> n; exact: deltaDF.
have GdG : G `<=` d<< G >> by move=> ? ? ? [_]; apply.
have Gdelta A : G A -> G `<=` delta A.
  by move=> ? ? ?; rewrite /delta /= => ? [?]; apply; exact/GI.
have GdGdelta A : G A -> d<< G >> `<=` delta A.
  move=> ?; apply: gen_class_smallest => //; first exact: Gdelta.
  by apply/ddelta; exact: GdG.
have dGGI A B : d<< G >> A -> G B -> d<< G >> (A `&` B).
  by move=> ? ?; apply: GdGdelta.
have dGGdelta A : d<< G >> A -> G `<=` delta A.
  by move=> ? ? ?; rewrite /delta /= setIC; exact: dGGI.
have dGdGdelta A : d<< G >> A -> d<< G >> `<=` delta A.
  by move=> ?; exact: gen_class_smallest (dGGdelta _ _) (ddelta _ _).
have dGdGdG A B : d<< G >> A -> d<< G >> B -> d<< G >> (A `&` B).
  by move=> ? ?; exact: dGdGdelta.
apply: g_salgebra_smallest => //; apply: dynkin_setI_are_measurable_sets => //.
exact: dynkin_g_dynkin.
Qed.

End dynkin_lemmas.

Section measure_unique.
Variables (R : realType) (T : measurableType) (G : set (set T)).
Hypotheses (mG : measurable = s<< G >>) (setIG : setI_closed G).
Variable g : (set T)^nat.
Hypotheses (Gg : forall i, G (g i)) (nd_g : nondecreasing_seq g).
Hypothesis g_cover : \bigcup_k (g k) = setT.
Variables m1 m2 : {measure set T -> \bar R}.
Hypothesis m1m2 : forall A, G A -> m1 A = m2 A.
Hypothesis m1goo : forall k, (m1 (g k) < +oo)%E.

Lemma measure_unique : forall E, measurable E -> m1 E = m2 E.
Proof.
(*NB: alternative proof
move=> E mA.
apply: (@g_salgebra_measure_unique _ _ G) => //.
- rewrite mG.
  exact: g_salgebra_self.
- by rewrite -mG.*)
pose D n := [set X | measurable X /\ m1 (g n `&` X) = m2 (g n `&` X)].
have dynkinD n : dynkin (D n).
  split.
  - by rewrite /D /=; split => //; rewrite setIT m1m2.
  - move=> X [SX mm'X]; split; first exact: measurableC.
    rewrite -setDE measureD//; last by rewrite mG; exact/g_salgebra_self/Gg.
    by rewrite m1m2 // mm'X -measureD // -?m1m2// mG; exact/g_salgebra_self/Gg.
  - move=> F tF DF; rewrite /D /=; split.
      by apply: measurable_bigcup => // i;  exact: (DF i).1.
    rewrite setI_bigcupr.
    transitivity (\sum_(i <oo) m1 (g n `&` F i)%E).
      rewrite -lim_mkord; apply/esym/cvg_lim => //=.
      apply: measure_sigma_additive; last exact: trivIset_setI.
      move=> i; apply: measurableI => //; last exact: (DF i).1.
      by rewrite mG; exact/g_salgebra_self/Gg.
    transitivity (\sum_(i <oo) m2 (g n `&` F i)).
      by apply: eq_ereal_pseries => // k; have := (DF k).2.
    rewrite -lim_mkord; apply/cvg_lim => //.
    apply: measure_sigma_additive; last exact: trivIset_setI.
    move=> i; apply: measurableI => //; last exact: (DF i).1.
    by rewrite mG; exact/g_salgebra_self/Gg.
have GsubD n : G `<=` D n.
  move=> S GS; rewrite /D /=; split.
  - by rewrite mG; exact/g_salgebra_self.
  - by rewrite m1m2//; exact: setIG.
have mDE n : measurable = D n.
  rewrite eqEsubset; split=> [| x []//].
  by rewrite mG -setI_closed_gdynkin_salgebra//; exact: gen_class_smallest.
have m1m2g n A : measurable A -> m1 (g n `&` A) = m2 (g n `&` A).
  by rewrite (mDE n) /D /= => -[SE].
rewrite mG; apply: (@g_salgebra_measure_unique_cover _ _ _ _ g) => //.
- by rewrite mG; apply: g_salgebra_self.
- by move=> A n sGA; apply: m1m2g => //; rewrite mG.
Qed.

End measure_unique.

Section Hahn_extension.
Variables (R : realType) (T : ringOfSetsType) (mu : {measure set T -> \bar R}).

Let mstar : {outer_measure set T -> \bar R} := [outer_measure of mu_ext mu].
Let M : measurableType := [the measurableType of caratheodory_type mstar].

Lemma subset_g_salgebra_caratheodory : s<< @measurable T >> `<=` @measurable M.
Proof.
apply: g_salgebra_smallest; last first.
  split => //; [by move=> X mX; rewrite setTD; exact: measurableC |
    by move=> u_ mu_; exact: measurable_bigcup].
move=> A mA; apply le_caratheodory_measurable => // X.
apply lb_ereal_inf => _ [B [mB XB] <-].
set BA := eseries (fun n => mu (B n `&` A)).
set BNA := eseries (fun n => mu (B n `&` ~` A)).
apply (@le_trans _ _ (lim BA + lim BNA)); [apply: lee_add|].
  - rewrite (_ : BA = eseries (fun n => mstar (B n `&` A))); last first.
      rewrite funeqE => n; apply: eq_bigr => i _.
      by rewrite /mstar /= measurable_mu_extE //; exact: measurableI.
    apply (@le_trans _ _ (mstar (\bigcup_k (B k `&` A)))).
      by apply le_mu_ext; rewrite -setI_bigcupl; apply setISS.
    exact: outer_measure_sigma_subadditive.
  - rewrite (_ : BNA = eseries (fun n => mstar (B n `\` A))); last first.
      rewrite funeqE => n; apply eq_bigr => i _.
      by rewrite /mstar /= measurable_mu_extE //; exact: measurableD.
    apply (@le_trans _ _ (mstar (\bigcup_k (B k `\` A)))).
      by apply le_mu_ext; rewrite -setI_bigcupl; apply setISS.
    exact: outer_measure_sigma_subadditive.
have ? : cvg BNA.
  apply/is_cvg_ereal_nneg_series => n _.
  by rewrite -setDE; apply: measure_ge0 => //; apply: measurableD.
have ? : cvg BA.
  apply/is_cvg_ereal_nneg_series => n _.
  by apply: measure_ge0 => //; apply: measurableI.
have ? : cvg (eseries (mu \o B)).
  by apply/is_cvg_ereal_nneg_series => n _; exact: measure_ge0.
have [def|] := boolP (adde_def (lim BA) (lim BNA)); last first.
  rewrite /adde_def negb_and !negbK=> /orP[/andP[BAoo BNAoo]|/andP[BAoo BNAoo]].
  - suff -> : lim (eseries (mu \o B)) = +oo by rewrite lee_pinfty.
    apply/eqP; rewrite -lee_pinfty_eq -(eqP BAoo); apply/lee_lim => //.
    near=> n; apply: lee_sum => m _; apply: le_measure; rewrite /mkset; by
      [rewrite inE; exact: measurableI | rewrite inE | apply: subIset; left].
  - suff -> : lim (eseries (mu \o B)) = +oo by rewrite lee_pinfty.
    apply/eqP; rewrite -lee_pinfty_eq -(eqP BNAoo); apply/lee_lim => //.
    near=> n; apply: lee_sum => m _; rewrite -setDE; apply: le_measure;
      rewrite /mkset; by [rewrite inE; exact: measurableD |
                          rewrite inE | apply: subIset; left].
rewrite -ereal_limD // (_ : (fun _ => _) =
    eseries (fun i => mu (B i `&` A) + mu (B i `&` ~` A))); last first.
  by rewrite funeqE => n; rewrite -big_split /=; apply eq_bigr.
apply/lee_lim => //.
  apply/is_cvg_ereal_nneg_series => // n _; apply/adde_ge0.
  by apply: measure_ge0 => //; apply: measurableI.
  by rewrite -setDE; apply: measure_ge0; apply: measurableD.
near=> n; apply: lee_sum => i _; rewrite -measure_semi_additive2.
- apply: le_measure; rewrite /mkset; [|
    by rewrite inE | by rewrite -setIUr setUCr setIT].
  rewrite inE.
  by apply: measurableU; [exact: measurableI |
                          rewrite -setDE; exact: measurableD].
- exact: measurableI.
- by rewrite -setDE; exact: measurableD.
- apply: measurableU; [exact: measurableI | rewrite -setDE; exact: measurableD].
- by rewrite setIACA setICr setI0.
Grab Existential Variables. all: end_near. Qed.

Let I : measurableType := g_measurableType (@measurable T).

Let Hahn_ext' : set I -> \bar R := mu_ext mu.

Local Lemma Hahn_ext'0 : Hahn_ext' set0 = 0.
Proof. exact: mu_ext0. Qed.

Local Lemma Hahn_ext'_ge0 (A : set I) : measurable A -> 0 <= Hahn_ext' A.
Proof. by move=> mA; exact: mu_ext_ge0. Qed.

Local Lemma Hahn_ext'_sigma_additive : semi_sigma_additive Hahn_ext'.
Proof.
move=> F mF tF mUF; rewrite /Hahn_ext'.
apply: (@caratheodory_measure_sigma_additive _ _ mstar) => //; last first.
  exact: subset_g_salgebra_caratheodory.
by move=> i; exact: (subset_g_salgebra_caratheodory (mF i)).
Qed.

Definition Hahn_ext : {measure set I -> \bar R} :=
  Measure.Pack _ (Measure.Axioms
    Hahn_ext'0 Hahn_ext'_ge0 Hahn_ext'_sigma_additive).

Lemma Hahn_ext_sigma_finite : @sigma_finite _ T setT mu ->
  @sigma_finite _ I setT Hahn_ext.
Proof.
move=> -[S setTS mS]; exists S => //; move=> i; split.
  by have := (mS i).1; exact: g_salgebra_self.
by rewrite /Hahn_ext /= /Hahn_ext' measurable_mu_extE //;
  [exact: (mS i).2 | exact: (mS i).1].
Qed.

Lemma Hahn_ext_unique : @sigma_finite _ T setT mu ->
  (forall mu' : {measure set I -> \bar R},
    (forall X, @measurable T X -> mu' X = mu X) ->
    (forall X, @measurable I X -> Hahn_ext X = mu' X)).
Proof.
move=> sfmu mu' mu'mu; move: (sfmu) => /sigma_finiteP[S setTS [le_S mS]] X mX.
apply: (@measure_unique R I (@measurable T) erefl _ S) => //.
- by move=> ? ? ? ?; apply: measurableI.
- by move=> i; exact: (mS i).1.
- move=> Y mY.
  by rewrite /Hahn_ext/Hahn_ext'/= measurable_mu_extE // mu'mu.
- move=> i.
  by rewrite /Hahn_ext/=/Hahn_ext' measurable_mu_extE //;
    [exact: (mS i).2 | exact: (mS i).1].
Qed.

End Hahn_extension.

Local Close Scope ereal_scope.

Section lte_bnd.
Variables (d : unit) (T : porderType d).
Implicit Types (x y : T) (b : bool).

Local Lemma BLeft_ltE x y : (BLeft x < BLeft y)%O = (x < y)%O.
Proof. by []. Qed.
Local Lemma BRight_leE x y : (BRight x <= BRight y)%O = (x <= y)%O.
Proof. by []. Qed.
Local Lemma BRight_BLeft_leE x y : (BRight x <= BLeft y)%O = (x < y)%O.
Proof. by []. Qed.
Local Lemma BLeft_BRight_ltE x y : (BLeft x < BRight y)%O = (x <= y)%O.
Proof. by []. Qed.
Local Lemma BRight_BSide_ltE x y b : (BRight x < BSide b y)%O = (x < y)%O.
Proof. by case: b. Qed.
Local Lemma BLeft_BSide_leE x y b : (BLeft x <= BSide b y)%O = (x <= y)%O.
Proof. by case: b. Qed.

Definition lte_bnd := (BLeft_ltE, BLeft_BRight_ltE, BRight_BSide_ltE,
  BLeft_BSide_leE, BRight_BLeft_leE, BRight_leE).

Lemma BSide_BRight_leE x y b : (BSide b x <= BRight y)%O = (x <= y)%O.
Proof. by case: b. Qed.
Lemma BSide_BLeft_leE x y b : (BSide b x < BLeft y)%O = (x < y)%O.
Proof. by case: b. Qed.
Lemma BSide_leE x y b : (BSide b x <= BSide b y)%O = (x <= y)%O.
Proof. by case: b. Qed.
Lemma BSide_ltE x y b : (BSide b x < BSide b y)%O = (x < y)%O.
Proof. by case: b. Qed.

End lte_bnd.

Lemma ltBRight_leBLeft (d : unit) (T : porderType d) (a : itv_bound T) (r : T) :
  (a < BRight r)%O -> (a <= BLeft r)%O.
Proof. by move: a => [[] a|[]]. Qed.

Lemma itv_meet_mem (d : unit) (T : orderType d) (i1 i2 j1 j2 : itv_bound T)
    (x : T) :
  x \in itv_meet (Interval i1 i2) (Interval j1 j2) <->
  x \in Interval i1 i2 /\ x \in Interval j1 j2.
Proof.
split.
  rewrite /= 3!itv_boundlr joinEtotal meetEtotal le_maxl le_minr.
  by move=> /andP[/andP[-> ->] /andP[-> ->]].
case; rewrite 2!itv_boundlr => /andP[i1x xi2] /andP[j1x xj2].
by rewrite /= itv_boundlr joinEtotal meetEtotal le_maxl le_minr i1x j1x xj2 xi2.
Qed.

Coercion pair_of_interval T (I : interval T) : itv_bound T * itv_bound T :=
  let: Interval b1 b2 := I in (b1, b2).

Definition miditv (R : numDomainType) (i : interval R) : R :=
  match i with
  | Interval (BSide _ a) (BSide _ b) => (a + b) / 2
  | Interval -oo%O (BSide _ b) => b - 1
  | Interval (BSide _ a) +oo%O => a + 1
  | Interval -oo%O +oo%O => 0
  | _ => 0
  end.

Section miditv_lemmas.
Variable R : numFieldType.
Implicit Types i : interval R.

Lemma mem_miditv i : (i.1 < i.2)%O -> miditv i \in i.
Proof.
move: i => [[[]a|[]] [[]b|[]]] //= ab; rewrite in_itv /=.
- by rewrite midf_lt // andbT midf_le // ltW.
- by rewrite midf_le // midf_le.
- by rewrite ler_addl ler01.
- by rewrite midf_lt // midf_lt.
- by rewrite midf_lt // midf_le // ltW.
- by rewrite ltr_addl ltr01.
- by rewrite ltr_subl_addr ltr_addl.
- by rewrite ler_subl_addr ler_addl.
Qed.

Lemma miditv_bnd2 i : (i.1 < i.2)%O -> forall b, (BSide b (miditv i) <= i.2)%O.
Proof.
move: i => [[[]a|[]] [[]b|[]]] //= => ab; case; rewrite lte_bnd.
- by rewrite midf_le // ltW.
- by rewrite midf_lt.
- by rewrite midf_le.
- by rewrite midf_le.
- by rewrite midf_le // ltW.
- by rewrite midf_lt.
- by rewrite midf_le // ltW.
- by rewrite midf_le // ltW.
- by rewrite ler_subl_addl ler_addr.
- by rewrite ltr_subl_addl ltr_addr.
- by rewrite ler_subl_addl ler_addr.
- by rewrite ler_subl_addl ler_addr.
Qed.

Lemma miditv_bnd1 i : (i.1 < i.2)%O -> forall b, (i.1 <= BSide b (miditv i))%O.
Proof.
move: i => [[[]a|[]] [[]b|[]]] //= => ab; case; rewrite lte_bnd.
- by rewrite midf_le // ltW.
- by rewrite midf_le // ltW.
- by rewrite midf_le.
- by rewrite midf_le.
- by rewrite ler_addl.
- by rewrite ler_addl.
- by rewrite midf_lt.
- by rewrite midf_le // ltW.
- by rewrite midf_lt.
- by rewrite midf_le // ltW.
- by rewrite ltr_addl.
- by rewrite ler_addl.
Qed.

End miditv_lemmas.

(* definitions and lemmas to make a bridge between MathComp intervals and     *)
(* classical sets                                                             *)
Section set_itv_porderType.
Variables (d : unit) (T : porderType d).
Implicit Types (i j : interval T) (x y : T) (a : itv_bound T).

Definition neitv i := [set` i] != set0.

Lemma neitv_lt_bnd i : neitv i -> (i.1 < i.2)%O.
Proof.
case: i => a b; apply: contraNT => /= /itv_ge ab0.
by apply/eqP; rewrite predeqE => t; split => //=; rewrite ab0.
Qed.

Lemma set_itvP i j : [set` i] = [set` j] :> set _ <-> i =i j.
Proof.
split => [ij x|ij]; first by have /(congr1 (@^~ x))/=/is_true_inj := ij.
by rewrite predeqE => r /=; rewrite ij.
Qed.

Lemma subset_itvP i j : {subset i <= j} <-> [set` i] `<=` [set` j].
Proof. by []. Qed.

Lemma set_itvoo x y : `]x, y[%classic = (fun z => x < z < y)%O.
Proof. by []. Qed.

Lemma set_itvoo0 x : `]x, x[%classic = set0.
Proof.
rewrite set_itvoo predeqE => r; split => // /andP[/lt_trans] /[apply].
by rewrite ltxx.
Qed.

Lemma set_itvcc x y : `[x, y]%classic = (fun z => x <= z <= y)%O.
Proof. by []. Qed.

Lemma set_itvoc x y : `]x, y]%classic = (fun z => x < z <= y)%O.
Proof. by []. Qed.

Lemma set_itvoc0 x : `]x, x]%classic = set0.
Proof.
rewrite set_itvoc predeqE => r; split => // /andP[/lt_le_trans] /[apply].
by rewrite ltxx.
Qed.

Lemma set_itvco x y : `[x, y[%classic = (fun z => x <= z < y)%O.
Proof. by []. Qed.

Lemma set_itvco0 x : `[x, x[%classic = set0.
Proof.
rewrite set_itvco predeqE => r; split => // /andP[/le_lt_trans] /[apply].
by rewrite ltxx.
Qed.

Lemma set_itv_infty_infty : `]-oo, +oo[%classic = @setT T.
Proof. by rewrite predeqE. Qed.

Lemma set_itv_o_infty x : `]x, +oo[%classic = (fun z => x < z)%O.
Proof. by rewrite predeqE /mkset => r; rewrite in_itv andbT. Qed.

Lemma set_itv_c_infty x : `[x, +oo[%classic = (fun z => x <= z)%O.
Proof. by rewrite predeqE /mkset => r; rewrite in_itv andbT. Qed.

Lemma set_itv_infty_o x : `]-oo, x[%classic = (fun z => z < x)%O.
Proof. by rewrite predeqE /mkset => r; rewrite in_itv. Qed.

Lemma set_itv_infty_c x : `]-oo, x]%classic = (fun z => z <= x)%O.
Proof. by rewrite predeqE /mkset => r; rewrite in_itv. Qed.

Lemma set_itv_pinfty_bnd a : [set` Interval +oo%O a] = set0.
Proof. by apply/eqP/negPn/negP => /neitv_lt_bnd. Qed.

Lemma set_itv_bnd_ninfty a : [set` Interval a -oo%O] = set0.
Proof. by apply/eqP/negPn/negP => /neitv_lt_bnd /=; case: a => [[]a|[]]. Qed.

Definition set_itv_infty_set0 := (set_itv_bnd_ninfty, set_itv_pinfty_bnd).

Definition set_itvE := (set_itvoo0, set_itvoc0, set_itvco0, set_itvoo,
  set_itvcc, set_itvoc, set_itvco, set_itv_infty_infty, set_itv_o_infty,
  set_itv_c_infty, set_itv_infty_o, set_itv_infty_c, set_itv_infty_set0).

(* puncture interval *)
Lemma punct_itvoc x y : (x < y)%O -> (`]x, y] = `]x, y[ `|` [set y])%classic.
Proof.
move=> xy; rewrite !set_itvE predeqE => r; split=> [/andP[xr]|].
  by rewrite le_eqVlt => /predU1P[->|ry]; [right|left; rewrite xr].
by case=> [/andP[ar /ltW ->]|->]; [rewrite andbT|rewrite xy lexx].
Qed.

Lemma punct_itvco x y : (x < y)%O -> (`[x, y[ = [set x] `|` `]x, y[)%classic.
Proof.
move=> xy; rewrite !set_itvE predeqE => r; split=> [/andP[]|].
  by rewrite le_eqVlt => /predU1P[->|xr ry]; [left|right; rewrite xr].
by case=> [->|/andP[/ltW -> -> //]]; rewrite lexx.
Qed.

Lemma punct_itvccL x y : (x <= y)%O -> (`[x, y] = [set x] `|` `]x, y])%classic.
Proof.
move=> ab; rewrite !set_itvE predeqE => r; split=> [/andP[]|].
  by rewrite le_eqVlt => /predU1P[->|xr ry]; [left|right; rewrite xr].
by case=> [->|/andP[/ltW -> -> //]]; rewrite lexx.
Qed.

Lemma punct_itvccR x y : (x <= y)%O -> (`[x, y] = `[x, y[ `|` [set y])%classic.
Proof.
move=> xy; rewrite !set_itvE predeqE => r; split=> [/andP[xr]|].
  by rewrite le_eqVlt => /predU1P[->|ry]; [right|left; rewrite xr].
by case=> [/andP[-> /ltW //]|->]; rewrite lexx xy.
Qed.

Lemma punct_itv_c_infty x : (`[x, +oo[ = [set x] `|` `]x, +oo[ )%classic.
Proof.
rewrite predeqE => r; rewrite !set_itvE; split; last by case=> [->//|/ltW].
by rewrite le_eqVlt => /predU1P[->|?]; [left|right].
Qed.

Lemma punct_itv_infty_c x : (`]-oo, x] = `]-oo, x[ `|` [set x])%classic.
Proof.
rewrite predeqE => r; rewrite !set_itvE; split => [|[/ltW //|-> //=]].
by rewrite le_eqVlt => /predU1P[->|xr]; [right|left].
Qed.

End set_itv_porderType.
Arguments neitv {d T} _.

Section set_itv_numFieldType.
Variable R : numFieldType.
Implicit Types i : interval R.

Lemma neitvE i : neitv i = (i.1 < i.2)%O.
Proof.
apply/idP/idP; first exact: neitv_lt_bnd.
by move=> /mem_miditv ii; apply/set0P; exists (miditv i).
Qed.

Lemma neitvP i : reflect (i.1 < i.2)%O (neitv i).
Proof. by apply: (iffP idP); rewrite -neitvE. Qed.

End set_itv_numFieldType.

Lemma setitv0 (R : realDomainType) : [set` (0%O : interval R)] = set0.
Proof. by rewrite predeqE. Qed.

Section interval_has_bound.
Variable R : numDomainType.

Lemma has_lbound_itv (x : R) b (a : itv_bound R) :
  has_lbound [set` Interval (BSide b x) a].
Proof. by case: b; exists x => r /andP[]; rewrite lte_bnd // => /ltW. Qed.

Lemma has_ubound_itv (x : R) b (a : itv_bound R) :
  has_ubound [set` Interval a (BSide b x)].
Proof. by case: b; exists x => r /andP[]; rewrite lte_bnd // => _ /ltW. Qed.

End interval_has_bound.

Section interval_hasNbound.
Variable R : realDomainType.

Lemma hasNlbound_itv (a : itv_bound R) : a != -oo%O ->
  ~ has_lbound [set` Interval -oo%O a].
Proof.
move: a => [b r|[|]] _ //.
  suff: ~ has_lbound `]-oo, r[%classic.
    by case: b => //; apply/contra_not/subset_has_lbound => x /ltW.
  apply/has_lbPn => x; exists (minr (r - 1) (x - 1)).
    by rewrite !set_itvE lt_minl ltr_subl_addr ltr_addl ltr01.
  by rewrite lt_minl orbC ltr_subl_addr ltr_addl ltr01.
case=> r /(_ (r - 1)) /=; rewrite in_itv /= => /(_ erefl).
by apply/negP; rewrite -ltNge ltr_subl_addr ltr_addl.
Qed.

Lemma hasNubound_itv (a : itv_bound R) : a != +oo%O ->
  ~ has_ubound [set` Interval a +oo%O].
Proof.
move: a => [b r|[|]] _ //.
  suff: ~ has_ubound `]r, +oo[%classic.
    case: b => //; apply/contra_not/subset_has_ubound => x.
    by rewrite !set_itvE => /ltW.
  apply/has_ubPn => x; rewrite !set_itvE; exists (maxr (r + 1) (x + 1));
  by rewrite ?in_itv /= ?andbT lt_maxr ltr_addl ltr01 // orbT.
case=> r /(_ (r + 1)) /=; rewrite in_itv /= => /(_ erefl).
by apply/negP; rewrite -ltNge ltr_addl.
Qed.

End interval_hasNbound.

Hint Extern 0 (has_lbound _) => solve[apply: has_lbound_itv] : core.
Hint Extern 0 (has_ubound _) => solve[apply: has_ubound_itv] : core.
Hint Extern 0 (~ has_lbound _) => solve[by apply: hasNlbound_itv] : core.
Hint Extern 0 (~ has_ubound _) => solve[by apply: hasNubound_itv] : core.

Section interval_has.
Variable R : realType.
Implicit Types x : R.

Lemma has_sup_half x b (i : itv_bound R) : (i < BSide b x)%O ->
  has_sup [set` Interval i (BSide b x)].
Proof.
move: b i => [] [[]y|[]]; rewrite ?lte_bnd => xy; split=> //; do 1?[
  by exists ((x + y) / 2); rewrite !set_itvE addrC !(midf_le,midf_lt) //;
    exact: ltW
| by exists (x - 1); rewrite !set_itvE
    !(ltr_subl_addr, ler_subl_addr, ltr_addl,ler_addl)].
Qed.

Lemma has_inf_half x b (i : itv_bound R) : (BSide b x < i)%O ->
  has_inf [set` Interval (BSide b x) i].
Proof.
move: b i => [] [[]y|[]]; rewrite ?lte_bnd => xy; do 1?[
  by (split=> //; exists ((x + y) / 2); rewrite !set_itvE !(midf_le,midf_lt) //;
    exact: ltW)
| (by split => //; exists (x + 1); rewrite !set_itvE !(ltr_addl,ler_addl))].
Qed.

End interval_has.

Hint Extern 0 (has_sup _) => solve[apply: has_sup1 | exact: has_sup_half] : core.
Hint Extern 0 (has_inf _) => solve[apply: has_inf1 | exact: has_inf_half]: core.

Lemma minus_itv_bnd_infty (R : numDomainType) (x : R) b :
  -%R @` [set` Interval (BSide b x) +oo%O] =
  [set` Interval -oo%O (BSide (negb b) (- x))].
Proof.
rewrite predeqE => /= r; split=> [[y xy <-]|xr].
  by case: b xy; rewrite !in_itv/= andbT (ler_opp2, ltr_opp2).
exists (- r); rewrite ?opprK //.
by case: b xr; rewrite !in_itv/= andbT (ler_oppr, ltr_oppr).
Qed.

Lemma minus_itvoo (R : numDomainType) (x y : R) :
  -%R @` `]x, y[%classic = `](- y), (- x)[%classic.
Proof.
rewrite predeqE => /= r; split => [[{}r + <-]|].
  by rewrite !in_itv/= !ltr_opp2 andbC.
by exists (- r); rewrite ?opprK// !in_itv/= ltr_oppl ltr_oppr andbC.
Qed.

Section interval_sup_inf.
Variable R : realType.
Implicit Types x y : R.

Lemma sup_itv_infty_bnd x b : sup [set` Interval -oo%O (BSide b x)] = x.
Proof.
case: b; last first.
  by rewrite punct_itv_infty_c sup_setU ?sup1// => ? ? ? ->; exact/ltW.
set s := sup _; apply/eqP; rewrite eq_le; apply/andP; split.
- apply sup_le_ub; last by move=> ? /ltW.
  by exists (x - 1); rewrite !set_itvE ltr_subl_addr ltr_addl.
- rewrite leNgt; apply/negP => sx; pose p := (s + x) / 2.
  suff /andP[?]: (p < x) && (s < p) by apply/negP; rewrite -leNgt sup_ub.
  by rewrite !midf_lt.
Qed.

Lemma inf_itv_bnd_infty x b : inf [set` Interval (BSide b x) +oo%O] = x.
Proof.
case: b; last by rewrite /inf minus_itv_bnd_infty sup_itv_infty_bnd opprK.
rewrite punct_itv_c_infty inf_setU ?inf1// => _ b ->.
by rewrite !set_itvE => /ltW.
Qed.

Let sup_itv_o_bnd x y b : x < y ->
  sup [set` Interval (BRight x) (BSide b y)] = y.
Proof.
case: b => xy; last first.
  by rewrite punct_itvoc// sup_setU ?sup1// => ? ? /andP[? /ltW ?] ->.
set B := [set` _]; set A := `]-oo, x]%classic.
rewrite -(@sup_setU _ A B) //.
- rewrite -(sup_itv_infty_bnd y true); congr sup.
  rewrite predeqE => u; split=> [[|/andP[]//]|yu].
  by rewrite /A !set_itvE => /le_lt_trans; apply.
  by have [xu|ux] := ltP x u; [right; rewrite /B !set_itvE xu| left].
- by move=> u v; rewrite /A /B => ? /andP[xv _]; rewrite (le_trans _ (ltW xv)).
Qed.

Lemma sup_itv_bounded x y a b : x < y ->
  sup [set` Interval (BSide a x) (BSide b y)] = y.
Proof.
case: a => xy; last exact: sup_itv_o_bnd.
case: b.
  by rewrite punct_itvco// sup_setU ?sup_itv_o_bnd// => ? ? -> /andP[/ltW].
by rewrite (punct_itvccR (ltW _))// sup_setU ?sup1// => ? ? /andP[_ /ltW ? ->].
Qed.

Lemma sup_itvcc x y : x <= y -> sup `[x, y]%classic = y.
Proof.
by move=> ?; rewrite punct_itvccR// sup_setU ?sup1// => ? ? /andP[_ /ltW ? ->].
Qed.

Let inf_itv_bnd_o x y b : x < y ->
  inf [set` Interval (BSide b x) (BLeft y)] = x.
Proof.
case: b => xy.
  by rewrite punct_itvco// inf_setU ?inf1// => _ ? -> /andP[/ltW].
by rewrite /inf minus_itvoo sup_itv_o_bnd ?opprK // ltr_oppl opprK.
Qed.

Lemma inf_itv_bounded x y a b : x < y ->
  inf [set` Interval (BSide a x) (BSide b y)] = x.
Proof.
case: b => xy; first exact: inf_itv_bnd_o.
case: a.
  by rewrite (punct_itvccL (ltW _))// inf_setU ?inf1// => ? ? -> /andP[/ltW].
by rewrite punct_itvoc// inf_setU ?inf_itv_bnd_o// => ? ? /andP[? /ltW ?] ->.
Qed.

Lemma inf_itvcc x y : x <= y -> inf `[x, y]%classic = x.
Proof.
by move=> ?; rewrite punct_itvccL// inf_setU ?inf1 // => ? ? -> /andP[/ltW].
Qed.

End interval_sup_inf.

(* lemmas between itv and set-theoretic operations *)
Section set_itv_porderType.
Variables (d : unit) (T : orderType d).
Implicit Types (x y : T) (i j : interval T) (b : bool).

Lemma set_itvC_infty_bnd b x :
  ~` [set` Interval -oo%O (BSide b x)] =
  [set` Interval (BSide b x) +oo%O].
Proof.
case: b; rewrite !set_itvE predeqE => r.
by split; rewrite leNgt => /negP.
by split; rewrite ltNge => /negP.
Qed.

Lemma set_itvC_bnd_infty b x :
  ~` [set` Interval (BSide b x) +oo%O] =  [set` Interval -oo%O (BSide b x)].
Proof. by rewrite -set_itvC_infty_bnd setCK. Qed.

Let set_itvC_bounded b0 b1 x y : ~` [set` Interval (BSide b0 x) (BSide b1 y)] =
  [set` Interval -oo%O (BSide b0 x)] `|` [set` Interval (BSide b1 y) +oo%O].
Proof.
move: b0 b1 => [] []; rewrite !set_itvE predeqE => r; split.
by move/negP; rewrite negb_and -ltNge -leNgt => /orP.
by move/orP; rewrite leNgt (ltNge r x) -negb_and => /negP.
by move/negP; rewrite negb_and -2!ltNge => /orP.
by move/orP; rewrite 2!ltNge -negb_and => /negP.
by move/negP; rewrite negb_and -2!leNgt => /orP.
by move/orP; rewrite 2!leNgt -negb_and => /negP.
by move/negP; rewrite negb_and -leNgt -ltNge => /orP.
by move/orP; rewrite leNgt (ltNge y r) -negb_and => /negP.
Qed.

Lemma set_itvC_itv i : ~` [set` i] =
  [set` Interval -oo%O i.1] `|` [set` Interval i.2 +oo%O].
Proof.
case: i => -[[] x|[]] [[] y|[]] /=.
by rewrite set_itvC_bounded.
by rewrite set_itvC_bounded.
by rewrite !set_itvE setUT setC0.
by rewrite set_itvC_bnd_infty !set_itvE setU0.
by rewrite set_itvC_bounded.
by rewrite set_itvC_bounded.
by rewrite !set_itvE setC0 setUT.
by rewrite set_itvC_bnd_infty !set_itvE setU0.
by rewrite set_itvC_infty_bnd !set_itvE set0U.
by rewrite set_itvC_infty_bnd !set_itvE set0U.
by rewrite set_itvE setC0 set0U set_itvE.
by rewrite !set_itvE setCT set0U.
by rewrite !set_itvE setTU setC0.
by rewrite !set_itvE setTU setC0.
by rewrite !set_itvE setC0 setTU.
by rewrite !set_itvE setC0 setU0.
Qed.

Definition set_itvC := (set_itvC_infty_bnd, set_itvC_bnd_infty, set_itvC_itv).

Lemma itv_boundedErays a x b y : [set` Interval (BSide a x) (BSide b y)] =
  [set` Interval (BSide a x) +oo%O] `\` [set` Interval (BSide b y) +oo%O].
Proof. by rewrite -[LHS]setCK set_itvC setCU /= set_itvC setDE. Qed.

Lemma set_itv_meet i j : [set` itv_meet i j] = [set` i] `&` [set` j].
Proof.
rewrite eqEsubset; split => x; move: i j => [i1 i2] [j1 j2] /=.
- rewrite itv_boundlr joinEtotal meetEtotal le_maxl le_minr.
  move=> /andP[/andP[i1x j1x] /andP[xi2 xj2]].
  by split; rewrite /= itv_boundlr ?i1x ?xi2 // j1x xj2.
- case; rewrite /= !itv_boundlr => /andP[i1x xi2] /andP[j1x xj2] /=.
  by rewrite joinEtotal meetEtotal le_maxl le_minr i1x xi2 j1x xj2.
Qed.

End set_itv_porderType.

Section set_itv_realType.
Variable R : realType.
Implicit Types x : R.

Lemma set_itvK : {in neitv, cancel (fun i => [set` i]) (@Rhull R)}.
Proof.
move=> [[[] x|[]] [[] y|[]]] /neitvP //;
  rewrite /Rhull /= !(in_itv, inE)/= ?lte_bnd => xy.
- rewrite asboolT// inf_itv_bounded// lexx/= xy asboolT// asboolT//=.
  by rewrite asboolF//= sup_itv_bounded//= ltxx ?andbF.
- by rewrite asboolT// inf_itvcc// ?asboolT// ?sup_itvcc// ?lexx ?xy.
- by rewrite asboolT//= inf_itv_bnd_infty lexx asboolT// asboolF.
- rewrite asboolT// inf_itv_bounded//= ltxx asboolF// asboolT//.
  by rewrite sup_itv_bounded// ltxx andbF asboolF.
  rewrite asboolT // inf_itv_bounded // ltxx asboolF // asboolT //.
  by rewrite sup_itv_bounded // xy lexx asboolT.
- by rewrite asboolT // inf_itv_bnd_infty ltxx asboolF // asboolF.
- by rewrite asboolF // asboolT // sup_itv_infty_bnd ltxx asboolF.
- by rewrite asboolF // asboolT // sup_itv_infty_bnd lexx asboolT.
- by rewrite asboolF // asboolF.
Qed.

Lemma RhullT : Rhull setT = `]-oo, +oo[%R :> interval R.
Proof. by rewrite /Rhull -set_itv_infty_infty asboolF// asboolF. Qed.

Lemma RhullK : {in [pred X | `[< is_interval X >]],
                cancel (@Rhull R) (fun i => [set` i])}.
Proof.
move=> X /asboolP iX; rewrite /Rhull /mkset /= predeqE => r.
case: ifPn => /asboolP bX; last first.
  case: ifPn => /asboolP aX; last by rewrite (interval_unbounded_setT _ bX aX).
  rewrite in_itv /= negbK; have [|] := asboolP (X (sup X)) => XsupX /=.
    split => [|Xr].
      rewrite le_eqVlt => /predU1P[->//|rX].
      move/has_lbPn : bX => /(_ r)[y Xy yr].
      by move: (iX _ _ Xy XsupX); apply; rewrite (ltW yr) (ltW rX).
    by rewrite /mkset sup_ub //; exact/asboolP.
  split => [rX|Xr]; last exact: sup_ub_strict.
  by apply: interior_subset; rewrite interval_left_unbounded_interior.
case: ifPn => /asboolP uX.
  have [|] := asboolP (X (inf X)) => XinfX.
    rewrite in_itv /= negbK; have [|] := asboolP (X (sup X)) => XsupX /=.
      split=> [|Xr]; last first.
        by rewrite /mkset sup_ub // andbT inf_lb.
      move => /andP[]; rewrite le_eqVlt => /predU1P[<-//|infXr].
      rewrite le_eqVlt => /predU1P[->//|rsupX]; apply: interior_subset.
      by rewrite interval_bounded_interior //; rewrite /mkset infXr.
    split => [/andP[]|Xr].
      rewrite le_eqVlt => /predU1P[<-//|infXr rsupX]; apply: interior_subset.
      by rewrite interval_bounded_interior //; rewrite /mkset infXr.
    by rewrite /mkset inf_lb //= sup_ub_strict.
  have [|] := asboolP (X (sup X)) => XsupX /=.
    rewrite in_itv /=; split=> [/andP[infXr]|Xr]; last first.
      by rewrite inf_lb_strict // sup_ub.
    rewrite le_eqVlt => /predU1P[->//|rsupX]; apply: interior_subset.
    by rewrite interval_bounded_interior //; rewrite /mkset infXr.
  rewrite in_itv /=; split=> [/andP[infXr rsupX]|Xr]; last first.
    by rewrite inf_lb_strict // sup_ub_strict.
  apply: interior_subset.
  by rewrite interval_bounded_interior //; rewrite /mkset infXr.
rewrite in_itv /=; have [|] := asboolP (X (inf X)) => XinfX /=.
  rewrite andbT; split => [|Xr]; last exact: inf_lb.
  rewrite le_eqVlt => /predU1P[<-//|infXr].
  move/has_ubPn : uX => /(_ r)[y Xy yr].
  by move: (iX _ _ XinfX Xy); apply; rewrite (ltW infXr) (ltW yr).
rewrite andbT.
split=> [infXr|Xr]; last exact: inf_lb_strict.
by apply: interior_subset; rewrite interval_right_unbounded_interior.
Qed.

Lemma itv_c_inftyEbigcap x :
  `[x, +oo[%classic = \bigcap_k `]x - k.+1%:R^-1, +oo[%classic.
Proof.
rewrite predeqE => y; split=> /= [|xy].
  rewrite in_itv /= andbT => xy z _ /=; rewrite in_itv /= andbT ltr_subl_addr.
  by rewrite (le_lt_trans xy) // ltr_addl invr_gt0 ltr0n.
rewrite in_itv /= andbT leNgt; apply/negP => yx.
have {}[k ykx] := ltr_add_invr yx.
have {xy}/= := xy k Logic.I.
by rewrite in_itv /= andbT; apply/negP; rewrite -leNgt ler_subr_addr ltW.
Qed.

Lemma itv_bnd_inftyEbigcup b x : [set` Interval (BSide b x) +oo%O] =
  \bigcup_k [set` Interval (BSide b x) (BLeft k%:R)].
Proof.
rewrite predeqE => y; split=> /=; last first.
  by move=> [n _]/=; rewrite in_itv => /andP[xy yn]; rewrite in_itv /= xy.
rewrite in_itv /= andbT => xy; exists (`|floor y|%N.+1) => //=.
rewrite in_itv /= xy /= -addn1 natrD.
have [y0|y0] := ltP 0 y; last by rewrite (le_lt_trans y0)// ltr_spaddr.
rewrite natr_absz ger0_norm; last by rewrite floor_ge0 ltW.
by rewrite -RfloorE lt_succ_Rfloor.
Qed.

Lemma itv_o_inftyEbigcup x :
  `]x, +oo[%classic = \bigcup_k `[x + k.+1%:R^-1, +oo[%classic.
Proof.
rewrite predeqE => y; split => [|[n _]]/=.
  rewrite in_itv /= andbT => xy.
  have {}[k xky] := ltr_add_invr xy.
  by exists k => //=; rewrite in_itv /= (ltW xky).
rewrite in_itv /= andbT => xny.
by rewrite in_itv /= andbT (lt_le_trans _ xny) // ltr_addl invr_gt0.
Qed.

Lemma set_itv_setT (i : interval R) : [set` i] = setT -> i = `]-oo, +oo[.
Proof.
have [i0  /(congr1 (@Rhull _))|] := boolP (neitv i).
  by rewrite set_itvK// => ->; exact: RhullT.
by rewrite negbK => /eqP ->; rewrite predeqE => /(_ 0)[_]/(_ Logic.I).
Qed.

End set_itv_realType.

Lemma trivIset_set_itv_nth (R : numDomainType) def (s : seq (interval R))
  (D : set nat) : [set` def] = set0 ->
  trivIset D (fun i => [set` nth def s i]) <->
    trivIset D (fun i => nth set0 [seq [set` j] | j <- s] i).
Proof.
move=> def0; split=> /trivIsetP ss; apply/trivIsetP => i j Di Dj ij.
- have [si|si] := ltP i (size s); last first.
    by rewrite (nth_default set0) ?size_map// set0I.
  have [sj|sj] := ltP j (size s); last first.
    by rewrite setIC (nth_default set0) ?size_map// set0I.
  by rewrite (nth_map def) // (nth_map def) // ss.
- have [?|h] := ltP i (size s); last by rewrite (nth_default def h) def0 set0I.
  have [?|h] := ltP j (size s); last by rewrite (nth_default def h) def0 setI0.
  by have := ss _ _ Di Dj ij; rewrite (nth_map def) // (nth_map def).
Qed.
Arguments trivIset_set_itv_nth {R} _ {s}.

Lemma neitv_bnd1 (R : numFieldType) (s : seq (interval R)) :
  all neitv s -> forall i, i \in s -> i.1 != +oo%O.
Proof.
move=> /allP sne [a b] si /=; apply/negP => /eqP boo; move: si.
by rewrite boo => /sne /negP; apply; rewrite set_itv_infty_set0.
Qed.

Lemma neitv_bnd2 (R : numFieldType) (s : seq (interval R)) :
  all neitv s -> forall i, i \in s -> i.2 != -oo%O.
Proof.
move=> /allP sne [a b] si /=; apply/negP => /eqP boo; move: si.
by rewrite boo => /sne /negP; apply; rewrite set_itv_infty_set0.
Qed.

Section simple_sets.
Variable R : numDomainType.
Implicit Types (s : seq (interval R)) (i : interval R).

Definition sset s := \big[setU/set0]_(x <- s) [set` x].

Local Notation "[ 'sset' 'of' s ]" := (sset s).

Lemma ssetE s : [sset of s] = \big[setU/set0]_(x <- s) [set` x].
Proof. by []. Qed.

Lemma sset_cons i s : [sset of i :: s] = [set` i] `|` [sset of s].
Proof. by rewrite ssetE big_cons -ssetE. Qed.

Lemma sset_nil : [sset of @nil (interval R)] = set0.
Proof. by rewrite ssetE big_nil. Qed.

Lemma sset_cons1 i : [sset of [:: i]] = [set` i].
Proof. by rewrite sset_cons sset_nil setU0. Qed.

Lemma sset_bigcup s : [sset of s] = \bigcup_(i in [set j | j \in s]) [set` i].
Proof. by rewrite bigcup_set. Qed.

Lemma ssetP s x :
  [sset of s] x <-> (\bigcup_(i in [set j | j \in s]) [set` i]) x.
Proof. by rewrite -sset_bigcup. Qed.

Lemma sseti s1 s2 : s1 =i s2 -> [sset of s1] = [sset of s2].
Proof.
move=> s12; rewrite 2!sset_bigcup eqEsubset; split => x [i];
  rewrite /mkset => + ix; by [rewrite s12 => ?; exists i |
                             rewrite -s12 => ?; exists i].
Qed.

Lemma sset_filter_neitv s : [sset of [seq x <- s | neitv x]] = [sset of s].
Proof.
elim: s => // h t ih /=; case: ifPn => [h0|].
  by rewrite sset_cons ih -sset_cons.
by rewrite negbK => h0; rewrite sset_cons ih (eqP h0) set0U.
Qed.

End simple_sets.
Notation "[ 'sset' 'of' s ]" := (sset s).

Notation bnd1eta := (fun (i : interval _) => i.1).
Notation bnd2eta := (fun (i : interval _) => i.2).

Section itv_cplt.
Variable R : realType.
Implicit Types s : seq (interval R).

Definition itv_cplt s : seq (interval R) :=
  let a' := -oo%O :: map bnd2eta s in
  let b' := rcons (map bnd1eta s) +oo%O in
  map (uncurry (@Interval _)) (zip a' b').

Lemma itv_cplt_nil : [sset of itv_cplt [::]] = setT.
Proof. by rewrite /itv_cplt ssetE big_seq1 set_itvE. Qed.

Lemma itv_cpltE_subset s : ~` [sset of s] `<=` [sset of itv_cplt s].
Proof.
elim: s => [x _|[a1 b1] t ih x]; first by rewrite itv_cplt_nil.
rewrite sset_cons setCU => -[] x_notin_h /ih {}ih.
set a := map bnd1eta (Interval a1 b1 :: t).
set b := map bnd2eta (Interval a1 b1 :: t).
rewrite (_ : itv_cplt _ = Interval -oo%O a1 ::
  map (uncurry (@Interval _)) (zip b (rcons (behead a) +oo%O))) //.
rewrite sset_cons.
have : ([set` Interval -oo%O a1] `|` [set` Interval b1 +oo%O]) x.
  by rewrite set_itvC in x_notin_h.
case=> [xa1|xb1]; [by left|right].
have {ih} /ssetP[j] : [sset of map (uncurry (@Interval _))
  (zip (-oo%O :: behead b) (rcons (behead a) +oo%O))] x by [].
rewrite {1}/mkset => + jx; rewrite {}/b {}/a.
move: t => [|[a2 b2] t /=]; first by rewrite sset_cons1.
rewrite inE => /orP[/eqP jb2|jb2].
  apply/ssetP; exists (Interval b1 a2); first by rewrite /mkset inE eqxx.
  by rewrite /= itv_splitI xb1 /=; move: jx; rewrite jb2.
by apply/ssetP; exists j => //; rewrite /mkset inE jb2 orbT.
Qed.

Local Lemma sorted_itv_cpltE_subset s :
  sorted <=%O (map bnd2eta s) -> sorted <=%O (map bnd1eta s) ->
  [sset of itv_cplt s] `<=` ~` [sset of s].
Proof.
set a := map bnd1eta s; set b := map bnd2eta s.
move=> sorted_b sorted_a x.
move=> /ssetP[/= j] /mapP[[b' a']] /(nthP (+oo%O, -oo%O)) => -[n].
rewrite size_zip /= size_rcons 2!size_map minnn ltnS => ns.
rewrite nth_zip; last by rewrite size_rcons /= !size_map.
move=> -[nb' na'] jba'.
move=> xj /ssetP[] i si xi.
have [k [ks ik]] : exists k, (k < size s)%N /\
    i = Interval (nth -oo%O a k) (nth +oo%O b k).
  move/(nthP 0%O) : si => [k ks ki].
  exists k; split => //.
  by rewrite /a /b !(nth_map 0%O) // ki; case: i {xi ki}.
move: xi; rewrite ik /= itv_boundlr => /andP[akx xbk].
move: xj; rewrite jba' /= itv_boundlr => /andP[b'x xa'].
rewrite -/a in na'.
rewrite -/b in nb'.
have [kn|nk] := leP k n.
  case: n => [|n] in ns na' nb' kn *.
    move: kn; rewrite lex0 => /eqP k0.
    rewrite {ns ks} /= in nb' jba' b'x xa'.
    rewrite -{}nb' {b'x b'} in jba'.
    rewrite -na' /= in xa'.
    rewrite k0 /a /= in akx.
    rewrite {jba' k0 na' xbk ik k sorted_a sorted_b a' b j}.
    rewrite {}/a in xa'.
    case: s => [//|s0 s1] in si akx xa' *.
    by have := le_trans xa' akx; rewrite lte_bnd ltxx.
  rewrite /= in nb'.
  have : (n <= (size s).-1)%N by move: ns; clear -si; case: s si.
  rewrite leq_eqVlt => /predU1P[k's1|k's1].
    move: na'; rewrite nth_rcons size_map k's1 prednK //; last first.
      by move: ns; clear -si; case: s si.
    rewrite ltnn eqxx => ka'.
    have : (BRight x <= BLeft x)%O.
      rewrite (le_trans xbk) // (le_trans _ b'x) //= -nb'.
      apply: (sorted_leq_nth le_trans) => //.
      - by rewrite inE /b size_map.
      - by rewrite inE size_map.
      - by rewrite -ltnS k's1 prednK // (leq_ltn_trans _ ks).
    by rewrite lte_bnd ltxx.
  move: kn; rewrite le_eqVlt => /orP[kn|kn].
    have : (BRight x <= BLeft x)%O.
      rewrite (@le_trans _ _ (nth -oo%O a k)) // (le_trans xa') // -na'.
      by rewrite nth_rcons size_map -(eqP kn) ks.
    by rewrite lte_bnd ltxx.
  suff: (BRight x <= BLeft x)%O by rewrite lte_bnd ltxx.
  rewrite (@le_trans _ _ (nth +oo%O b k)) // (le_trans _ b'x) //= -nb'.
  by apply: (sorted_leq_nth le_trans) => //; rewrite inE ?/b size_map.
suff: (BRight x <= BLeft x)%O by rewrite lte_bnd ltxx.
rewrite (le_trans xa') //= (le_trans _ akx) //.
rewrite -na' nth_rcons size_map (ltn_trans nk ks).
apply: (sorted_leq_nth le_trans) => //; last exact: ltnW.
- by rewrite inE size_map (ltn_trans nk).
- by rewrite inE size_map.
Qed.

Lemma itv_cpltE s : sorted <=%O (map bnd2eta s) -> sorted <=%O (map bnd1eta s) ->
  [sset of itv_cplt s] = ~` [sset of s].
Proof.
by rewrite eqEsubset; split; [exact: sorted_itv_cpltE_subset |
                              exact: itv_cpltE_subset].
Qed.

Definition itv_cplt_ne s := [seq x <- itv_cplt s | neitv x].

Lemma itv_cplt_neE s :
  sorted <=%O (map bnd2eta s) -> sorted <=%O (map bnd1eta s) ->
  [sset of itv_cplt_ne s] = ~` [sset of s].
Proof. by move=> s_a s_b; rewrite /itv_cplt_ne sset_filter_neitv itv_cpltE. Qed.

End itv_cplt.

Section itv_diff.
Variable R : realType.
Implicit Types i j : interval R.

(* assumes ~ j <= i *)
Definition itv_diff i j := if ~~ neitv (itv_meet i j) then i
  else
    let: Interval i1 i2 := i in let: Interval j1 j2 := j in
    if (j1 <= i1)%O then
      (if (j2 <= i2)%O then Interval j2 i2 else 0%O)
    else
      (if (j2 <= i2)%O then 0%O else Interval i1 j1).

Lemma set_itv_diff i j :
  (~~ (j <= i)%O) || ((j <= i)%O && (j.1 == i.1)) ->
  [set` itv_diff i j] = [set` i] `\` [set` j].
Proof.
move=> ji.
rewrite /itv_diff; case: ifPn => [ij0|/negPn ij0].
  by apply/esym/setDidPl; rewrite -set_itv_meet; apply/eqP; move/negPn : ij0.
move: i j => [i1 i2] [j1 j2] /= in ji ij0 *.
have [ji1|ji1] := leP j1 i1.
- have [ji2|ji2] := leP j2 i2.
  + rewrite eqEsubset; split=> x /=.
    * rewrite itv_boundlr => /andP[j2x xi2]; split=> /=.
        rewrite itv_boundlr xi2 andbT (@le_trans _ _ j2) // leNgt.
        apply/negP => j2j1; apply/negP : ij0; rewrite joinEtotal meetEtotal.
        by rewrite maxElt ltNge ji1 /= minElt ltNge ji2 /= neitvE /= -leNgt ltW.
      rewrite itv_boundlr => /andP[j1x xj2].
      by have := le_trans xj2 j2x; rewrite lte_bnd ltxx.
    * case; rewrite !itv_boundlr => /andP[i1x xi2] /negP; rewrite xi2 andbT.
      by apply: contraNle; rewrite (le_trans ji1).
  + rewrite set_itvE; apply/esym; rewrite setD_eq0 => x /=; rewrite !itv_boundlr.
    by move=> /andP[i1x xi2]; rewrite (le_trans ji1)// (le_trans xi2)// ltW.
- have [ji2|ji2] := leP j2 i2.
    case/orP: ji => [|/andP[ji]]; last by rewrite gt_eqF.
    by rewrite itv_leEmeet [in X in X -> _]/= (join_l (ltW _))// meet_l// eqxx.
  rewrite eqEsubset; split=> x /=.
  * rewrite itv_boundlr => /andP[i1x xj1]; split.
      rewrite itv_boundlr i1x /= leNgt; apply/negP => i2j1; apply/negP : ij0.
      rewrite meetEtotal minElt ji2 joinEtotal maxElt ji1 neitvE /=.
      by rewrite -leNgt (le_trans _ xj1) // (le_trans (ltW i2j1)).
    rewrite itv_boundlr => /andP[j1x xj2].
    by have := le_trans xj1 j1x; rewrite lte_bnd ltxx.
  * move=> -[]; rewrite itv_boundlr => /andP[i1x xi2].
    rewrite itv_boundlr => /negP; rewrite negb_and -2!ltNge => /orP[xj1|j2x].
      by rewrite itv_boundlr i1x.
    by have := lt_trans (le_lt_trans xi2 ji2) j2x; rewrite ltxx.
Qed.

Lemma set_itv_diffxx i : [set` itv_diff i i] = set0.
Proof. by rewrite set_itv_diff ?setDv// lexx eqxx. Qed.

End itv_diff.

Section disjoint_itv.
Context {R : numDomainType}.

Definition disjoint_itv : rel (interval R) :=
  fun a b => [disjoint [set` a] & [set` b]].

Lemma disjoint_itvxx (i : interval R) : neitv i -> ~~ disjoint_itv i i.
Proof. by move=> i0; rewrite /disjoint_itv /= setIid. Qed.

Lemma lt_disjoint (i j : interval R) :
  (forall x y, x \in i -> y \in j -> x < y) -> disjoint_itv i j.
Proof.
move=> ij; apply/eqP; rewrite predeqE => x; split => // -[xi xj].
by have := ij _ _ xi xj; rewrite ltxx.
Qed.

End disjoint_itv.

Lemma disjoint_neitv {R : realFieldType} (i j : interval R) :
  disjoint_itv i j <-> ~~ neitv (itv_meet i j).
Proof.
case: i j => [a b] [c d]; rewrite /disjoint_itv /= -set_itv_meet.
by split => [/negPn//|?]; apply/negPn.
Qed.

Lemma disj_itv_Rhull {R : realType} (A B : set R) : A `&` B = set0 ->
  is_interval A -> is_interval B -> disjoint_itv (Rhull A) (Rhull B).
Proof.
by move=> AB0 iA iB; rewrite /disjoint_itv RhullK ?inE// RhullK ?inE.
Qed.

Definition contiguous_itv (R : realType) (i j : interval R) : bool :=
  (i.2 == j.1 :> itv_bound R).

Section lt_itv.
Variable R : realFieldType.
Implicit Types i j : interval R.

Definition lt_itv i j := (i.1 < j.1)%O || ((i.1 == j.1) && (i.2 < j.2)%O).

Definition le_itv i j := (i == j) || (lt_itv i j).

Lemma le_itv_bnd1 i j : le_itv i j -> (i.1 <= j.1)%O.
Proof.
rewrite /le_itv => /predU1P[->//|]; rewrite /lt_itv.
by move=> /orP[/ltW//|/andP[/eqP->//]].
Qed.

Lemma le_itv_bnd2 i j : le_itv i j -> neitv j ->
  disjoint_itv i j -> (i.2 <= j.2)%O.
Proof.
move: i j => [i1 i2] [j1 j2] /=.
rewrite /le_itv /lt_itv /= => /predU1P[[-> -> //]|] /=.
case: ltgtP => // [i1j1 _ j0 ij|->{i1} /ltW //].
rewrite leNgt; apply/negP => j2i2.
move/eqP : ij; apply/eqP.
by rewrite -set_itv_meet /= (join_r (ltW _))// (meet_r (ltW _)).
Qed.

Lemma lt_itvxx i : lt_itv i i = false.
Proof. by rewrite /lt_itv 2!ltxx andbF. Qed.

Lemma lt_itv_def i j : lt_itv i j = (j != i) && le_itv i j.
Proof.
rewrite /le_itv andb_orr eq_sym andNb /=; apply/idP/idP => [ij|/andP[]//].
by rewrite andbC ij /=; apply: contraPN ij => /eqP ->; rewrite lt_itvxx.
Qed.

Lemma le_itv_refl : reflexive le_itv.
Proof. by case=> a b; rewrite /le_itv eqxx. Qed.

Lemma le_itv_anti : antisymmetric le_itv.
Proof.
move=> /= [a b] [c d]; rewrite /le_itv => /andP[/orP[/eqP[-> -> //]|]].
rewrite /lt_itv /= => /orP[ac /orP[/eqP//|]|/andP[/eqP ac bd]].
  by rewrite ltNge (ltW ac) /= eq_sym lt_eqF.
by rewrite ac eqxx ltxx /= ltNge (ltW bd) orbF => /eqP.
Qed.

Lemma lt_itv_trans : transitive lt_itv.
Proof.
move=> [k1 k2] [i1 i2] [j1 j2]; rewrite /lt_itv /=.
case: (ltgtP i1 k1) => // [ik1 _| <-{k1} ik2]; last first.
  by case: (ltgtP i1 j1) => // _; apply: lt_trans.
by case: (ltgtP k1 j1) => // [kj1 _|<-]; [rewrite (lt_trans ik1) | rewrite ik1].
Qed.

Lemma le_itv_trans : transitive le_itv.
Proof.
move=> j i k; rewrite /le_itv.
move=> /orP[/eqP -> //|ij] /orP[/eqP <-|jk]; first by rewrite orbC ij.
by rewrite (lt_itv_trans ij jk) orbT.
Qed.

Definition le_itv_porderMixin :=
  LePOrderMixin lt_itv_def le_itv_refl le_itv_anti le_itv_trans.
Fact le_itv_display (disp : unit) : unit. Proof. exact. Qed.
Definition le_itv_porderType (disp : unit) :=
  POrderType (le_itv_display disp) (interval R) le_itv_porderMixin.

Lemma le_lt_trans_itv j i k : le_itv i j -> lt_itv j k -> lt_itv i k.
Proof. exact: (@le_lt_trans _ (le_itv_porderType _)). Qed.

Lemma lt_le_trans_itv j i k : lt_itv i j -> le_itv j k -> lt_itv i k.
Proof. exact: (@lt_le_trans _ (le_itv_porderType _)). Qed.

Lemma ltW_itv i j : lt_itv i j -> le_itv i j.
Proof. exact: (@ltW _ (le_itv_porderType _)). Qed.

Lemma total_le_itv : total le_itv.
Proof.
move=> [i1 i2] [j1 j2]; rewrite /le_itv/lt_itv/=; case/boolP: (_ == _) => ij//=.
case: (ltgtP i1 j1) => //=; rewrite ?orbT // => ij1.
by rewrite ij1; case: ltgtP => //=; rewrite ?orbT// => ->; rewrite eqxx.
Qed.

Definition le_itv_orderMixin :=
  LeOrderMixin lt_itv_def (fun _ _ => erefl) (fun _ _ => erefl)
               le_itv_anti le_itv_trans total_le_itv.
Fail Canonical le_itv_latticeType := LatticeType (interval R) le_itv_orderMixin.

Lemma lt_itv_lt i j : lt_itv i j -> disjoint_itv i j ->
  forall x y, x \in i -> y \in j -> x < y.
Proof.
move: i j => [a b] [c d]; rewrite /lt_itv; case: (ltgtP a c) => // [ac _|<-{c}].
- move=> /disjoint_neitv/negPn/eqP ij0 x y.
  rewrite 2!itv_boundlr => /andP[ax xb] /andP[cy yd].
  have [bc|cb] := leP b c; first by have := le_trans xb (le_trans bc cy).
  rewrite ltNge; apply/negP => yx.
  move: ij0; rewrite predeqE => /(_ y)[+ _]; apply.
  apply/itv_meet_mem; rewrite 2!itv_boundlr.
  by rewrite (le_trans (ltW ac)) //= (le_trans _ xb) // yd andbT cy.
- move=> /= ?; rewrite /disjoint_itv -set_itv_meet => abd.
  move=> x y; rewrite 2!itv_boundlr => /andP[ax xb] /andP[ay yd].
  rewrite ltNge; apply/negP => yx.
  move/negPn : abd => /negP; apply; apply/neitvP => /=.
  by rewrite joinxx ltxI (le_lt_trans ax)// (le_lt_trans ay).
Qed.

Lemma le_itv_lt i j : le_itv i j -> disjoint_itv i j ->
  forall x y, x \in i -> y \in j -> x < y.
Proof.
move: i j => [i1 i2] [j1 j2].
move/orP => [/eqP[<-{j1} <-{j2}]|]; last exact: lt_itv_lt.
have [i1i2|i1i2 _ x y] := ltP i1 i2; last by rewrite itv_ge // -leNgt.
by move=> /disjoint_neitv/neitvP /=; rewrite meetxx joinxx.
Qed.

Let lt_itv_subset i j k (r : R) : r \in i -> r \in k -> r \notin j ->
  lt_itv i j -> lt_itv j k ->
  (i <= j)%O \/ (j <= i)%O.
Proof.
move: i j k => [a1 a2] [b1 b2] [c1 c2] + + + ab bc; move: bc ab => /=.
rewrite /lt_itv /=; case: (ltgtP b1 c1) => //= [b1c1 _|<-{c1} b2c2]; last first.
  case : (ltgtP a1 b1) => //= [a1b1 _|<-{b1} a2b2]; last first.
    rewrite 2!itv_boundlr => /andP[a1x xa2] /andP[_ xc2] _; left.
    by rewrite itv_leEmeet/= joinxx (meet_l (ltW _)).
  rewrite 3!itv_boundlr => /andP[a1x xa2] /andP[b1x xc2].
  rewrite negb_and -2!ltNge => xb1b2; right.
  rewrite itv_leEmeet /= (join_l (ltW _))//.
  case/orP: xb1b2 => [|?]; first by move/(le_lt_trans b1x); rewrite ltxx.
  by rewrite meet_l // (le_trans _ xa2) //= ltW.
case : (ltgtP a1 b1) => // [a1b1 _|-> // a2b2].
  rewrite 3!itv_boundlr => /andP[a1x xa2] /andP[c1x xc2].
  rewrite negb_and -2!ltNge => xb1b2; right.
  rewrite itv_leEmeet /= (join_l (ltW _))//; case/orP: xb1b2 => [xb1|b2x].
    by have := lt_trans (lt_le_trans b1c1 c1x) xb1; rewrite ltxx.
  by rewrite meet_l//= (le_trans _ xa2) // ltW.
rewrite 3!itv_boundlr => /andP[b1x xa2] _ _; left.
by rewrite itv_leEmeet/= joinxx (meet_l (ltW _)).
Qed.

Lemma le_itv_subset i j k (r : R) : r \in i -> r \in k -> r \notin j ->
  le_itv i j -> le_itv j k ->
  (i <= j)%O \/ (j <= i)%O.
Proof.
move=> xa xc xb /orP[/eqP <- _|ab]; [by left|].
move/orP => [/eqP bc|]; last exact: (lt_itv_subset _ xc).
by move: xb; rewrite bc xc.
Qed.

End lt_itv.
Arguments lt_itv {R}.
Arguments le_itv {R}.
Arguments lt_itv_trans {R}.
Arguments le_itv_trans {R}.
Arguments total_le_itv {R}.
Arguments le_itv_refl {R}.
Arguments le_itv_anti {R}.

Lemma trivIset_sort (R : realFieldType) (s : seq (interval R)) (D : set nat) :
  [set k | (k < size s)%N] `<=` D ->
  trivIset D (fun i => [set` nth 0%O s i]) ->
  trivIset D (fun i => [set` nth 0%O (sort le_itv s) i]).
Proof.
move=> sD ts; rewrite trivIset_set_itv_nth ?set_itvE//.
apply (@perm_eq_trivIset _ [seq [set` i] | i <- s]).
- by apply: subset_trans _ sD => /= i; rewrite size_map.
- by rewrite perm_map // perm_sym perm_sort.
- by rewrite -(@trivIset_set_itv_nth _ 0%O) ?set_itvE.
Qed.

Lemma sset_sort_le_itv (R : realType) (s : seq (interval R)) :
  [sset of sort le_itv s] = [sset of s].
Proof. exact/sseti/mem_sort. Qed.

Section lt_itv_diff.
Variable R : realType.
Implicit Types i j : interval R.

Let lt_itv_diff i j : lt_itv i j -> ~~ (j <= i)%O -> ~~ (i <= j)%O ->
  lt_itv (itv_diff i j) j.
Proof.
rewrite /itv_diff; case: ifPn => //; move: i j => [a b] [c d] /=.
rewrite /lt_itv /=; case: ltgtP => [ab _ _ ji ijb|//|/= <-{c} ij0 bd _ abd].
  have [db|db] /= := leP d b; last by rewrite ab.
  by move: ji; rewrite itv_leEmeet /= (join_l (ltW _))// meet_l// eqxx.
rewrite leNgt bd /=.
by move: abd; rewrite itv_leEmeet /= joinxx (meet_l (ltW _)) // eqxx.
Qed.

Lemma le_itv_diff i j : le_itv i j -> ~~ (j <= i)%O -> ~~ (i <= j)%O ->
  le_itv (itv_diff i j) j.
Proof.
rewrite /le_itv => /orP[/eqP <-{j}|]; first by rewrite lexx.
by move=> ab sba sab; apply/orP; right; exact: lt_itv_diff.
Qed.

Let lt_itv_itv_diff k i j : ~~ (j <= i)%O -> disjoint_itv k i ->
  lt_itv i j -> lt_itv k i -> lt_itv k j ->
  lt_itv k (itv_diff i j).
Proof.
move: k i j => [k1 k2] [a1 a2] [b1 b2] /=; rewrite /lt_itv /=.
case: (ltgtP a1 b1) => [a1b1 ba + _| // | <-{b1}].
  have a2b2 : (a2 < b2)%O.
    rewrite ltNge; apply: contra ba => b2a2.
    by rewrite itv_leEmeet /= (join_l (ltW _))// meet_l.
  move: ba a1b1; case: (ltgtP k1 a1) => [k1a1 _ a1b1 ya _ _|//|
                                        <-{a1} ba a1b1 ya /= k2a2 _].
    rewrite /itv_diff; case: ifPn => [_|ab0]; first by rewrite k1a1.
    by rewrite leNgt a1b1 /= leNgt a2b2 /= k1a1.
  rewrite /itv_diff; case: ifPn => [_|/negPn ab0]; first by rewrite ltxx eqxx.
  rewrite leNgt a1b1 /= leNgt a2b2 /= ltxx eqxx /= ltNge.
  apply: contraPN ya => b1k2 /disjoint_neitv/neitvP; apply => /=.
  by rewrite joinxx (meet_l (ltW k2a2)) (lt_le_trans a1b1).
case: (ltgtP k1 a1) => [k1a1 ab ya /= a2b2 _ _|//|
                       <-{a1} ab ya /= a2b2 k2a2 k2b2].
  rewrite /itv_diff; case: ifPn => [_|ab0]; first by rewrite k1a1.
  by rewrite lexx leNgt a2b2 /= (lt_le_trans k1a1) // bound_lex1.
rewrite /itv_diff; case: ifPn => [_|/negPn ab0]; first by rewrite ltxx eqxx.
rewrite lexx leNgt a2b2 /= (ltNge k2) bound_le0x andbF orbF ltNge.
apply: contraPN ab0; rewrite ge_pinfty => /eqP k1oo.
by rewrite neitvE /= k1oo join_r // neitv_lt_bnd.
Qed.

Let le_itv_itv_diff0 i j : [set` i] = set0 -> le_itv i (itv_diff i j).
Proof.
move=> i0.
by rewrite /itv_diff /neitv /= set_itv_meet i0 set0I negbK eqxx /le_itv eqxx.
Qed.

Lemma le_itv_itv_diff k i j : ~~ (j <= i)%O -> disjoint_itv k i ->
  le_itv i j -> le_itv k i -> le_itv k j ->
  le_itv k (itv_diff i j).
Proof.
move=> ji ki => /predU1P[ij|ij]; first by rewrite ij lexx in ji.
move=> /predU1P[ya|ya /predU1P[kj|kj]].
- move: ki; rewrite {}ya {k} => ii.
  have [a0 _|a0 _] := eqVneq [set` i] set0; first exact: le_itv_itv_diff0.
  by move: ii; rewrite /disjoint_itv setIid (negbTE a0).
- by move: ya; rewrite kj => /(lt_itv_trans _ _ _ ij); rewrite lt_itvxx.
- by apply/orP; right; exact: lt_itv_itv_diff.
Qed.

End lt_itv_diff.

Section lt_itv_disjoint.
Variable R : realType.

Lemma neitv_sorted_disj h (t : seq (interval R)) :
  all neitv t -> sorted le_itv (h :: t) -> path disjoint_itv h t ->
  (forall c, c \in t -> disjoint_itv h c).
Proof.
elim: t h => [h t0 _ _ c //|
             b t ih a t0 /= /andP[lt_ab lt_bt] /andP[dis_ab dis_bt] c].
rewrite inE => /orP[/eqP ->{c} //|ct]; apply: ih => //.
- by move: t0; rewrite /= => /andP[].
- by rewrite (mask_second b) (sorted_mask (@le_itv_trans _)) //= lt_ab.
- case: t => [//|d t] in t0 lt_bt dis_bt ct *.
  move: dis_bt; rewrite [in X in X -> _]/= => /andP[dis_bd dis_dt].
  rewrite /= {}dis_dt andbT.
  have {}lt_ab := le_itv_lt lt_ab dis_ab.
  move/andP : lt_bt => [+ _] => /le_itv_lt/(_ dis_bd) lt_bd.
  apply/lt_disjoint => x y xa yd.
  have /neitvP nb : neitv b by move: t0 => /= /andP[].
  by rewrite (@lt_trans _ _ (miditv b) _ _ (lt_ab _ _ _ _) (lt_bd _ _ _ _))//
    mem_miditv.
Qed.

Lemma neitv_sorted_disj_trivIset h (t : seq (interval R)) :
  all neitv t -> sorted le_itv (h :: t) -> path disjoint_itv h t ->
  trivIset setT (fun i => [set` nth 0%O (h :: t) i]).
Proof.
elim: t h => //= [h t0 _ _|
                 b t ih a /andP[b0 t0] /andP[lt_ab lt_bt] /andP[dis_ab dis_bt]].
  apply/trivIsetP => i j _ _ ij.
  case: i => [|i] /= in ij *.
    case: j => [|j] //= in ij *.
    by rewrite nth_nil set_itvE setI0.
  by rewrite nth_nil set_itvE set0I.
apply/trivIsetP => i j _ _; move: i j => [|i] [|j] //= ?.
- have [jbt|btj] := ltP j (size (b :: t)).
    apply/eqP/(@neitv_sorted_disj _ (b :: t)) => //=;
      by [rewrite b0|rewrite lt_ab|rewrite dis_ab|rewrite mem_nth].
  by rewrite nth_default // set_itvE setI0.
- have [ibt|bti] := ltP i (size (b :: t)).
    rewrite setIC.
    apply/eqP/(@neitv_sorted_disj _ (b :: t)) => //=;
      by [rewrite b0|rewrite lt_ab|rewrite dis_ab|rewrite mem_nth].
  by rewrite nth_default // set_itvE set0I.
- by have /trivIsetP := ih b t0 lt_bt dis_bt; apply.
Qed.

Lemma trivIset_disj_itv h (t : seq (interval R)) :
  trivIset setT (fun i => [set` nth 0%O (h :: t) i]) ->
  path disjoint_itv h t.
Proof.
elim: t h => // t1 t2 ih h /= /trivIsetP tsht1t2.
apply/andP; split.
  by move: (tsht1t2 O 1%N Logic.I Logic.I erefl) => /= /eqP.
apply ih => //; apply/trivIsetP => i j _ _ ij.
by move: (tsht1t2 i.+1 j.+1 Logic.I Logic.I); apply.
Qed.

Lemma sorted_le_itv_bound (s : seq (interval R)) :
  all neitv s -> sorted le_itv s -> path disjoint_itv (head 0%O s) (behead s) ->
  sorted <=%O (map bnd2eta s) /\ sorted <=%O (map bnd1eta s).
Proof.
elim: s => // -[h1 h2] [//|[t11 t12] t2] ih /= ne ht Hdis; split.
  apply/andP; split.
    case/andP : ht => + _.
    move/orP => -[/eqP[_ <-]//|].
    rewrite /lt_itv /=; case: ltgtP => //= [|_ /ltW] // h11t11 _.
    move/andP : Hdis => [H _].
    rewrite leNgt; apply/negP => t12h2.
    move: H; apply/negP/set0P.
    have : neitv (Interval t11 t12) by move/and3P : ne => [_].
    move=> /set0P[x t11t12x].
    exists x; split => //=.
    rewrite itv_boundlr.
    move: t11t12x; rewrite /= itv_boundlr => /andP[t11x xt12].
    by rewrite (le_trans (ltW _) t11x) // (le_trans xt12) // ltW.
  apply: (proj1 (ih _ _ _)).
  - by move/andP : ne => [].
  - by case/andP : ht => ? ht.
  - by rewrite /=; move/andP : Hdis => // -[].
apply/andP; split.
- move/andP : ht => -[] /orP[/eqP[<-//]|].
  by rewrite /lt_itv /=; case: ltgtP.
- apply: (proj2 (ih _ _ _)).
  + by move/andP : ne => [].
  + by case/andP : ht.
  + by rewrite /=; move/andP : Hdis => // -[].
Qed.

End lt_itv_disjoint.

Section decomposition.
Variable R : realType.
Implicit Types (i j : interval R) (s t : seq (interval R)).

Program Definition decompose' s
    (f : forall t, (size t < size s)%N -> seq (interval R)) :=
  match s with
  | [::] => [::] | [:: i] => [:: i]
  | [:: i, j & tl] => if (i <= j)%O then f (j :: tl) _ else
                    if (j <= i)%O then f (i :: tl) _ else
                    itv_diff i j :: f (j :: tl) _
  end.
Next Obligation. by move=> s _ i j tl <-. Qed.
Next Obligation. by move=> s _ i j tl <-. Qed.
Next Obligation. by move=> s _ i j tl <-. Qed.

Lemma decompose'_ext s
  (f g : forall t, (size t < size s)%N -> seq (interval R)) :
    (forall t (h : (size t < size s)%N), f t h = g t h) ->
  decompose' f = decompose' g.
Proof.
move=> fg; congr decompose'.
by apply functional_extensionality_dep => ?; apply functional_extensionality_dep.
Qed.

Lemma wf_size : well_founded (fun t s => (size t < size s)%N).
Proof. by apply: (@Wf_nat.well_founded_lt_compat _ size) => s t /ssrnat.ltP. Qed.

Definition sorted_decompose : seq (interval R) -> seq (interval R) :=
  Fix wf_size (fun _ => _ _) decompose'.

Lemma sorted_decompose_nil : sorted_decompose [::] = [::].
Proof. by rewrite /sorted_decompose Fix_eq //=; exact decompose'_ext. Qed.

Lemma sorted_decompose_one i : sorted_decompose [:: i] = [:: i].
Proof. rewrite /sorted_decompose Fix_eq //=; exact: decompose'_ext. Qed.

Lemma sorted_decompose_two i j t : sorted_decompose [:: i, j & t] =
  if (i <= j)%O then sorted_decompose (j :: t) else
  if (j <= i)%O then sorted_decompose (i :: t) else
  itv_diff i j :: sorted_decompose (j :: t).
Proof.
rewrite {1}/sorted_decompose Fix_eq; last exact: decompose'_ext.
by move: i j => [? ?] [? ?] //=; case: ifPn => //; case: ifPn.
Qed.

Lemma sorted_decompose_eq0 s : (sorted_decompose s == [::]) = (s == [::]).
Proof.
apply/idP/idP => [/eqP //|/eqP ->]; last by rewrite sorted_decompose_nil.
move Hn : (size s) => n.
elim: n s Hn => [[]//|n ih [//|i [|j t] [tn]]].
  by rewrite sorted_decompose_one.
rewrite sorted_decompose_two; case: ifPn => [_ /ih|ij].
  by move=> /(_ tn).
by case: ifPn => // ji /ih => /(_ tn).
Qed.

Lemma cover_sorted_decompose s :
  sorted le_itv s -> [sset of sorted_decompose s] = [sset of s].
Proof.
move sn : (size s) => n; elim: n s sn => [|n ih [//|i [|j t]]].
  by case=> // _ _; rewrite sorted_decompose_nil.
  by move=> _ _; rewrite sorted_decompose_one.
move=> [tn] /= /andP[le_ij le_jt]; rewrite sorted_decompose_two.
  case: ifPn => ij.
  rewrite /= ih // 3!sset_cons setUA; congr setU.
  by rewrite setUC; apply/esym/setUidPl/subitvP.
case: ifPn => ji.
  rewrite /= ih //; last first.
    by rewrite (mask_second j) (sorted_mask le_itv_trans) //= le_ij.
  by rewrite 3!sset_cons setUA; congr setU; apply/esym/setUidPl/subitvP.
rewrite (sset_cons _ (sorted_decompose (j :: t))) ih //.
rewrite [in RHS]sset_cons sset_cons !setUA; congr (_ `|` _).
rewrite set_itv_diff // ?ji// eqEsubset; split.
- apply: subsetU; last by move=> x; right.
  by move=> x ix; left; case: ix.
- move=> x [ix|jx]; last by right.
  by have [jx|jx] := pselect ([set` j] x); [right|left].
Qed.

Let neitv_diff i j :
  neitv i -> neitv j -> ~~ (i <= j)%O -> ~~ (j <= i)%O ->
  neitv (itv_diff i j).
Proof.
move: i j => [a b] [c d]; rewrite !neitvE /itv_diff !itv_leEmeet /= => ab cd.
rewrite neitvE /=.
rewrite -leNgt; case: ifPn => //=; rewrite -ltNge; case: (leP c a) => ca.
  rewrite ltxI ab /= => ad; case: (leP d b) => db /=; last by rewrite eqxx.
  by  rewrite lt_neqAle db andbT => + _; apply: contra => /eqP ->.
by rewrite ltxI cd andbT; case: (leP d b) => //=; rewrite eqxx.
Qed.

Lemma sorted_decompose_nonempty s : all neitv s -> all neitv (sorted_decompose s).
Proof.
move sn : (size s) => n; elim: n s sn => [|n ih [//|i [|j t]] ].
  by move=> s /size0nil ->{} _; rewrite sorted_decompose_nil.
  by move=> _ i0; rewrite sorted_decompose_one.
move=> [tn] /= /and3P[i0 j0 ne]; rewrite sorted_decompose_two.
case: ifPn => ij; first by rewrite ih //= ne andbT.
case: ifPn => ji; first by rewrite ih //= ne andbT.
apply/allP => k; rewrite inE => /orP[/eqP ->|]; first exact: neitv_diff.
by move: k; apply/allP; rewrite ih //= ne andbT.
Qed.

Let sorted_disj_itv i j t (ijt : sorted le_itv [:: i, j & t])
  (ij : ~~ (i <= j)%O) (ji : ~~ (j <= i)%O) :
  forall j0, j0 \in j :: t -> disjoint_itv (itv_diff i j) j0.
Proof.
move=> c cjtl.
apply/eqP; rewrite set_itv_diff ?ji//.
move: cjtl; rewrite inE => /orP[/eqP ->|ctl].
  by rewrite setDE -setIA setICl setI0.
rewrite predeqE => x; split => // -[].
rewrite setDE => -[] ix/negP jx cx.
have jc : le_itv j c.
  move: ctl; rewrite -sub1seq.
  move/subseq_path_in => /(_ le_itv j) /=; rewrite andbT; apply => //.
    by move=> ? ? ? ? ? ?; exact: le_itv_trans.
  by move: ijt => /= /andP[].
have le_ij : le_itv i j by move: ijt; rewrite /= => /andP[].
move/negP in ji; apply: ji.
have [|//] := le_itv_subset ix cx jx le_ij jc.
by rewrite (negbTE ij).
Qed.

Lemma path_disj_itv_sorted_decompose s : sorted le_itv s ->
  forall i, (forall j, j \in s -> disjoint_itv i j) ->
  path disjoint_itv i (sorted_decompose s).
Proof.
move sn : (size s) => n.
elim: n s sn => [|n ih [//|i [|j t]] []].
  by move=> _ /size0nil ->{} _ t tc; rewrite sorted_decompose_nil.
  by move=> _ _ t tc; rewrite sorted_decompose_one /= tc ?mem_head // eqxx.
case: n => [//|n] in ih * => -[] tn ijt k disj_k.
rewrite sorted_decompose_two; case: ifPn => ij.
  rewrite ih //= ?tn//; first by case/andP : ijt.
  by move=> c cjt; rewrite disj_k // inE cjt orbT.
case: ifPn => // ji.
  rewrite ih//; first by rewrite /= tn.
    by rewrite (mask_second j) (sorted_mask le_itv_trans).
  by move=> c; rewrite inE => citl; rewrite disj_k // !inE orbCA citl orbT.
rewrite /=; apply/andP; split.
  apply/eqP; rewrite set_itv_diff ?ji// setDE setIA.
  by rewrite (eqP (disj_k _ _)) ?set0I // mem_head.
rewrite ih //; first by rewrite /= tn.
  exact/(subseq_sorted le_itv_trans _ ijt)/subseq_cons.
exact: sorted_disj_itv.
Qed.

Lemma path_disj_itv_sorted_decompose_head_behead s : sorted le_itv s ->
  path disjoint_itv (head 0%O (sorted_decompose s))
                    (behead (sorted_decompose s)).
Proof.
move sn : (size s) => n.
elim: n s sn => [|n ih [//|i [|j t]] []].
  by move=> _ /size0nil ->{} _; rewrite sorted_decompose_nil.
  by move=> ic _; rewrite sorted_decompose_one /=.
case: n => [//|n] in ih *=> -[] tn ijt.
rewrite sorted_decompose_two; case: ifPn => ij.
  by rewrite ih//; [rewrite /= tn | case/andP : ijt].
case: ifPn => // ji.
  rewrite ih //; first by rewrite /= tn.
  by rewrite (mask_second j) (sorted_mask le_itv_trans).
rewrite /= path_disj_itv_sorted_decompose //; first by move: ijt => /= /andP[].
exact: sorted_disj_itv.
Qed.

Lemma all_sorted_decompose s y : sorted le_itv s ->
  all (fun x => le_itv y x && disjoint_itv y x) s ->
  all (fun x => le_itv y x && disjoint_itv y x) (sorted_decompose s).
Proof.
move: y.
have [n] := ubnP (size s); elim: n s => // n ih.
case; first by move=> _ k _ _; rewrite sorted_decompose_nil.
move=> i [|j t]; first by move=> m k _; rewrite sorted_decompose_one /= andbT.
move=> /=; rewrite ltnS => tn y /andP[le_ij le_jt].
move=> /and3P[/andP[yi iy] /andP[yj jy] yt'].
rewrite sorted_decompose_two; case: ifPn => [ij|ij].
  apply ih => //; apply/allP => z.
  rewrite inE => /orP[/eqP -> //| zt]; rewrite ?yj//.
  by move/allP : yt'; apply.
case: ifPn => ji.
  apply ih => //.
  - by rewrite (mask_second j) (sorted_mask le_itv_trans) //= le_ij.
  - apply/allP => z; rewrite inE => /orP[/eqP -> //|zt]; rewrite ?yi//.
    by move/allP : yt' ; apply.
apply/allP => z; rewrite inE => /orP[/eqP ->{z}|zbt]; last first.
  have : all (fun x => le_itv y x && (disjoint_itv y x))
             (sorted_decompose (j :: t)).
    apply ih => //; apply/allP => u.
    rewrite inE => /orP[/eqP -> //|ut]; rewrite ?yj//.
      by move/allP : yt'; apply.
    by move/allP; apply.
rewrite le_itv_itv_diff //= /disjoint_itv set_itv_diff ?ji//.
apply/eqP; apply: (@subsetI_eq0 _ _ [set` y] _ [set` i]) => //.
- by move=> x [].
- exact/eqP.
Qed.

Lemma sorted_sorted_decompose s : sorted le_itv s ->
  sorted le_itv (sorted_decompose s).
Proof.
have [n] := ubnP (size s); elim: n s => // n ih.
case; first by move=> _ _; rewrite sorted_decompose_nil.
move=> a [|b t]; first by move=> _ _; rewrite sorted_decompose_one.
rewrite ltnS => abtn abt.
rewrite sorted_decompose_two.
case: ifPn => ab.
  apply ih => //.
  by move: abt => /= /andP[].
case: ifPn => [ba|ba/=].
  by rewrite ih // (mask_second b) (sorted_mask le_itv_trans).
have bt : sorted le_itv (sorted_decompose (b :: t)).
  by apply ih => //; move: abt => /= /andP[].
rewrite path_min_sorted //.
have bt' : sorted le_itv (b :: t).
  by move: abt => /= /andP[].
have : all (fun x => le_itv (itv_diff a b) x && (disjoint_itv (itv_diff a b) x))
           (b :: t).
  rewrite /= le_itv_diff //=; last first.
    by move: abt => /= => /andP[].
  apply/andP; split.
    by apply/eqP; rewrite set_itv_diff ?ba// setDE -setIA setICl setI0.
  apply/allP => z zt.
  apply/andP; split.
    rewrite (@le_itv_trans _ b) //.
      apply le_itv_diff => //.
      by move: abt => /= /andP[].
    move: abt => /= /andP[_ bt''].
    by move/order_path_min : bt'' => /(_ le_itv_trans) /allP; apply.
  rewrite /disjoint_itv set_itv_diff ?ba//.
  apply/negPn/negP => /set0P[x] -[[] ].
  move=> xa bx zx.
  move: a b z => [a1 a2] [b1 b2] [z1 z2] in zt zx abtn abt ab ba bt bt' bx xa *.
  apply: bx => /=.
  rewrite /= !itv_boundlr in xa zx *.
  case/andP : zx => zx1 zx2.
  rewrite (le_trans _ zx1) //=; last first.
     have : le_itv (Interval b1 b2) (Interval z1 z2).
       have : path le_itv (Interval b1 b2) t by [].
       by move/order_path_min => /(_ le_itv_trans)/allP; apply.
     by rewrite /le_itv /lt_itv /= => /orP[/eqP[ <- //]|/=]; case: ltgtP.
   rewrite leNgt; apply/negP => b2x.
   case/andP : xa => xa1 xa2.
   move/negP : ba; apply.
   rewrite itv_leEmeet/= meet_l; last by rewrite (le_trans (ltW b2x)).
   rewrite join_l//.
   move: abt; rewrite /= /le_itv => /andP[/orP[/eqP[<- //]| /=]].
   by rewrite /lt_itv /=; case: ltgtP.
move/(@all_sorted_decompose (b :: t) (itv_diff a b) bt').
by apply: sub_all => z /andP[].
Qed.

Lemma trivIset_sorted_decompose s : sorted le_itv s -> all neitv s ->
  trivIset setT (fun k => [set` nth 0%O (sorted_decompose s) k]).
Proof.
move=> sorteds sne.
have [/size0nil -> |] := eqVneq (size (sorted_decompose s)) 0%N.
  by apply/trivIsetP => /= i j _ _ ij; rewrite nth_nil setitv0 set0I.
rewrite size_eq0 => s0.
rewrite -(cons_head_beheadE 0%O s0); apply: neitv_sorted_disj_trivIset.
- have := sorted_decompose_nonempty sne.
  by rewrite -(cons_head_beheadE 0%O s0) /= => /andP[].
- by rewrite cons_head_beheadE// sorted_sorted_decompose.
- suff: path disjoint_itv 0%O
      (head 0%O (sorted_decompose s) :: behead (sorted_decompose s)).
    by move => /andP[].
  rewrite cons_head_beheadE// path_disj_itv_sorted_decompose => // i si.
  by apply/eqP; rewrite setitv0 set0I.
Qed.

Definition decompose s := sorted_decompose (sort le_itv [seq x <- s | neitv x]).

Lemma decompose_set0 (s : seq (interval R)) :
  [sset of s] = set0 -> forall i, i \in decompose s -> [set` i] = set0.
Proof.
move=> s0 i si; rewrite predeqE => x; split => // xi.
have : [sset of decompose s] = [sset of s].
  rewrite /decompose cover_sorted_decompose.
    by rewrite sset_sort_le_itv sset_filter_neitv.
  exact: (sort_sorted total_le_itv).
by rewrite s0 =>/eqP; apply/negP/set0P; exists x; rewrite sset_bigcup; exists i.
Qed.

Lemma itv_cplt_decomposeE s :
  [sset of itv_cplt_ne (decompose s)] = ~` [sset of s].
Proof.
have [sne ssorted sdisj] : [/\ all neitv (decompose s),
    sorted le_itv (decompose s) &
    path disjoint_itv (head 0%O (decompose s)) (behead (decompose s))].
  split.
  - rewrite sorted_decompose_nonempty // all_sort; apply/allP => i.
    by rewrite mem_filter => /andP[].
  - exact/sorted_sorted_decompose/(sort_sorted total_le_itv).
  - apply/path_disj_itv_sorted_decompose_head_behead.
    exact/(sort_sorted total_le_itv).
have [sdec1 sdec2] := sorted_le_itv_bound sne ssorted sdisj(*TODO*).
rewrite itv_cplt_neE // cover_sorted_decompose.
  by rewrite sset_sort_le_itv // sset_filter_neitv.
exact: (sort_sorted total_le_itv).
Qed.

Definition is_decomposition s : seq (interval R) -> Prop :=
  fun x => [/\ sorted le_itv x,
           path disjoint_itv (head 0%O x) (behead x) &
           [sset of x] = [sset of s] ].

Lemma is_decomposition_decompose s : is_decomposition s (decompose s).
Proof.
split.
- exact/sorted_sorted_decompose/(sort_sorted total_le_itv).
- apply: path_disj_itv_sorted_decompose_head_behead.
  exact/(sort_sorted total_le_itv).
- rewrite (cover_sorted_decompose (sort_sorted total_le_itv _)).
  by rewrite sset_sort_le_itv sset_filter_neitv.
Qed.

Lemma mem_decompose (j : interval R) s (r : R) : j \in s -> [set` j] r ->
  exists j', j' \in decompose s /\ [set` j'] r.
Proof.
move=> js jr.
have : [sset of s] r by rewrite sset_bigcup; exists j.
have [_ _] := is_decomposition_decompose s.
by move=> <-; rewrite sset_bigcup => -[j' sj' j'r]; exists j'.
Qed.

Lemma trivIset_decompose s :
  trivIset setT (fun k => [set` nth 0%O (decompose s) k]).
Proof.
have [->|s0] := eqVneq (decompose s) [::].
  by apply/trivIsetP => i j _ _ ?; rewrite nth_nil set_itvE set0I.
rewrite -(cons_head_beheadE 0%O s0); apply: neitv_sorted_disj_trivIset.
- apply/allP => /= j /mem_behead; rewrite /decompose.
  set s' := sort _ _.
  have /sorted_decompose_nonempty/allP sne : all neitv s'.
    by rewrite all_sort all_filter; apply/allP => i ia /=; exact: implybb.
  by move/sne.
- by rewrite cons_head_beheadE //; have [] := is_decomposition_decompose s.
- by have [] := is_decomposition_decompose s.
Qed.

Lemma decompose_nonempty s : all neitv (decompose s).
Proof.
rewrite /decompose; apply/sorted_decompose_nonempty.
by rewrite all_sort; apply/allP => i; rewrite mem_filter => /andP[].
Qed.

Lemma decompose_nil : decompose [::] = [::].
Proof. by rewrite /decompose /= sortE /= sorted_decompose_nil. Qed.

End decomposition.
Arguments decompose {R}.

Module Sset.
Section is_sset.
Variable R : realType.
Implicit Types A B : set R.

Definition is_sset A : Prop := exists s, A = [sset of s].

Lemma is_sset0 : is_sset set0. Proof. by exists fset0; rewrite sset_nil. Qed.

Lemma is_ssetU A B : is_sset A -> is_sset B -> is_sset (A `|` B).
Proof.
move=> [a aA] [b bB]; exists (a ++ b)%fset.
rewrite eqEsubset; split => [r [Ar|Br]|r].
  move: Ar; rewrite aA => /ssetP[/= j ja jr].
  by apply/ssetP; exists j => //; rewrite /mkset mem_cat ja.
  move: Br; rewrite bB => /ssetP[/= j jb jr].
  by apply/ssetP; exists j => //; rewrite /mkset mem_cat jb orbT.
move/ssetP => [j]; rewrite /mkset mem_cat => /orP[ja|jb] jr.
by left; rewrite aA; apply/ssetP; exists j.
by right; rewrite bB; apply/ssetP; exists j.
Qed.

Lemma is_ssetC A : is_sset A -> is_sset (~` A).
Proof.
move=> [a aA]; set s := itv_cplt_ne (decompose a).
exists [fset x | x in s]%fset; rewrite (@sseti _ _ s).
  by rewrite itv_cplt_decomposeE aA.
by move=> i; rewrite inE.
Qed.

End is_sset.

Section algebra_of_sets_instance.
Variable R : realType.

HB.instance Definition sset_algebraOfSets :=
  @isAlgebraOfSets.Build (Real.sort R) (@is_sset R)
  (@is_sset0 R) (@is_ssetU R) (@is_ssetC R).

Definition sset_algebraOfSetsType := [the algebraOfSetsType of (Real.sort R)].

Lemma is_sset_itv (i : interval R) : is_sset [set` i].
Proof. by exists [:: i]; rewrite sset_cons1. Qed.

Lemma is_sset_sset (s : seq (interval R)) : is_sset [sset of s].
Proof.
apply: (@bigsetU_measurable sset_algebraOfSetsType) => i _.
exact: is_sset_itv.
Qed.

End algebra_of_sets_instance.
End Sset.
Notation sset_algebraOfSetsType := Sset.sset_algebraOfSetsType.

Section conv_Rhull.
Variable R : realType.
Implicit Types (a b t r : R) (A : set R).

Lemma N01 t : (0 <= t <= 1) = (0 <= 1 - t <= 1).
Proof.
apply/idP/idP => /andP[t0 t1]; apply/andP; split; first by rewrite subr_ge0.
by rewrite ler_subl_addr addrC -ler_subl_addr subrr.
by move: t1; rewrite ler_subl_addr addrC -ler_subl_addr subrr.
by move: t0; rewrite subr_ge0.
Qed.

Definition conv t a b : R := (1 - t) * a + t * b.

Lemma conv0 a b : conv 0 a b = a.
Proof. by rewrite /conv subr0 mul1r mul0r addr0. Qed.

Lemma conv1 a b : conv 1 a b = b.
Proof. by rewrite /conv subrr mul0r add0r mul1r. Qed.

Lemma convN a b t : conv t a b = conv (1 - t) b a.
Proof. by rewrite /conv opprB addrCA subrr addr0 addrC. Qed.

Lemma le_conv a b t : a <= b -> 0 <= t <= 1 -> a <= conv t a b <= b.
Proof.
move=> ab /andP[].
rewrite le_eqVlt => /predU1P[/esym ->{t} _|t0]; first by rewrite conv0 lexx.
rewrite le_eqVlt => /predU1P[->{t0 t}|t1]; first by rewrite conv1 lexx andbT.
have t1t : 1 - t + t = 1 by rewrite subrK.
rewrite /conv; apply/andP; split.
  by rewrite -{1}(mul1r a) -{1}t1t [in X in X <= _]mulrDl ler_add // ler_pmul2l.
rewrite -{2}(mul1r b) -{2}t1t [in X in _ <= X]mulrDl ler_add // ler_pmul2l //.
by rewrite subr_gt0.
Qed.

Definition factor a b x := (x - a) / (b - a).

Lemma factor01 a b x : a != b -> a <= x -> x <= b -> 0 <= factor a b x <= 1.
Proof.
move=> ab ax xb; rewrite divr_ge0 // ?subr_ge0 // ?(le_trans ax) //=.
by rewrite ler_pdivr_mulr ?mul1r ?ler_sub// subr_gt0 lt_neqAle ab (le_trans ax).
Qed.

Lemma conv_factor a b x : a != b -> conv (factor a b x) a b = x.
Proof.
move=> ab; rewrite /conv -(@divff _ (b - a)) ?subr_eq0 1?eq_sym// -mulrBl.
rewrite opprB addrA subrK mulrAC (mulrAC (x - a)) -mulrDl 2!mulrBl.
rewrite -addrA (addrC (b * a)) -addrA (mulrC a b) subrK.
by rewrite -mulrN addrC -mulrDr -mulrA mulfV ?mulr1 // subr_eq0 eq_sym.
Qed.

Lemma conv_subset_Rhull A :
  [set x | exists a b t, [/\ A a, A b, 0 <= t <= 1 & x = conv t a b]]
    `<=` [set` Rhull A].
Proof.
move=> r -[a [b [t [Aa Ab /andP[t0 t1] ->{r}]]]].
have iRhullA := @interval_is_interval _ (Rhull A).
have [ab|/ltW ba] := leP a b.
  apply: (iRhullA a b); rewrite ?set_itv_mem; try exact/sub_Rhull.
  by rewrite le_conv // t0.
apply: (iRhullA b a); rewrite ?set_itv_mem; try exact/sub_Rhull.
by rewrite convN le_conv => //; rewrite -N01 t0.
Qed.

Lemma Rhull_subset_conv A : A !=set0 -> [set` Rhull A] `<=`
  [set x | exists a b t, [/\ A a, A b, 0 <= t <= 1 & x = conv t a b]].
Proof.
move=> A0 r; rewrite /Rhull; set i : R := inf A; set s : R := sup A.
have [|] := asboolP (has_lbound A) => lA.
- have [|]:= asboolP (has_ubound A) => uA.
  + have [|] := asboolP (A i) => Ai.
    * have [|] := asboolP (A s) => As; rewrite /= in_itv /= => /andP[ir rs].
      - have [si|si] := eqVneq i s.
        + have /eqP <- : i == r by rewrite eq_le {2}si ir.
          by exists i, s, 0; rewrite conv0 lexx ler01.
        + by exists i, s, (factor i s r); rewrite factor01 // conv_factor.
      - pose e := s - r.
        have [u ? seu] : exists2 u, A u & s - e < u.
          by apply sup_adherent; rewrite ?subr_gt0.
        have ? : i < u.
          rewrite (le_lt_trans _ seu)// (le_trans ir)// opprB addrCA subrr.
          by rewrite addr0.
        exists i, u, (factor i u r); rewrite factor01 ?conv_factor// ?lt_eqF//.
        by rewrite (le_trans _ (ltW seu))// /e opprB addrCA subrr addr0.
    * have [|] := asboolP (A s) => As; rewrite /= in_itv /= => /andP[ir rs].
      - pose e := r - i.
        have [l ? lie] : exists2 l, A l & l < i + e.
          by apply inf_adherent; rewrite ?subr_gt0.
        have ? : l < s.
          by rewrite (lt_le_trans lie)// (le_trans _ rs)// addrCA subrr addr0.
        exists l, s, (factor l s r); rewrite factor01// ?conv_factor// ?lt_eqF//.
        by rewrite (le_trans (ltW lie)) // /e addrCA subrr addr0.
      - pose e := ((r - i) `&` (s - r))%O.
        have [u ? seu] : exists2 u, A u & s - e < u.
          by apply sup_adherent; rewrite ?ltxI 2?subr_gt0 ?ir.
        have [l ? lie] : exists2 l, A l & l < i + e.
          by apply inf_adherent; rewrite ?ltxI 2?subr_gt0 ?ir.
        have ? : i + e <= r by rewrite -ler_sub_addl leIx lexx.
        have ? : r <= s - e.
          by rewrite -ler_sub_addr opprK -ler_sub_addl leIx lexx orbT.
        have ? : l < u.
           rewrite (lt_le_trans lie)// (le_trans _ (ltW seu))//.
           by rewrite (@le_trans _ _ r).
        exists l, u, (factor l u r); rewrite factor01// ?conv_factor// ?lt_eqF//.
          by rewrite (le_trans (ltW lie)).
        by rewrite (le_trans _ (ltW seu)).
  + have [|] := asboolP (A i) => /= Ai; rewrite in_itv /= andbT => ir.
    * have [u Au ru] : exists2 u, A u & r < u by move/has_ubPn : uA => /(_ r).
      have ? : i < u by rewrite (le_lt_trans ir).
      exists i, u, (factor i u r).
      by rewrite factor01// ?conv_factor // ?lt_eqF// ltW.
    * pose e := r - i.
      have [l ? lie] : exists2 l, A l & l < i + e
        by apply inf_adherent; rewrite ?subr_gt0.
      have [u ? ru] : exists2 u, A u & r < u
        by move/has_ubPn : uA => /(_ r).
      have ? : l < u by rewrite (lt_le_trans lie) // addrCA subrr addr0 ltW.
      have ? : l <= r by rewrite (le_trans (ltW lie)) // addrCA subrr addr0.
      exists l, u, (factor l u r).
      by rewrite factor01// ?conv_factor// ?lt_eqF// ltW.
- have [|] := asboolP (has_ubound A) => uA; last move=> _.
  + have [|] := asboolP (A s) => /= As; rewrite in_itv /= => rs.
    * have [l ? lr] : exists2 l, A l & l < r by move/has_lbPn : lA => /(_ r).
      have ? : l < s by rewrite (lt_le_trans lr).
      exists l, s, (factor l s r).
      by rewrite factor01// ?conv_factor// ?lt_eqF// ltW.
    * pose e := s - r.
      have [u ? seu] : exists2 u, A u & s - e < u.
        by apply sup_adherent; rewrite ?subr_gt0.
      have [l ? lr] : exists2 l, A l & l < r by move/has_lbPn : lA => /(_ r).
      have ? : l < u.
        rewrite (le_lt_trans _ seu)// (le_trans (ltW lr))// opprB addrCA.
        by rewrite subrr addr0.
      have ? : r <= u.
        by rewrite (le_trans _ (ltW seu))// opprB addrCA subrr addr0.
      exists l, u, (factor l u r).
      by rewrite factor01// ?conv_factor// ?lt_eqF// ltW.
  + have [l ? lr] : exists2 l, A l & l < r by move/has_lbPn : lA => /(_ r).
    have [u ? ru] : exists2 u, A u & r < u by move/has_ubPn : uA => /(_ r).
    have ? : l < u by rewrite (lt_trans lr).
    exists l, u, (factor l u r).
    by rewrite factor01// ?conv_factor// ?lt_eqF// ltW.
Qed.

Lemma le_Rhull : {homo (@Rhull R) : A B / (A `<=` B) >-> {subset A <= B}}.
Proof.
move=> A; have [A0 B AB r|/set0P A0 B AB r] := eqVneq A set0.
  by rewrite A0 Rhull0 in_itv /= lt_asym.
move/(Rhull_subset_conv A0) => -[a [b [t [Aa Ab /andP[t0 t1] ->]]]].
by apply/conv_subset_Rhull; exists a, b, t; rewrite t0 t1; split=> //; exact/AB.
Qed.

Lemma neitv_Rhull A : ~~ neitv (Rhull A) -> A = set0.
Proof.
move/negPn/eqP => A0; rewrite predeqE => r; split => // /sub_Rhull.
by rewrite A0.
Qed.

Lemma Rhull_involutive A : Rhull [set` Rhull A] = Rhull A.
Proof.
have [A0|/neitv_Rhull] := boolP (neitv (Rhull A)); first by rewrite set_itvK.
by move=> ->; rewrite ?Rhull0 set_itvE Rhull0.
Qed.

End conv_Rhull.

Coercion ereal_of_itv_bound T (b : itv_bound T) : \bar T :=
  match b with BSide _ y => y%:E | +oo%O => +oo%E | -oo%O => -oo%E end.
Arguments ereal_of_itv_bound T !b.

Lemma le_bnd_ereal (R : realDomainType) (a b : itv_bound R) :
  (a <= b)%O -> (a <= b)%E.
Proof.
move: a b => -[[] a|[]] [bb b|[]] //=; rewrite ?(lee_pinfty,lee_ninfty)//.
  by rewrite BLeft_BSide_leE lee_fin.
by case: bb => //; rewrite BRight_BLeft_leE => /ltW; rewrite lee_fin.
Qed.

Lemma lt_ereal_bnd (R : realDomainType) (a b : itv_bound R) :
  (a < b)%E -> (a < b)%O.
Proof.
by move: a b => -[[] a|[]] [[] b|[]] //=;
  rewrite ?(lee_pinfty,lee_ninfty,lte_fin)// => ab; rewrite lte_bnd ltW.
Qed.

(* TODO: move *)
Section cover_trivIset.
Variable R : realType.

Lemma perm_subset_set_itv_nth (D : set nat) (s s' : seq (interval R)) :
  [set k | (k < size s)%N] `<=` D -> perm_eq s s' ->
  [set [set` nth 0%O s i] | i in D] `<=`
    [set [set` nth 0%O s' i] | i in D].
Proof.
move=> sD ss' A [i Di iA].
have [/(mem_nth 0%O)|si] := ltnP i (size s); last first.
  move: iA; rewrite nth_default // => <-.
  by exists i => //; rewrite nth_default // -(perm_size ss').
move/perm_mem : (ss') => ->.
move/(nthP 0%O) => [j js' ji]; exists j; last by rewrite ji.
by apply sD; rewrite (perm_size ss').
Qed.

Lemma perm_set_itv_nth (D : set nat) (s s' : seq (interval R)) :
  [set k | (k < size s)%N] `<=` D -> perm_eq s s' ->
  [set [set` nth 0%O s i] | i in D] =
    [set [set` nth 0%O s' i] | i in D].
Proof.
move=> sD ss'; rewrite eqEsubset; split; apply perm_subset_set_itv_nth => //.
by rewrite -(perm_size ss').
by rewrite perm_sym.
Qed.

Lemma cover_set_itv_nth_sort (D : set nat) (s : seq (interval R)) :
  [set k | (k < size s)%N] `<=` D ->
  cover D (fun n => [set` nth 0%O s n]) =
  cover D (fun n => [set` nth 0%O (sort le_itv s) n]).
Proof.
move=> sD; apply: eqcover_r; apply: perm_set_itv_nth => //.
by rewrite perm_sym perm_sort.
Qed.

Lemma cover_set_itv_nthE (s : seq (interval R)) (D : set nat) :
  [set k | (k < size s)%N] `<=` D ->
  cover D (fun n => [set` nth 0%O s n]) = \big[setU/set0]_(i <- s) [set` i].
Proof.
move=> sD; rewrite eqEsubset; split => [r [i Di ri]|r].
- rewrite -bigcup_set; exists (nth 0%O s i) => //; apply/mem_nth.
  by rewrite ltnNge; apply: contraPN ri => si; rewrite nth_default.
- rewrite -bigcup_set => -[/= i /(nthP 0%O)[k ks <-{i} kr]]; exists k => //.
  exact: sD.
Qed.

Lemma trivIset_itv_meet (s : seq (interval R)) (i : interval R) :
  trivIset setT (fun n => [set` nth 0%O s n]) ->
  trivIset setT (fun n => [set` nth 0%O [seq itv_meet i j | j <- s] n]).
Proof.
move=> tJ.
rewrite -(@trivIset_restr _ _ _ [set k | (k < size s)%N]) //; last first.
  move=> k _ /negP; rewrite -leqNgt => Jk.
  by rewrite nth_default ?size_map// set_itvE.
apply/trivIsetP => a b aJ bJ ab.
rewrite (nth_map 0%O) // (nth_map 0%O) // !set_itv_meet setIACA setIid.
by move/trivIsetP : tJ => -> //; rewrite setI0.
Qed.

End cover_trivIset.

Section hlength.
Local Open Scope ereal_scope.
Variable R : realType.
Implicit Types i j : interval R.

Definition hlength (A : set R) : \bar R := let i := Rhull A in i.2 - i.1.

Lemma hlength0 : hlength (set0 : set R) = 0.
Proof. by rewrite /hlength Rhull0 /= subee. Qed.

Lemma hlength_singleton (r : R) : hlength `[r, r] = 0.
Proof.
rewrite /hlength /= asboolT // sup_itvcc //= asboolT//.
by rewrite asboolT ?inf_itvcc//= ?subee// inE.
Qed.

Lemma hlength_itv i : hlength [set` i] = if i.2 > i.1 then i.2 - i.1 else 0.
Proof.
case: ltP => [/lt_ereal_bnd/neitvP i12|]; first by rewrite /hlength set_itvK.
rewrite le_eqVlt => /orP[|/lt_ereal_bnd i12]; last first.
  rewrite (_ : [set` i] = set0) ?hlength0//.
  by apply/eqP/negPn; rewrite -/(neitv _) neitvE -leNgt (ltW i12).
case: i => -[ba a|[|]] [bb b|[|]] //=.
- rewrite /= => /eqP[->{b}]; move: ba bb => -[] []; try
    by rewrite set_itvE hlength0.
  by rewrite hlength_singleton.
- by move=> _; rewrite set_itvE hlength0.
- by move=> _; rewrite set_itvE hlength0.
Qed.

Lemma hlength_setT : hlength setT = +oo%E :> \bar R.
Proof. by rewrite -set_itv_infty_infty hlength_itv. Qed.

Lemma hlength_finite_fin_num i : neitv i -> hlength [set` i] < +oo ->
  ((i.1 : \bar R) \is a fin_num) /\ ((i.2 : \bar R) \is a fin_num).
Proof.
move: i => [[ba a|[]] [bb b|[]]] /neitvP //=; do ?by rewrite ?set_itvE ?eqxx.
by move=> _; rewrite hlength_itv /= lte_pinfty.
by move=> _; rewrite hlength_itv /= lte_ninfty.
by move=> _; rewrite hlength_itv /=.
Qed.

Lemma finite_hlengthE i : neitv i -> hlength [set` i] < +oo ->
  hlength [set` i] = (fine i.2)%:E - (fine i.1)%:E.
Proof.
move=> i0 ioo; have [ri1 ri2] := hlength_finite_fin_num i0 ioo.
rewrite !fineK// hlength_itv; case: ifPn => //.
rewrite -leNgt le_eqVlt => /predU1P[->|]; first by rewrite subee.
by move/lt_ereal_bnd/ltW; rewrite leNgt; move: i0 => /neitvP => ->.
Qed.

Lemma hlength_infty_bnd b r :
  hlength [set` Interval -oo%O (BSide b r)] = +oo :> \bar R.
Proof. by rewrite hlength_itv /= lte_ninfty. Qed.

Lemma hlength_bnd_infty b r :
  hlength [set` Interval (BSide b r) +oo%O] = +oo :> \bar R.
Proof. by rewrite hlength_itv /= lte_pinfty. Qed.

Lemma pinfty_hlength i : hlength [set` i] = +oo ->
  (exists s r, i = Interval -oo%O (BSide s r) \/ i = Interval (BSide s r) +oo%O)
  \/ i = `]-oo, +oo[.
Proof.
rewrite hlength_itv; case: i => -[ba a|[]] [bb b|[]] //= => [|_|_|].
- by case: ifPn.
- by left; exists ba, a; right.
- by left; exists bb, b; left.
- by right.
Qed.

Lemma hlength_ge0 i : 0 <= hlength [set` i].
Proof.
rewrite hlength_itv; case: ifPn => //; case: (i.1 : \bar _) => [r| |].
- by rewrite suber_ge0//; exact: ltW.
- by rewrite ltNge lee_pinfty.
- by case: (i.2 : \bar _) => //= [r _|]; rewrite lee_pinfty.
Qed.
Local Hint Extern 0 (0%:E <= hlength _) => solve[apply: hlength_ge0] : core.

Lemma hlength_Rhull (A : set R) : hlength [set` Rhull A] = hlength A.
Proof. by rewrite /hlength Rhull_involutive. Qed.

Lemma le_hlength_itv i j : {subset i <= j} -> hlength [set` i] <= hlength [set` j].
Proof.
set I := [set` i]; set J := [set` j].
have [->|/set0P I0] := eqVneq I set0; first by rewrite hlength0 hlength_ge0.
have [J0|/set0P J0] := eqVneq J set0.
  by move/subset_itvP; rewrite -/J J0 subset0 -/I => ->.
move=> /subset_itvP ij; apply: lee_sub => /=.
  have [ui|ui] := asboolP (has_ubound I).
    have [uj /=|uj] := asboolP (has_ubound J); last by rewrite lee_pinfty.
    by rewrite lee_fin le_sup // => r Ir; exists r; split => //; apply: ij.
  have [uj /=|//] := asboolP (has_ubound J).
  by move: ui; have := subset_has_ubound ij uj.
have [lj /=|lj] := asboolP (has_lbound J); last by rewrite lee_ninfty.
have [li /=|li] := asboolP (has_lbound I); last first.
  by move: li; have := subset_has_lbound ij lj.
rewrite lee_fin ler_oppl opprK le_sup// ?has_inf_supN//; last first.
  by case: I0 => x Ix; exists (- x)%R, x.
move=> r [r' Ir' <-{r}]; exists (- r')%R.
by split => //; exists r' => //; apply: ij.
Qed.

Lemma le_hlength : {homo hlength : A B / (A `<=` B) >-> A <= B}.
Proof.
move=> a b /le_Rhull /le_hlength_itv.
by rewrite (hlength_Rhull a) (hlength_Rhull b).
Qed.

End hlength.
Arguments hlength {R}.
Hint Extern 0 (0%:E <= hlength _) => solve[apply: hlength_ge0] : core.

Lemma IntervalE (R : numDomainType) (i : interval R) : i = Interval i.1 i.2.
Proof. by case: i. Qed.

Section le_disj_itv.
Variable R : realType.
Implicit Types i j : interval R.

Lemma le_itv_disj_bnd2_bnd1 i j : neitv i -> neitv j -> le_itv i j ->
  disjoint_itv i j -> (i.2 <= j.1)%O.
Proof.
move=> i0 j0 le_ij dis_ij; rewrite leNgt; apply/negP => j1i2.
move: (dis_ij); apply/negP.
move: (le_ij) => /predU1P[<-|lt_ij]; first by rewrite disjoint_itvxx.
rewrite /disjoint_itv -set_itv_meet (IntervalE i) (IntervalE j).
have : (i.1 <= j.1)%O by exact: le_itv_bnd1.
rewrite /lt_itv le_eqVlt => /predU1P[i1j1|i1j1] /=.
  move: lt_ij; rewrite /lt_itv {}i1j1 ltxx eqxx/= => {}i2j2.
  by apply/neitvP => /=; rewrite join_l// meet_l//; exact/ltW.
by rewrite (join_r (ltW i1j1)) meet_l//; [exact/neitvP|exact: le_itv_bnd2].
Qed.

Let le_itv_disj_bndNinfty i j : neitv i -> neitv j -> le_itv i j ->
  disjoint_itv i j -> j.1 != -oo%O /\ i.2 != +oo%O.
Proof.
move=> i0 j0 ij disj_ij.
have i2j1 := le_itv_disj_bnd2_bnd1 i0 j0 ij disj_ij.
split; apply: contraTN i2j1 => /eqP ->.
- by move/neitvP: i0; rewrite -ltNge; exact: le_lt_trans.
- by move/neitvP: j0; rewrite -ltNge => /lt_le_trans; apply; rewrite bound_lex1.
Qed.

Lemma le_itv_disj_bnd2r i j : neitv i -> neitv j -> le_itv i j ->
  disjoint_itv i j -> exists b r, i.2 = BSide b r.
Proof.
move=> i0 j0 les ts.
move i2E : (i.2) => i2; case: i2 => [b i2|[]] in i2E *; first by exists b, i2.
- have := @neitv_bnd2 _ [:: i]; rewrite all_seq1 => /(_ i0 i).
  by rewrite mem_seq1 eqxx => /(_ isT); rewrite i2E eqxx.
- have [] := le_itv_disj_bndNinfty i0 j0 les ts.
  by rewrite i2E.
Qed.

Lemma le_itv_disj_bnd1r i j : neitv i -> neitv j -> le_itv i j ->
  disjoint_itv i j -> exists b a, j.1 = BSide b a.
Proof.
move=> i0 j0 sle str.
move i1E : (j.1) => i1; case: i1 => [b i1|[]] in i1E *; first by exists b, i1.
- have [] := le_itv_disj_bndNinfty i0 j0 sle str.
  by rewrite i1E.
- have := @neitv_bnd1 _ [:: j]; rewrite all_seq1 => /(_ j0 j).
  by rewrite mem_seq1 eqxx => /(_ isT); rewrite i1E eqxx.
Qed.

Lemma le_itv_disj_contiguous i j : neitv i -> neitv j -> le_itv i j ->
  disjoint_itv i j -> is_interval ([set` i] `|` [set` j]) -> contiguous_itv i j.
Proof.
move=> ine jne ij dij itvij.
rewrite /contiguous_itv eq_le le_itv_disj_bnd2_bnd1//=.
have [b [x bx]] := le_itv_disj_bnd2r ine jne ij dij.
have [c [y cy]] := le_itv_disj_bnd1r ine jne ij dij.
set m := (x + y) / 2.
rewrite leNgt bx cy; apply/negP => xy.
have xyW : x <= y.
  by move: b c {cy bx} xy => [] [] /=; rewrite lte_bnd // => /ltW.
have xys : Interval (BSide b x) (BSide c y) \in itv_cplt [:: i; j].
  rewrite /itv_cplt; apply/mapP; exists (BSide b x, BSide c y) => //.
  apply/(nthP (+oo%O, -oo%O)); exists 1%N; first by rewrite size_zip.
  by rewrite !nth_zip //= -bx -cy.
have : m \in [sset of itv_cplt [:: i; j]].
  rewrite sset_bigcup inE; exists (Interval (BSide b x) (BSide c y)) => //=.
  by rewrite /m -/(miditv (Interval (BSide b x) (BSide c y))) mem_miditv.
rewrite itv_cpltE /= ?andbT; [|exact: le_itv_bnd2|exact: le_itv_bnd1].
rewrite inE; apply; rewrite sset_cons sset_cons1.
set midi := miditv i; set midj := miditv j.
move: itvij => /(_ midi midj); apply.
- by left; rewrite /= mem_miditv //; exact/neitvP.
- by right; rewrite /= mem_miditv //; exact/neitvP.
- move/neitvP in ine; move/neitvP in jne.
  have := miditv_bnd2 ine b; rewrite bx BSide_leE -/midi => midix.
  have := miditv_bnd1 jne c; rewrite cy BSide_leE -/midj => midjy.
  by rewrite (le_trans midix) /= ?midf_le// (le_trans _ midjy) //= midf_le.
Qed.

End le_disj_itv.

Section hlength_setU.
Local Open Scope ereal_scope.
Variable R : realType.
Implicit Types (i j : interval R) (A B : set R).

Lemma Rhull_setU2 A B : B !=set0 -> A `&` B = set0 ->
  is_interval A -> is_interval B -> lt_itv (Rhull A) (Rhull B) ->
  (Rhull (A `|` B)).2 = (Rhull B).2.
Proof.
move=> B0 AB0 iA iB AB /=.
have [|] := asboolP (has_ubound (A `|` B)) => uAB; last first.
  rewrite asboolF //; apply: contra_not uAB => -[x Bx].
  exists x => z [Az|Bz]; last exact: Bx.
  case: B0 => b0 Bb0; rewrite (@le_trans _ _ b0) //; last exact: Bx.
  apply/ltW/(lt_itv_lt AB) => //; [|exact: sub_Rhull|exact: sub_Rhull].
  by rewrite disj_itv_Rhull.
have uB : has_ubound B.
  by case: uAB => x ABx; exists x => y By; apply ABx; right.
rewrite (asboolT uB) // sup_setU //; last first.
  move=> a b Aa Bb.
  apply/ltW/(lt_itv_lt AB) => //; [|exact: sub_Rhull|exact: sub_Rhull].
  by rewrite disj_itv_Rhull.
congr (BSide (~~ `[< _ >]) _).
rewrite propeqE; split; last by right.
case => // AsB.
exfalso; move/set0P : B0 => /negP; apply; apply/eqP.
rewrite predeqE => x; split => // Bx.
have : (sup B < x)%R.
  apply: (lt_itv_lt AB) => //; [|exact: sub_Rhull|exact: sub_Rhull].
  by rewrite disj_itv_Rhull.
by apply/negP; rewrite -leNgt; exact: sup_ub.
Qed.

Lemma Rhull_setU1 A B : A !=set0 -> A `&` B = set0 ->
  is_interval A -> is_interval B -> lt_itv (Rhull A) (Rhull B) ->
  (Rhull (A `|` B)).1 = (Rhull A).1.
Proof.
move=> A0 AB0 iA iB AB /=.
have [|] := asboolP (has_lbound (A `|` B)) => uAB; last first.
  rewrite asboolF //.
  apply: contra_not uAB => -[x Ax].
  exists x => y [Ay|By]; first exact: Ax.
  case: A0 => a0 Aa0.
  rewrite (@le_trans _ _ a0) //; first exact: Ax.
  apply/ltW/(lt_itv_lt AB); [|exact: sub_Rhull|exact: sub_Rhull].
  by rewrite disj_itv_Rhull.
have lA : has_lbound A.
  case: uAB => x ABx.
  by exists x => y Ay; apply ABx; left.
rewrite (asboolT lA) // inf_setU //; last first.
  move=> a b Aa Bb.
  apply/ltW/(lt_itv_lt AB) => //; [|exact: sub_Rhull|exact: sub_Rhull].
  by rewrite disj_itv_Rhull.
congr (BSide (`[< _ >]) _).
rewrite propeqE; split; last by left.
case => // AsB.
exfalso; move: A0 => [a0 A0].
have : (a0 < inf A)%R.
  apply: (lt_itv_lt AB) => //; [|exact: sub_Rhull|exact: sub_Rhull].
  by rewrite disj_itv_Rhull.
by apply/negP; rewrite -leNgt; apply inf_lb.
Qed.

Lemma hlength_itvU A B : A `&` B = set0 -> is_interval A -> is_interval B ->
  is_interval (A `|` B) -> hlength (A `|` B) = hlength A + hlength B.
Proof.
move=> AB0 iA iB iAUB.
have [->|/set0P A0] := eqVneq A set0; first by rewrite set0U hlength0 add0e.
have [->|/set0P B0] := eqVneq B set0; first by rewrite setU0 hlength0 adde0.
wlog : A B A0 B0 AB0 iA iB iAUB / lt_itv (Rhull A) (Rhull B).
  move=> H; have [AB|AB] := eqVneq (Rhull A) (Rhull B).
      move/(congr1 (fun i => [set` i])) : AB AB0.
      rewrite RhullK ?inE// RhullK ?inE// => ->.
      by rewrite setIid => /eqP; move/set0P : B0 => /negbTE ->.
  have /orP[|] := total_le_itv (Rhull A) (Rhull B).
    by rewrite /le_itv (negbTE AB) orFb; exact: H.
  rewrite /le_itv eq_sym (negbTE AB) orFb => {}AB.
  by rewrite setUC H // 1?addeC// 1?setIC// 1?setU // setUC.
move=> AB.
have : contiguous_itv (Rhull A) (Rhull B).
  apply le_itv_disj_contiguous => //; do 1?
    [by apply/set0P; rewrite RhullK// ?inE].
  by rewrite ltW_itv.
  by rewrite disj_itv_Rhull.
  by rewrite RhullK ?inE// RhullK ?inE.
rewrite /contiguous_itv => /eqP A2B1.
rewrite /hlength A2B1 Rhull_setU2// Rhull_setU1// [in RHS]addeC ![in RHS]addeA.
congr (_ - _)%E; rewrite subeK //.
case: (Rhull B).1 => [b b1|[]] // in A2B1 *.
- exfalso; move/set0P : A0 => /negP; apply; rewrite -(@RhullK _ A) ?inE //.
  by apply/eqP/neitvP/negP; rewrite A2B1 -leNgt.
- suff: exists b r, (Rhull A).2 = BSide b r.
    by move=> [b [r Abr]]; rewrite -A2B1 Abr.
  apply: (@le_itv_disj_bnd2r _ (Rhull A) (Rhull B)) => //; do 1?
    [by apply/set0P; rewrite RhullK// ?inE].
  + exact/ltW_itv.
  + by rewrite disj_itv_Rhull.
Qed.

Lemma hlengthUitv (A : set R) (s : seq (interval R)) :
  is_interval A ->
  cover setT (fun n => [set` nth 0%O s n]) = A ->
  trivIset setT (fun n => [set` nth 0%O s n]) ->
  hlength A = \sum_(i <- s) hlength [set` i].
Proof.
move=> Aitv AE ts.
have Fmap (s' : seq (interval R)) :
    (fun n => [set` nth 0%O s' n]) =
      (fun n => nth 0%O [seq [set` j] | j <- s'] n).
  apply/funext => i; have [is'|is'] := ltnP i (size s').
    by rewrite (nth_map 0%O).
  by rewrite !nth_default ?size_map// set_itvE.
wlog : s ts AE / sorted le_itv s => [hwlog|].
  have /permPl pss := perm_sort le_itv s.
  rewrite -(perm_big _ pss); apply: hwlog; [exact: trivIset_sort|
    by rewrite -cover_set_itv_nth_sort|exact: (sort_sorted total_le_itv)].
elim: (s : seq _) => [|j {}s IHs]/= in A Aitv ts AE *.
  rewrite /cover bigcup0 in AE; last by move=> i _; rewrite nth_nil set_itvE.
  by rewrite !big_nil/= in AE * => _; rewrite -AE hlength0.
rewrite (path_sortedE le_itv_trans) => /andP[/allP/= j_small s_sorted].
set K := \big[setU/set0]_(j <- s) [set` j].
have K_itv : is_interval K.
  move=> x z Kx Kz y /andP[xy yz].
  have: A y.
    apply: (Aitv x z); rewrite ?xy//;
      by rewrite -AE cover_set_itv_nthE// big_cons; right.
  rewrite -AE /= cover_set_itv_nthE// big_cons=> -[]//.
  move=> jy; move: Kx; rewrite /K.
  rewrite -bigcup_set => -[k/= ks kx].
  suff: (x > y)%R by case: ltgtP xy.
  apply: (le_itv_lt (j_small k ks)) => //.
  have /(nthP 0%O)[ik ik_small <-] := ks.
  rewrite /disjoint_itv; apply/eqP.
  by have /trivIsetP-/(_ 0%N ik.+1 I I isT) := ts.
transitivity (hlength [set` j] + hlength K); last first.
  rewrite big_cons; congr (_ + _)%E; rewrite IHs// ?cover_set_itv_nthE//.
  by move=> i0 i1 _ _ /(ts i0.+1 i1.+1 I I)[].
rewrite -AE cover_set_itv_nthE// big_cons /= hlength_itvU//.
- rewrite big_distrr/= big1_seq => //= i /(nthP 0%O)[ii ii_lt <-].
  by apply: contraTeq isT => /set0P-/(ts 0%N ii.+1 I I).
- exact: interval_is_interval.
- by move: AE; rewrite cover_set_itv_nthE// big_cons => ->.
Qed.

Lemma cover_hlength_set_itv (I J : seq (interval R)) :
  cover setT (fun n => [set` nth 0%O I n]) =
    cover setT (fun n => [set` nth 0%O J n]) ->
  trivIset setT (fun n => [set` nth 0%O J n]) ->
  forall i, i \in I ->
  hlength [set` i] = \sum_(j <- J) hlength [set` itv_meet i j].
Proof.
move=> IJ tJ i iI.
have h : [set` i] = \big[setU/set0]_(j <- J) ([set` i] `&` [set` j]).
  rewrite -big_distrr /= (big_nth 0%O) big_mkord.
  move/esym: (IJ).
  rewrite -(@cover_restr _ _ _ [set k | (k < size J)%N]) //; last first.
    by move=> k _ /negP; rewrite -leqNgt => Jk; rewrite nth_default // set_itvE.
  rewrite /cover bigcup_mkord => ->; apply/esym; rewrite setIidPl.
  move: iI => /(nthP 0%O)[k kI <-].
  exact: (@bigcup_sup _ _ k setT (fun n => [set` nth 0%O I n])).
rewrite h (@hlengthUitv _ [seq (itv_meet i j) | j <- J]) // ?big_map//.
- by rewrite -h; apply: interval_is_interval.
- rewrite -(@cover_restr _ _ _ [set k | (k < size J)%N]) //; last first.
    move=> k _ /negP; rewrite -leqNgt => Jk.
    by rewrite nth_default ?size_map// set_itvE.
  rewrite /cover bigcup_mkord (big_nth 0%O) big_mkord.
  by apply eq_bigr => k _; rewrite (nth_map 0%O) // set_itv_meet.
- exact: trivIset_itv_meet.
Qed.

Lemma hlengthUset (I J : seq (interval R)) :
  cover setT (fun n => [set` nth 0%O I n]) =
    cover setT (fun n => [set` nth 0%O J n]) ->
  trivIset setT (fun n => [set` nth 0%O I n]) ->
  trivIset setT (fun n => [set` nth 0%O J n]) ->
  \sum_(i <- I) hlength [set` i] = \sum_(i <- J) hlength [set` i].
Proof.
move=> IJ tI tJ.
rewrite big_seq [RHS]big_seq.
(under eq_bigr) => [i /(cover_hlength_set_itv IJ tJ) ->|]; first over.
rewrite /= exchange_big /=; apply/esym.
(under eq_bigr) => [j /(cover_hlength_set_itv (esym IJ) tI) ->|]; first over.
rewrite -big_seq; apply eq_bigr => j _; rewrite -big_seq.
by under eq_bigr do rewrite itv_meetC.
Qed.

End hlength_setU.

Lemma ereal_mem_Interval (R : realDomainType) (r : R) (a b : itv_bound R) :
  (a < r%:E < b)%E -> r \in Interval a b.
Proof.
move: a b => [[]a|[]] [[]b|[]] //=; rewrite ?lte_fin ?in_itv //= => /andP[] //.
- by move=> /ltW ->.
- by move=> /ltW -> /ltW ->.
- by move=> /ltW ->.
- by move=> -> /ltW.
- by move=> ->.
- by move=> _ /ltW.
Qed.

Lemma Interval_ereal_mem (R : realDomainType) (r : R) (a b : itv_bound R) :
  r \in Interval a b -> (a <= r%:E <= b)%E.
Proof.
move: a b => [[]a|[]] [[]b|[]] //=; rewrite ?lee_fin ?in_itv ?(andbT,andbF) //=.
- by move=> /andP[-> /ltW ->].
- by move=> ->; rewrite lee_pinfty.
- by move=> /andP[/ltW -> /ltW ->].
- by move=> /andP[/ltW ->].
- by move=> /ltW ->; rewrite lee_pinfty.
- by move=> /ltW ->; rewrite lee_ninfty.
- by move=> ->; rewrite lee_ninfty.
- by move=> _; rewrite lee_pinfty lee_ninfty.
Qed.

(* TODO: move? *)
Lemma le_sum_measure_bigcup (R : realType)
   (F : (set (sset_algebraOfSetsType R))^nat)
   (l : {additive_measure set (sset_algebraOfSetsType R) -> \bar R}) :
   (forall k, measurable (F k)) -> measurable (\bigcup_n F n) -> trivIset setT F
  -> forall n, (\sum_(k < n) l (F k) <= l (\bigcup_k F k))%E.
Proof.
move=> mS US tS n.
have : \big[setU/set0]_(i < n) F i `<=` \bigcup_i F i.
  by move=> /= r; rewrite -bigcup_set => -[/= k _ Skr]; exists k.
move: (@bigsetU_measurable _ _ (enum 'I_n) xpredT _ (fun k _ => mS k)).
rewrite [in X in X -> _]big_enum => mU /(le_measure l) /=.
rewrite !inE /=.
by move=> /(_ mU US); apply: le_trans; rewrite measure_bigsetU.
Qed.

Section slength_definition.
Variable R : realType.
Implicit Types i : interval R.

Definition slength (A : set R) : \bar R :=
  let s := xget [::] [set s | A = [sset of s] ] in
  \sum_(i <- decompose s) hlength [set` i].

Lemma slength_ge0 (X : set (sset_algebraOfSetsType R)) : (0 <= slength X)%E.
Proof.
rewrite /slength; case: xgetP => [/= x _ _|_]; last first.
  by rewrite decompose_nil big_nil.
by apply/sume_ge0 => i _; apply hlength_ge0.
Qed.

Lemma slength0 : slength set0 = 0%E.
Proof.
rewrite /slength; case: xgetP => [|_]; last by rewrite decompose_nil big_nil.
move=> /= x _ /esym/decompose_set0 x0; rewrite big_seq big1//.
by move=> i /x0 ->; rewrite hlength0.
Qed.

Lemma slength_itv i : slength ([set` i]) = hlength ([set` i]).
Proof.
have [->|i0] := eqVneq [set` i] set0.
  by rewrite slength0 hlength0.
rewrite /slength; case: xgetP => [/= s _ si|]; last first.
  by move=> /(_ [fset i]%fset) /=; rewrite ssetE big_seq_fset1.
rewrite -[RHS]/((hlength \o (fun i => [set` i])) i).
rewrite -[RHS](big_seq1 adde_monoid i).
apply: hlengthUset.
+ do 2 rewrite cover_set_itv_nthE//.
  move: (is_decomposition_decompose s) => [_ _ cover_s].
  by rewrite -!ssetE cover_s -si ssetE big_seq1.
+ apply: (trivIset_sorted_decompose (sort_sorted total_le_itv _)).
  by apply/allP => j; rewrite mem_sort /= mem_filter => /andP[].
+ apply/trivIsetP => -[|a] [|b] //=;
    by rewrite nth_nil set_itvE ?(setI0,set0I).
Qed.

End slength_definition.
Arguments slength {R}.
Arguments slength0 {R}.

Section addressing_sequence_of_simple_sets.
Variables (R : realType) (s : (seq (interval R))^nat).
Hypothesis s0 : forall n, size (s n) != O. (* no empty intervals *)

(* indirect address *)
Fixpoint indaddr (b p : nat) : nat * nat :=
  if p isn't p'.+1 then (b, O) else
    if (p'.+1 < size (s b))%N then (b, p'.+1) else
      indaddr b.+1 (p' - (size (s b)).-1)%N.

Lemma indaddrE b p : indaddr b p =
 if (p < size (s b))%N then (b, p) else indaddr b.+1 (p - size (s b))%N.
Proof.
case: p => [|p] /= in b *; first by rewrite lt0n s0.
case: ifPn => //; rewrite -leqNgt => sbp1.
by rewrite -{2}(@prednK (size (s b))) // lt0n.
Qed.

(* direct address *)
(* x.2 < size (s x.1) *)
Definition diraddr (x : nat * nat) := (\sum_(x < x.1) size (s x) + x.2)%N.

Lemma indaddrK (b p : nat) : (p < size (s b))%N ->
 diraddr (indaddr b p) = diraddr (b, p).
Proof.
elim: b p => [p s0p|b ih p psb1].
  by rewrite indaddrE s0p.
by rewrite indaddrE psb1.
Qed.

Lemma diraddrK (n p k : nat) : (p < size (s (n + k)))%N ->
  indaddr k (diraddr (n + k, p)%N - \sum_(i < k) size (s i)) = (n + k, p)%N.
Proof.
elim: n p k => [p k ps0|n ih p k psn1].
  by rewrite add0n {1}/diraddr (addnC _ p) addnK indaddrE ps0.
rewrite indaddrE ifF; last first.
  apply/negbTE.
  rewrite -leqNgt /diraddr (addnC _ p) (addnC _ k).
  rewrite -(big_mkord xpredT (size \o s)) /index_iota subn0 iotaD big_cat.
  rewrite -{2}(subn0 k) big_mkord add0n.
  rewrite [n.+1]lock /= -lock (addnC (\sum_(i < k) size (s i))%N) addnA addnK.
  by rewrite /= big_cons addnCA leq_addr.
rewrite {1}addSnnS.
rewrite (_ : _ - _ = diraddr (n + k.+1, p)%N - \sum_(i < k.+1) size (s i))%N.
  by rewrite ih ?addSnnS // -addSnnS.
by rewrite big_ord_recr /= subnDA.
Qed.

Definition nth_interval (n : nat) : interval R :=
  let: (b, k) := indaddr O n in nth 0%O (s b) k.

Lemma nth_interval_diraddr (n p : nat) : (p < size (s n))%N ->
  nth_interval (diraddr (n, p)) = nth 0%O (s n) p.
Proof.
move=> psn.
rewrite /nth_interval (_ : indaddr _ _ = (n, p)) //.
by move: (@diraddrK n p O); rewrite addn0 big_ord0 subn0 => ->.
Qed.

Lemma map_nth_interval (n : nat) :
  [seq nth_interval (diraddr (n, i)) | i <- iota 0 (size (s n))] = s n.
Proof.
apply(@eq_from_nth _ 0%O).
  by rewrite size_map size_iota.
move=> i; rewrite size_map size_iota => isn.
rewrite [in LHS](nth_map 0%O) ?size_iota// -[in RHS]nth_interval_diraddr //.
by rewrite nth_iota.
Qed.

Lemma map_nth_interval_diraddr n k : flatten [seq s i | i <- iota k n] =
  [seq nth_interval i | i <- iota (diraddr (k, O))
    (\sum_(x < (k + n)) size (s x) - \sum_(x < k) size (s x))].
Proof.
have [m nm] := ubnP n; elim: m => // m ih in n k nm *.
destruct n as [|n].
  by rewrite /= addn0 subnn.
rewrite /= ih //.
rewrite -map_nth_interval map_comp -map_cat; congr map.
rewrite {1}/diraddr [in LHS]/= -iotaDl.
rewrite -/(diraddr (k, O)) {2}/diraddr big_ord_recr /= addnAC -/(diraddr _).
rewrite -iotaD; congr iota.
rewrite addnC addSnnS subnDA subnK //.
have lem a b : (\sum_(i < a) size (s i) <= \sum_(x < a + b) size (s x))%N.
  rewrite -[X in (_ <= X)%N](big_mkord xpredT (fun x => size (s x))).
  rewrite /index_iota subn0 iotaD big_cat.
  by rewrite -[in X in (_ <= X)%N](subn0 a) -/(index_iota _ _) big_mkord leq_addr.
rewrite leq_subRL.
  by rewrite -(big_ord_recr k (size \o s)) /= -addSnnS lem.
by rewrite lem.
Qed.

Lemma flatten_map_nth_interval n :
  exists u, flatten [seq s i | i <- iota 0 n] =
       [seq nth_interval i | i <- iota 0 n] ++ u.
Proof.
exists [seq nth_interval i | i <- iota n (diraddr (n, O) - n)].
rewrite -map_cat -iotaD /diraddr addn0 (addnC n) subnK; last first.
  rewrite -{1}(muln1 n) -{1}(subn0 n) -sum_nat_const_nat big_mkord leq_sum //.
  by move=> a _; rewrite lt0n.
rewrite map_nth_interval_diraddr big_ord0 subn0 add0n /diraddr big_ord0 /=.
by rewrite addn0.
Qed.

End addressing_sequence_of_simple_sets.

Lemma bigcup_bigU_bigcup (R : realType) (f : (seq (interval R))^nat) :
  (forall n, size (f n) != O) ->
  \bigcup_k \big[setU/set0]_(i <- f k) [set` i] =
  \bigcup_k [set` nth_interval f k].
Proof.
move=> f0; rewrite eqEsubset; split => r.
  move=> -[n Hn]; rewrite -bigcup_set => -[/= I].
  move=> /(nthP 0%O)[p pn <-{I}] rnp.
  exists (diraddr f (n, p)) => //.
  by rewrite nth_interval_diraddr.
move=> [n _] ; rewrite /nth_interval.
move Hx : (indaddr _ _ _) => x.
destruct x as [x1 x2] => rx2.
exists x1 => //.
rewrite -bigcup_set.
exists (nth 0%O (f x1) x2) => //.
rewrite /mkset; apply/(nthP 0%O); exists x2 => //.
rewrite ltnNge; apply: contraPN rx2 => /(nth_default 0%O) -> /=.
by rewrite in_itv.
Qed.

Lemma sum_nth_interval_sum_sum (R : realType) (f : (seq (interval R))^nat)
  (l : set R -> \bar R) :
    (forall x, 0 <= l x)%E -> (forall n, size (f n) != O) ->
  (\sum_(k <oo) l [set` nth_interval f k] <=
   \sum_(k <oo) \sum_(x <- f k) l [set` x])%E.
Proof.
move=> l_ge0 f0; apply: lee_lim.
- by apply: is_cvg_ereal_nneg_natsum_cond => n _ _; apply: l_ge0.
- apply: is_cvg_ereal_nneg_natsum_cond => n _ _; apply: sume_ge0 => i _.
  exact: l_ge0.
- near=> n.
  rewrite 2!big_mkord.
  have -> : (\sum_(k < n) \sum_(x <- f k) l [set` x] =
            \sum_(k <- flatten (map f (iota 0 n))) l [set` k])%E.
    rewrite big_flatten /= big_map -[in RHS](subn0 n) -/(index_iota _ _).
    by rewrite big_mkord.
  have -> : (\sum_(k < n) l [set` nth_interval f k] =
            \sum_(k <- map (nth_interval f) (iota 0 n)) l [set` k])%E.
    by rewrite big_map -[in RHS](subn0 n) -/(index_iota _ _) big_mkord.
  have [s' ->] := flatten_map_nth_interval f0 n.
  rewrite big_cat /= lee_addl //.
  by apply: sume_ge0 => I _; apply: l_ge0.
Grab Existential Variables. all: end_near. Qed.

Section slength_sigma_finite.
Variable R : realType.
Implicit Types (i : interval R) (n : nat).

Definition ccitv n : interval R := `[ (-(n%:R))%R, n%:R].

Lemma slength_ccitv n : slength [set` ccitv n] = n.*2%:R%:E.
Proof.
rewrite slength_itv hlength_itv /= lte_fin -{1}(add0r (-n%:R)) ltr_subl_addl.
rewrite -natrD ltr0n addnn double_gt0 lt0n; case: ifPn => [n0|/negPn/eqP->//].
by rewrite -addnn natrD 2!EFinN oppeK.
Qed.

Lemma slength_ccitv_sym b r n :
  slength ([set` Interval (BSide b r) +oo%O] `&` [set` ccitv n]) =
  slength ([set` Interval -oo%O (BSide b (- r))] `&` [set` ccitv n]).
Proof.
rewrite -2!set_itv_meet 2!slength_itv 2!hlength_itv /= 2!lte_fin; case: ifPn.
- rewrite ltUx => /andP[rn _]; case: ifPn.
  + rewrite ltxI => /andP[_ _]; congr (_%:E); rewrite opprK addrC.
    congr (_ + _)%R; rewrite joinEtotal meetEtotal /maxr /minr {rn}.
    have [rn|rn|rn] := ltgtP r (- n%:~R).
    * by rewrite ifF // ?opprK //; apply/negbTE; rewrite -leNgt -ler_oppr ltW.
    * by rewrite ifT // ltr_oppl.
    * by rewrite {2}rn opprK ltxx rn opprK.
   + rewrite ltxI negb_and -2!leNgt ler_oppl opprK (leNgt _ r) rn /=.
     rewrite -subr_le0 opprK -natrD lern0 addnn double_eq0 => /eqP n0.
     move: rn; rewrite {}n0 => r0; rewrite add0e mulr0n join_r ?opprK//.
     by rewrite oppr0 ltW.
- case: ifPn => //.
  rewrite ltxI => /andP[]; rewrite -ltr_oppl opprK => rn _.
  rewrite -leNgt lexU leNgt rn /= -subr_le0 opprK -natrD lern0 addnn double_eq0.
  move=> /eqP n0; move: rn.
  by rewrite {}n0 => r0; rewrite adde0 meet_r // ler_oppr mulr0n oppr0 ltW.
Qed.

Lemma slength_sigma_finite :
  sigma_finite setT (slength : set (sset_algebraOfSetsType R) -> \bar R).
Proof.
exists ((fun i => [set` i]) \o ccitv).
  rewrite predeqE => /= r; split => // _; have [r0|r0] := leP 0 r.
  - exists (absz (ceil r)) => //=.
    rewrite itv_boundlr/= 2!lte_bnd (le_trans _ r0)/= ?oppr_le0 ?ler0n//.
    by rewrite natr_absz ger0_norm ?ceil_ge0// ceil_ge.
  - exists (absz (floor r)) => //=.
    rewrite itv_boundlr/= 2!lte_bnd (le_trans (ltW r0)) ?ler0n// andbT.
    by rewrite natr_absz ltr0_norm ?floor_lt0// mulrNz opprK floor_le.
move=> n; split.
  by exists [fset (ccitv n)]%fset; rewrite ssetE big_seq_fset1.
by rewrite slength_itv hlength_itv /= -(fun_if EFin) lte_pinfty.
Qed.

End slength_sigma_finite.

Section slength_additive.
Variable R : realType.
Implicit Types i : interval R.

Local Lemma slength_additive_seq (s : seq (interval R)) :
  trivIset setT (fun k => [set` nth 0%O s k]) ->
  slength [sset of s] = (\sum_(j <- s) slength [set` j])%E.
Proof.
move=> ts.
rewrite {1}/slength; case: xgetP => [/= s' _ Xs'|/(_ s)]; last first.
  by rewrite /=; tauto.
apply/esym; under eq_bigr do rewrite slength_itv; apply/esym.
apply: hlengthUset => //.
- do 2 rewrite cover_set_itv_nthE//.
  have [_ _ cover_s'] := is_decomposition_decompose s'.
  by rewrite -ssetE cover_s' -Xs'.
- apply/(trivIset_sorted_decompose (sort_sorted total_le_itv _))/allP => j.
  by rewrite mem_sort /= mem_filter => /andP[].
Qed.

Lemma slength_additive :
  additive (slength : set (sset_algebraOfSetsType R) -> \bar R).
Proof.
apply/additive2P; first by rewrite slength0.
move=> A B /= [a Aa] [b Bb] AB0.
pose a' := decompose a; pose b' := decompose b.
have ABE : A `|` B = [sset of a' ++ b'].
  rewrite Aa Bb.
  have [_ _ <-] := is_decomposition_decompose a.
  have [_ _ <-] := is_decomposition_decompose b.
  by rewrite [in RHS]ssetE big_cat.
have tAB : trivIset setT (fun k => [set` nth 0%O (a' ++ b') k]).
  apply/trivIsetP => k1 k2 _ _.
  wlog : k1 k2 / (k1 < k2)%N.
    move=> h; rewrite eqn_leq negb_and -2!ltnNge => /orP[k2k1|k1k2].
      by rewrite setIC h // lt_eqF.
    by rewrite h // lt_eqF.
  move=> k1k2 _.
  have [k2a'b'|a'b'k2] := ltnP k2 (size (a' ++ b')); last first.
    by rewrite setIC nth_default // set_itvE set0I.
  have [k2a'|a'k2] := ltnP k2 (size a').
    rewrite nth_cat (ltn_trans k1k2) // nth_cat k2a'.
    have /trivIsetP := @trivIset_decompose _ a.
    by apply => //; rewrite ltn_eqF.
  have [k1a'|a'k1] := ltnP k1 (size a').
    rewrite nth_cat k1a' nth_cat ltnNge a'k2 /=; apply: subsetI_eq0 AB0.
    - rewrite Aa; have [_ _ <-] := is_decomposition_decompose a.
      rewrite sset_bigcup => r ra'.
      by exists (nth 0%O a' k1) => //; exact/mem_nth.
    - rewrite Bb; have [_ _ <-] := is_decomposition_decompose b.
      rewrite sset_bigcup => r rb'.
      exists (nth 0%O b' (k2 - size a')) => //.
      by apply/mem_nth; rewrite ltn_subLR // -size_cat.
  rewrite nth_cat ltnNge a'k1 /= nth_cat ltnNge a'k2 /=.
  have /trivIsetP := @trivIset_decompose _ b.
  apply => //; rewrite -(eqn_add2r (size a')) (subnK a'k1) (subnK a'k2).
  by rewrite ltn_eqF.
rewrite ABE slength_additive_seq // (_ : A = [sset of a']); last first.
  rewrite /a' /decompose.
  rewrite (cover_sorted_decompose (sort_sorted total_le_itv _)) //.
  by rewrite sset_sort_le_itv sset_filter_neitv.
rewrite slength_additive_seq; last first.
  apply/trivIsetP => i j _ _ ij.
  move/trivIsetP : tAB => /(_ i j Logic.I Logic.I ij).
  rewrite nth_cat; case: ifPn => [ia'|]; last first.
    by rewrite -leqNgt => a'i; rewrite (nth_default _ a'i) set_itvE set0I.
  rewrite nth_cat; case: ifPn => [//|].
  by rewrite -leqNgt => b'i; rewrite (nth_default _ b'i) set_itvE setI0.
rewrite (_ : B = [sset of b']); last first.
  rewrite (cover_sorted_decompose (sort_sorted total_le_itv _)) //.
  by rewrite sset_sort_le_itv sset_filter_neitv.
rewrite slength_additive_seq ?big_cat//.
apply/trivIsetP => i j _ _ ij.
move/trivIsetP : tAB => /(_ (size a' + i)%N (size a' + j)%N Logic.I Logic.I).
rewrite eqn_add2l => /(_ ij).
rewrite nth_cat -ltn_subRL subnn ltn0 addnC addnK.
by rewrite nth_cat -ltn_subRL subnn ltn0 addnC addnK.
Qed.

Lemma semi_additive_slength :
  semi_additive (slength : set (sset_algebraOfSetsType R) -> _).
Proof. by rewrite semi_additiveE; exact: slength_additive. Qed.

Lemma semi_additive2_slength :
  semi_additive2 (slength : set (sset_algebraOfSetsType R) -> _).
Proof. exact/(semi_additive2P slength0)/semi_additive_slength. Qed.

Definition slength_additive_measure :
    {additive_measure set (sset_algebraOfSetsType R) -> \bar R} :=
  AdditiveMeasure.Pack _ (AdditiveMeasure.Axioms slength0
    (fun X _ => slength_ge0 X) semi_additive2_slength).
Canonical slength_additive_measure.

Corollary le_slengthU_sumslength (A : seq (set R)) :
  (forall a : set R, a \in A -> Sset.is_sset a) ->
  (slength (\big[setU/set0]_(a <- A) a) <= \sum_(a <- A) (slength a))%E.
Proof.
move=> mA.
do 2 rewrite (big_nth set0) big_mkord.
apply: (Boole_inequality [additive_measure of
         (slength : set (sset_algebraOfSetsType R) -> _)]) => /= k.
have [kA|kA] := ltnP k (size A).
  case: k kA=> [? |k kA]; first exact/mA/mem_nth.
  exact/mA/mem_nth.
by rewrite nth_default.
Qed.

End slength_additive.

(* NB: really useful? *)
Lemma is_cvg_sum_slength (R : realType)
    (F : (set (sset_algebraOfSetsType R))^nat) (P : pred nat) m :
  (forall k, P k -> measurable (F k)) ->
    cvg (fun n => (\sum_(m <= k < n | P k) slength (F k))%E).
Proof.
move=> mF; apply: is_cvg_ereal_nneg_natsum_cond => n mn Pn.
exact/slength_ge0.
Qed.

Lemma sum_slength_neitv (R : realType) (j : (interval R)^nat) :
  ((fun n => \sum_(0 <= k < n) slength [set` j k]) =
   (fun n => \sum_(0 <= k < n | neitv (j k)) slength [set` j k]))%E.
Proof.
rewrite funeqE => n; rewrite 2!big_mkord (bigID (fun k : 'I_n => neitv (j k))).
rewrite /= addeC big1 ?add0e // => k; rewrite neitvE => jk1jk2.
rewrite [X in slength X](_ : _ = set0) ?slengt0//.
by apply/eqP/negPn; rewrite -/(neitv _) neitvE.
Qed.

Lemma measurable_sset_itv (R : realType) (i : interval R) :
  measurable ([set` i] : set (sset_algebraOfSetsType R)).
Proof. exact/Sset.is_sset_itv. Qed.

Section slength_sigma_additive_on_intervals.
Variable R : realType.
Implicit Types i : interval R.
Local Open Scope ereal_scope.

Lemma slength_sigma_subadditive_finite_itv i (j : (interval R)^nat)
    (P : pred nat) :
  hlength [set` i] < +oo ->
  P `<=` neitv \o j ->
  [set` i] `<=` \bigcup_(k in P) [set` j k] ->
  slength [set` i] <=\sum_(k <oo | P k) slength [set` j k].
Proof.
move=> iNoo jne ij.
set l := lim _; have := lee_pinfty l.
rewrite le_eqVlt => /predU1P[->|loo]; first by rewrite lee_pinfty.
have [jfin|] := pselect (forall k, P k -> hlength [set` j k] < +oo); last first.
  move/existsNP => -[k /not_implyP[Pk] /negP].
  rewrite -leNgt lee_pinfty_eq => /eqP jkoo.
  rewrite /l (ereal_nneg_series_pinfty _ Pk) // ?lee_pinfty// ?slength_itv//.
  by move=> n _; apply/measure_ge0/measurable_sset_itv.
have [->|] := eqVneq [set` i] set0.
  rewrite slength0 ereal_nneg_series_lim_ge0// => k _.
  exact/measure_ge0/measurable_sset_itv.
move=> i0.
have [ri1 ri2] := hlength_finite_fin_num i0 iNoo.
set a := fine i.1; set b := fine i.2.
have [ab|ba] := ltP a b; last first.
  rewrite slength_itv hlength_itv ltNge -{1}(fineK ri1) -{1}(fineK ri2).
  rewrite -/a -/b lee_fin ba /= ereal_nneg_series_lim_ge0// => k _.
  exact/measure_ge0/measurable_sset_itv.
suff baj : forall e : {posnum R},
    b%:E - a%:E <= \sum_(k <oo | P k) slength [set` j k] + e%:num%:E.
  rewrite (@le_trans _ _ (b%:E - a%:E)) //.
    rewrite slength_itv hlength_itv -(fineK ri1) -(fineK ri2).
    by rewrite -/a -/b lte_fin ab.
  by apply lee_adde => e; exact: baj.
move=> e.
set a' := (a + e%:num/4%:R)%R.
set b' := (b - e%:num/4%:R)%R.
have a'b'i : {subset `[a', b'] <= i}.
  apply/subset_itvP => r; rewrite /= in_itv /= => /andP[a'r rb'].
  rewrite (IntervalE i).
  apply: ereal_mem_Interval.
  rewrite -(fineK ri1) -(fineK ri2) -/a -/b 2!lte_fin; apply/andP; split.
    by rewrite (lt_le_trans _ a'r) // /a' ltr_addl.
  by rewrite (le_lt_trans rb') // /b' ltr_subl_addl ltr_addr.
set a_ := fun k => fine (j k).1; set b_ := fun k => fine (j k).2.
set a'_ := (fun k => a_ k - e%:num / (2 ^ k.+3)%:R)%R.
set b'_ := (fun k => b_ k + e%:num / (2 ^ k.+3)%:R)%R.
have ia_b_ : [set` i] `<=` \bigcup_(k in P) `] (a'_ k) , (b'_ k) [%classic.
  move/subset_trans : ij; apply => r [k Pk].
  have [->//|jk0] := eqVneq [set` j k] set0.
  rewrite (IntervalE (j k)) => /Interval_ereal_mem /andP[jk1r rjk2].
  have [jk1 jk2] := hlength_finite_fin_num jk0 (jfin _ Pk).
  exists k => //=; rewrite in_itv /=; apply/andP; split.
    rewrite -lte_fin (lt_le_trans _ jk1r) // /a'_ /a_ EFinB lte_subl_addr//.
    rewrite -{2}(fineK jk1) // -EFinD lte_fin.
    by rewrite ltr_addl divr_gt0 // ltr0n expn_gt0.
  rewrite -lte_fin (le_lt_trans rjk2) // /b'_ /b_ -{1}(fineK jk2) //.
  by rewrite lte_fin ltr_addl divr_gt0 // ltr0n expn_gt0.
have a'b'a'_b'_ :
    [set x | x \in `[a', b']] `<=` \bigcup_(k in P) `](a'_ k), (b'_ k)[%classic.
  by move/subset_itvP : a'b'i => /subset_trans; apply.
have [F [HF HF_]] : exists F : {fset nat}, `[a', b']%classic `<=`
    \bigcup_(k in [set x | (x \in F) && (P x)]) `] (a'_ k), (b'_ k) [%classic /\
  [set x | x \in F] `<=` P.
  have h k : P k -> open `](a'_ k), (b'_ k)[%classic.
    by move=> _; exact: interval_open.
  have := @segment_compact _ a' b'.
  (* NB: Borel-Lebesgue theorem *)
  rewrite compact_cover => /(_ _ _ _ h a'b'a'_b'_) => -[F FP a'b'F]; exists F.
  split; last by move=> x /FP; rewrite inE.
  move=> r /a'b'F[k Fk kr]; exists k => //=.
  by rewrite Fk /=; move/FP : Fk; rewrite inE.
set F' := [fset k in F | neitv `](a'_ k), (b'_ k)[]%fset.
have HF' : (`[a', b'] `<=` \bigcup_(k in [set` F']) `](a'_ k), (b'_ k)[)%classic.
  move/subset_trans : HF; apply.
  move=> r [k /andP[kF Pk]].
  have [-> //|a'b'k0 a'b'kr] := eqVneq `](a'_ k), (b'_ k)[%classic set0.
  by exists k => //; rewrite /mkset /F' !inE /= /neitv /= a'b'k0 andbT.
have : b'%:E - a'%:E <= \sum_(k <oo | P k) slength [set` j k] + (e%:num / 2)%:E.
  have [a'b'|b'a'] := ltP a' b'; last first.
    rewrite (@le_trans _ _ 0%:E) //; first by rewrite sube_le0 lee_fin.
    rewrite adde_ge0 // ?lee_fin//.
    by apply: ereal_nneg_series_lim_ge0 => k _; exact/slength_ge0.
  rewrite (@le_trans _ _ (slength `[a', b']%classic)) //.
    by rewrite slength_itv hlength_itv /= lte_fin a'b'.
  have F'_ringOfSets x : x \in [seq `](a'_ k), (b'_ k)[%classic | k <- F'] ->
      Sset.is_sset x.
    move=> /mapP[/= p pF' ->{x}]; exists [:: `](a'_ p), (b'_ p)[ ].
    by rewrite sset_cons1.
  rewrite (@le_trans _ _
      (slength (\big[setU/set0]_(k <- F') `] (a'_ k), (b'_ k) [%classic))) //.
    apply/le_measure => //.
      by rewrite inE /=; exact/Sset.is_sset_itv.
      rewrite inE /=; apply: bigsetU_measurable => n _.
      exact/Sset.is_sset_itv.
    by move/subset_trans : HF'; apply; rewrite bigcup_set.
  rewrite (@le_trans _ _ (\sum_(k <- F') (b'_ k - a'_ k)%:E)) //.
    move: (@le_slengthU_sumslength _ [seq `](a'_ k), (b'_ k)[%classic | k <- F']
      F'_ringOfSets).
    rewrite big_map => /le_trans; apply.
    rewrite big_map /F' 2!big_fset /= ; apply: lee_sum => k /neitvP.
    rewrite lte_bnd => a'b'k0.
    by rewrite slength_itv hlength_itv /= lte_fin a'b'k0.
  apply: (le_trans _
      (@epsilon_trick _ (slength \o pred_set \o j) _ P _)) => //; last first.
    by move=> n; apply/slength_ge0.
  rewrite [X in X <= _](_ : _ =
      \sum_(k <- F') (b_ k - a_ k + (e%:num / (2 ^ k.+2)%:R))%:E); last first.
    apply eq_bigr => /= k ?; rewrite /a'_ /b'_; congr (_ %:E).
    rewrite opprB addrA addrC 2!addrA (addrC _ (b_ k)) -addrA; congr (_ + _)%R.
    by rewrite -mulrDl -mulr2n -mulr_natl expnS natrM -mulf_div divff // mul1r.
  under eq_bigr do rewrite EFinD.
  rewrite big_split /=.
  (* TODO: lemma? *)
  have cvggeo :
      (fun n => \sum_(i < n) (e%:num / (2 ^ i.+2)%:R)%:E) --> (e%:num / 2)%:E.
    rewrite (_ : (fun n => _) =
        EFin \o series (fun k => e%:num / (2 ^ (k + 2))%:R)); last first.
      rewrite funeqE => n; rewrite /series /=.
      rewrite (@big_morph _ _ EFin 0%:E adde) // big_mkord.
      by under eq_bigr do rewrite -[in X in (_ ^X)%:R]addn2.
    apply: cvg_comp; last apply cvg_refl.
    have := @cvg_geometric_series_half _ e%:num 1.
    by rewrite expr1.
  have ? : cvg (fun n => \sum_(k < n | P k) (e%:num / (2 ^ k.+2)%:R)%:E).
    under eq_fun do rewrite -(big_mkord P (fun k => (e%:num / (2 ^ k.+2)%:R)%:E)).
    by apply: is_cvg_ereal_nneg_series => n _; rewrite lee_fin divr_ge0// ler0n.
  apply (@le_trans _ _ (\sum_(k <oo | P k) slength [set` j k] +
      \sum_(k <oo | P k) (e%:num / (2 ^ k.+2)%:R)%:E)); last first.
    rewrite -ereal_limD //; last 3 first.
      by apply: is_cvg_sum_slength => k Pk; exact/measurable_sset_itv.
      by under eq_fun do rewrite big_mkord.
      have /andP[l0 le2] :
          0 <= \sum_(k <oo | P k) (e%:num / (2 ^ k.+2)%:R)%:E <= (e%:num / 2)%:E.
        apply/andP; split.
          rewrite (@ereal_nneg_series_lim_ge0 _
            (fun k => (e%:num / (2 ^ k.+2)%:R)%:E)) // => n _.
          by apply divr_ge0 => //; rewrite ler0n.
        move/cvg_lim : (cvggeo) => <- //=.
        apply lee_lim => //.
          by under eq_fun do rewrite big_mkord.
          under eq_fun do rewrite -(big_mkord xpredT (fun k => (e%:num / (2 ^ k.+2)%:R)%:E)).
          by apply: is_cvg_ereal_nneg_series => n _; rewrite lee_fin divr_ge0 // ler0n.
        near=> n.
        rewrite (big_mkord P (fun k => (e%:num / (2 ^ k.+2)%:R)%:E)).
        move: (@lee_sum_nneg R _ (enum 'I_n) xpredT P (fun k => (e%:num / (2 ^ k.+2)%:R)%:E)).
        rewrite big_enum big_enum_cond; apply => k _ _.
        by apply divr_ge0 => //; rewrite ler0n.
      apply: fin_num_adde_def => //.
      rewrite fin_numE gt_eqF /=; last first.
        by rewrite (lt_le_trans _ l0) // lte_ninfty.
      by rewrite lt_eqF // (le_lt_trans le2) // lte_pinfty.
    rewrite (_ : (fun x => _) = (fun x => \sum_(0 <= k < x | P k)
      (slength [set` j k] + (e%:num / 2 / (2 ^ k.+1)%:R)%:E))) //.
    rewrite funeqE => n; rewrite big_split => /=; congr (_ + _).
    by apply eq_bigr => m Pm; rewrite expnS natrM invfM -mulrA.
  have sum_F'_P f : \sum_(k <- F') f k = \sum_(k <- F' | P k) f k.
    apply eq_fbigl_cond => // k; apply/idP/idP => /=.
      rewrite !inE andbT => /andP[/= kF -> /=].
      by rewrite andbT kF /=; apply/HF_.
    by rewrite !inE andbT => /andP[].
  apply: lee_add; last first.
    set f := fun n => \sum_(k < n | P k) (e%:num / (2 ^ n.+2)%:R)%:E.
    rewrite (@le_trans _ _ (\sum_(k <oo | P k) (e%:num / (2 ^ k.+2)%:R)%:E)) //.
    rewrite sum_F'_P.
    by apply: lee_sum_lim => n _; apply divr_ge0 => //; rewrite ler0n.
  rewrite [X in X <= _](_ : _ = \sum_(k <- F') slength [set` j k]); last first.
    apply eq_fbigr => k /imfsetP[/= p]; rewrite !inE => /andP[pF a'b'p0 ->{k} ?].
    rewrite /b_ /a_ slength_itv hlength_itv.
    have [? ?] : ((j p).1 : \bar R) \is a fin_num /\
                 ((j p).2 : \bar R) \is a fin_num.
      apply hlength_finite_fin_num; first by apply: jne => //; exact: HF_.
      by apply jfin => //; exact: HF_.
    rewrite EFinB fineK// fineK//.
    have /jne/neitvP/ltW/le_bnd_ereal : P p := HF_ _ pF.
    by rewrite le_eqVlt => /predU1P[->|->//]; rewrite ltxx subee.
  by rewrite sum_F'_P; apply: lee_sum_lim => k _; exact/slength_ge0.
have -> : b'%:E - a'%:E = b%:E - a%:E - (e%:num / 2)%:E.
  rewrite /a' /b' (EFinD a) oppeD// (EFinB b) -addeA.
  rewrite (addeCA (- (e%:num / 4%:R)%:E)) addeA; congr (_ + _).
  rewrite -oppeD//; congr oppe; rewrite -EFinD; congr (_%:E).
  by rewrite -mulrDl -mulr2n -mulr_natl (natrM _ 2 2) -mulf_div divff // mul1r.
rewrite lee_subl_addr// => /le_trans; apply; rewrite le_eqVlt; apply/orP; left.
rewrite -addeA; apply/eqP; congr (_ + _).
by rewrite -EFinD -mulrDl -mulr2n -mulr_natr -mulrA divff ?mulr1.
Grab Existential Variables. all: end_near. Qed.

Lemma slength_sigma_additive_finite_itv i (j : (interval R)^nat) :
  [set` i] = \bigcup_k [set` j k] ->
  trivIset setT (pred_set \o j) ->
  hlength [set` i] < +oo ->
  slength [set` i] = \sum_(k <oo) slength [set` j k].
Proof.
move=> ij tj iNoo.
apply/eqP; rewrite eq_le; apply/andP; split.
  pose P := neitv \o j.
  have : [set` i] `<=` \bigcup_(k in [set x | neitv (j x)]) [set` j k].
    suff: [set` i] = \bigcup_(k in [set x | neitv (j x)]) [set` j k].
      by move=> ->.
    rewrite ij; apply/predeqP => r; split => [[x _ jxr]|[x]].
      by exists x => //; rewrite /mkset; apply/set0P; exists r.
    by exists x.
  move/(@slength_sigma_subadditive_finite_itv _ j P iNoo (fun x => id)).
  move/le_trans; apply; apply: lee_lim.
  + by apply: is_cvg_sum_slength => n jn0; exact/Sset.is_sset_itv.
  + by apply: is_cvg_sum_slength => n _; exact/Sset.is_sset_itv.
  + near=> n.
    rewrite 2!big_mkord.
    move: (@lee_sum_nneg R _ (enum 'I_n) xpredT (neitv \o j)
      (slength \o pred_set \o j)).
    rewrite /= big_enum_cond big_enum; apply.
    by move=> x _ _; exact/slength_ge0.
apply: ereal_lim_le.
  by apply: is_cvg_sum_slength => n _; exact/Sset.is_sset_itv.
near=> n.
rewrite [X in X <= _](_ : _ = slength (\big[setU/set0]_(k < n) [set` j k])) //.
  apply: le_measure.
  - by rewrite inE /=; apply: bigsetU_measurable => k _; exact/Sset.is_sset_itv.
  - by rewrite inE /=; exact/Sset.is_sset_itv.
  - by rewrite ij -bigcup_set /= => r [k /= _ jkr]; exists k.
rewrite big_mkord; apply/esym.
apply/(@measure_bigsetU _ _ (@slength_additive_measure R) (pred_set \o j)) => //.
by move=> // k; exists [:: j k]; rewrite sset_cons1.
Grab Existential Variables. all: end_near. Qed.

Lemma slength_sigma_subadditive_infinite_itv
    i (j : (interval R)^nat) (P : pred nat) :
  hlength ([set` i]) = +oo ->
  (forall k, P k -> neitv (j k)) ->
  [set` i] `<=` \bigcup_(k in P) [set` j k] ->
  slength [set` i] <= \sum_(k <oo | P k) slength [set` j k].
Proof.
move=> ioo jne ij; suff h : forall M, (M > 0)%R -> \forall n \near \oo,
    M%:E <= \sum_(0 <= k < n | P k) slength [set` j k].
  rewrite slength_itv ioo lee_pinfty_eq; apply/eqP.
  by apply/cvg_lim => //; apply/ereal_cvgPpinfty => M M0; exact: h.
set iIccitv := fun n => [set` i] `&` [set` ccitv R n].
have len_iIccitv_dvg M : (M > 0)%R ->
    exists n, (n >= 1)%N /\ M%:E < slength (iIccitv n).
  move=> M0.
  move/pinfty_hlength : ioo => [[b [r iroo]]|ioo]; last first.
    have ? : (0 < `|ceil M|)%N by rewrite absz_gt0 gt_eqF // ceil_gt0.
    exists `|ceil M|%N; split=> //; rewrite /iIccitv ioo set_itvE setTI.
    rewrite slength_ccitv lte_fin (le_lt_trans (ceil_ge _)) // -muln2 natrM.
    rewrite natr_absz gtr0_norm ?ceil_gt0// ltr_pmulr ?ltr1n// ltr0z.
    by rewrite ceil_gt0.
  rewrite /iIccitv.
  wlog : i {ij iIccitv} b r {iroo} / i = Interval -oo%O (BSide b r).
    move=> h; move: iroo => [->|iroo]; first exact: h.
    have [N [N0 MN]] := h _ b (- r)%R erefl.
    by exists N; split => //; rewrite iroo slength_ccitv_sym.
  move=> ->{i}.
  have [r0|r0] := ler0P r.
    exists (`|ceil (`| r | + M) |%N.+1); split => //.
    rewrite -set_itv_meet slength_itv hlength_itv /= lte_fin ltxI ltz_opp //.
    rewrite andbT ltr_oppl opprK meet_l ?(le_trans r0)//.
    rewrite -addn1 natrD natr_absz ger0_norm ?ceil_ge0// ?(addr_ge0 _ (ltW _))//.
    case: ifPn => [_|].
      rewrite lte_fin -ltr_subl_addl ltr_spaddr//.
      by rewrite (le_trans _ (ceil_ge _))// addrC ler_add2r ler0_norm.
    rewrite ltr_spaddr//.
    by rewrite (le_trans _ (ceil_ge _)) // (ler_paddr (ltW _))// ler0_norm.
  move=> [:crM]; exists (`|ceil (`| r | + M)|%N); split.
    abstract: crM.
    by rewrite absz_gt0 gt_eqF // ceil_gt0 // -(addr0 0%R) ler_lt_add.
  rewrite -set_itv_meet slength_itv hlength_itv /= lte_fin ltxI ltz_opp //.
  rewrite ltr_oppl opprK andbT.
  rewrite natr_absz ger0_norm ?ceil_ge0// ?(addr_ge0 _ (ltW _))// gtr0_norm//.
  rewrite meet_l; last first.
    by rewrite (le_trans (ceil_ge _)) // ler_int le_ceil // ler_addl ltW.
  case: ifPn => [_|/negP].
    rewrite lte_fin -{1}(add0r M) ltr_le_add//.
    by rewrite (le_trans (ceil_ge _)) // ler_int le_ceil // ler_addr ltW.
  rewrite -oppr_lt0 in r0.
  by rewrite (lt_le_trans r0)// ler0z ceil_ge0// addr_ge0// ?ltW// -oppr_lt0.
move=> M M0.
have {len_iIccitv_dvg}[N [N0 MN]] := len_iIccitv_dvg _ M0.
set jIccitv := fun N k => [set` j k] `&` [set` ccitv R N].
have len_jIccitv_dvg :
    \forall n \near \oo, M%:E <= \sum_(k < n | P k) slength (jIccitv N k).
  have iUj n : iIccitv n `<=` \bigcup_(k in P) jIccitv n k.
    by move/(@setSI _ [set` ccitv R n]) : ij; rewrite setI_bigcupl.
  apply lte_lim => //.
  + apply: (@lee_sum_nneg_ord _ (slength \o jIccitv N)) => n Pn.
    by apply: slength_ge0; rewrite /jIN -set_itv_meet; exact/Sset.is_sset_itv.
  + under eq_fun do rewrite -(big_mkord P (slength \o jIccitv N)).
    apply: is_cvg_ereal_nneg_series => n _.
    by apply: slength_ge0; rewrite /jIN -set_itv_meet; exact/Sset.is_sset_itv.
  + rewrite (lt_le_trans MN) // /iIccitv -set_itv_meet.
    under [in lim _]eq_fun do rewrite -(big_mkord P (slength \o jIccitv N)).
    rewrite [X in _ <= X](_ : _ = (\sum_(k <oo | P k)
        slength [set` itv_meet (j k) (ccitv R N)])); last first.
      congr (lim _); rewrite funeqE => /= n.
      by under eq_bigr do rewrite /jIccitv -set_itv_meet.
    rewrite (_ : (fun n => _) =
      (fun n => \sum_(k < n | P k && (neitv (itv_meet (j k) (ccitv R N))))
      slength [set` itv_meet (j k) (ccitv R N)])%E); last first.
      rewrite funeqE => /= n; rewrite big_mkord.
      rewrite (bigID (fun k : 'I_n => neitv (itv_meet (j k) (ccitv R N)))) /=.
      rewrite addeC big1 ?add0e // => k /andP[?].
      by rewrite negbK => /eqP ->; rewrite slength0.
    under [in lim _]eq_fun do
      rewrite -(big_mkord (fun k => P k && (neitv (itv_meet (j k) (ccitv R N))))
      (fun k => slength [set` itv_meet (j k) (ccitv R N)])).
    apply: (@slength_sigma_subadditive_finite_itv _
        (fun k => itv_meet (j k) (ccitv R N))
        (fun k => P k && (neitv (itv_meet (j k) (ccitv R N))))) => //.
    + rewrite (@le_lt_trans _ _ (hlength [set` ccitv R N])) //.
      by apply le_hlength; rewrite set_itv_meet; apply subIset; right.
    + by rewrite -slength_itv slength_ccitv lte_pinfty.
    + by move=> k /andP[].
    + apply: (@subset_trans _
          (\bigcup_(k in P) [set` itv_meet (j k) (ccitv R N)])).
        move=> x; rewrite set_itv_meet => /iUj [k ? Hk]; exists k => //.
        by rewrite set_itv_meet.
      move=> r [k Pk kr]; exists k => //; rewrite Pk /=; apply/set0P.
      by exists r.
have [m _ Hm] :
    \forall n \near \oo, M%:E <= \sum_(k < n | P k) slength [set` j k].
  case: len_jIccitv_dvg => m [mN]; exists m => // p /= mp.
  have /le_trans := mN _ mp; apply; apply: lee_sum => /= q _.
  rewrite /jIccitv; apply: le_measure => //.
  - by rewrite inE /=; apply: measurableI => //; exact/Sset.is_sset_itv.
  - by rewrite inE /=; exact/Sset.is_sset_itv.
  - by apply: subIset; left.
near=> n; rewrite big_mkord.
by have /Hm mn : (m <= n)%N by near: n; exists m.
Grab Existential Variables. all: end_near. Qed.

Lemma slength_sigma_subadditive_itv i (j : (interval R)^nat) (P : pred nat) :
  (forall k, P k -> neitv (j k)) ->
  [set` i] `<=` \bigcup_(k in P) [set` j k] ->
  slength ([set` i]) <= \sum_(k <oo | P k) slength [set` j k].
Proof.
move=> jne ij; have := lee_pinfty (hlength [set` i]).
rewrite le_eqVlt => /predU1P[|] ioo; by [
  exact: slength_sigma_subadditive_infinite_itv |
  exact: slength_sigma_subadditive_finite_itv].
Qed.

Lemma slength_sigma_additive_itv i (j : (interval R)^nat) :
  [set` i] = \bigcup_k [set` j k] -> trivIset setT (pred_set \o j) ->
  slength ([set` i]) = \sum_(k <oo) slength [set` j k].
Proof.
move=> ij tj; have := lee_pinfty (hlength [set` i]).
rewrite le_eqVlt => /predU1P[ioo|iNoo]; last first.
  exact: slength_sigma_additive_finite_itv.
rewrite slength_itv ioo sum_slength_neitv; apply/esym/eqP.
rewrite -lee_pinfty_eq -ioo -slength_itv.
apply: slength_sigma_subadditive_itv => // r.
by rewrite ij => -[n _ jnr]; exists n => //=; apply/set0P; exists r.
Qed.

End slength_sigma_additive_on_intervals.

Section slength_measure.
Variable R : realType.
Implicit Types (i : interval R) (f : (seq (interval R))^nat).
Local Open Scope ereal_scope.

Definition nil_cons0 f := fun k => if size (f k) == O then [:: 0%O] else f k.

Lemma nil_cons0P (f : (seq (interval R))^nat) n : size (nil_cons0 f n) != O.
Proof. by rewrite /nil_cons0; case: ifPn. Qed.

Lemma nil_cons0_bigU f k : \big[setU/set0]_(x <- f k) [set` x] =
  \big[setU/set0]_(x <- nil_cons0 f k) [set` x].
Proof.
rewrite /nil_cons0; case: (f k) => /= [|h t]; last by rewrite big_cons.
by rewrite big_nil big_seq1 set_itvE.
Qed.

Lemma nil_cons0_bigcup_bigU f : \bigcup_k \big[setU/set0]_(x <- f k) [set` x] =
  \bigcup_k \big[setU/set0]_(x <- nil_cons0 f k) [set` x].
Proof. by congr bigcup; rewrite funeqE => j; exact: nil_cons0_bigU. Qed.

Lemma nil_cons0_sum f k :
  \sum_(x <- f k) slength [set` x] = \sum_(x <- nil_cons0 f k) slength [set` x].
Proof.
rewrite /nil_cons0; case: (f k) => //=.
by rewrite big_nil big_seq1 set_itvE slength0.
Qed.

Lemma nil_cons0_lim f : \sum_(k <oo) \sum_(x <- f k) slength [set` x] =
  \sum_(k <oo) \sum_(x <- nil_cons0 f k) slength [set` x].
Proof.
rewrite (_ : (fun n => \sum_(0 <= k < n) (\sum_(x <- f k) slength [set` x])) =
  (fun n => \sum_(0 <= k < n) (\sum_(x <- nil_cons0 f k) slength [set` x]))) //.
by rewrite funeqE => n; apply eq_bigr => j _; rewrite nil_cons0_sum.
Qed.

Local Lemma le_slength_itv_sumI (F : (set R)^nat) f :
  (forall k, F k = [sset of f k]) ->
  forall i, [set` i] `<=` \bigcup_k (F k) ->
  slength ([set` i]) <= \sum_(k <oo) slength ([set` i] `&` F k).
Proof.
move=> Fs i iF.
have {iF}iiF : [set` i] `<=` \bigcup_k ([set` i] `&` F k).
  by move=> r ir; move/iF : (ir) => [k _ Skr]; exists k.
pose df := decompose \o f.
pose idf := fun k => [seq itv_meet i x | x <- df k].
have {iiF} :
    [set` i] `<=` \bigcup_k (\big[setU/set0]_(x <- idf k) [set` x]).
  move/subset_trans : iiF; apply => r [n _].
  rewrite [in X in X -> _]Fs ssetE big_distrr /= => sir.
  exists n => //; rewrite /idf big_map.
  under eq_bigr do rewrite set_itv_meet.
  move: sir; rewrite -bigcup_set => -[/= j jsn [ir jr]].
  have [k [ksn kr]] := mem_decompose jsn jr.
  by rewrite -bigcup_set; exists k.
rewrite nil_cons0_bigcup_bigU bigcup_bigU_bigcup //; last exact: nil_cons0P.
move=> iiF.
rewrite (_ : (fun _ => _) = (fun n => \sum_(0 <= k < n)
    \sum_(x <- idf k) slength [set` x])); last first.
  rewrite funeqE => k; apply eq_bigr => {}k _.
  have -> : forall n, [set` i] `&` F n = \big[setU/set0]_(x <- idf n) [set` x].
    move=> n; rewrite big_map;have [_ _] := is_decomposition_decompose (f n).
    rewrite {1}ssetE -[decompose _]/(df n) -(Fs n) => <-.
    by rewrite big_distrr /=; under eq_bigr do rewrite -set_itv_meet.
  rewrite (big_nth 0%O) big_mkord.
  rewrite (@measure_bigsetU _ _ (@slength_additive_measure R)
      (fun n => [set` nth 0%O (idf k) n])) //; last 2 first.
    by move=> m; apply: Sset.is_sset_itv.
    exact/trivIset_itv_meet/trivIset_decompose.
  by rewrite (big_nth 0%O) big_mkord.
rewrite nil_cons0_lim.
rewrite (le_trans _ (@sum_nth_interval_sum_sum _ (nil_cons0 idf) slength _ _))//.
- rewrite sum_slength_neitv slength_sigma_subadditive_itv => //.
  by apply: (subset_trans iiF) => r [k _ kr]; exists k => //; apply/set0P; exists r.
- by move=> x; apply: slength_ge0.
- exact: nil_cons0P.
Grab Existential Variables. all: end_near. Qed.

Lemma slength_semi_sigma_additive :
  semi_sigma_additive (slength : set (sset_algebraOfSetsType R) -> \bar R).
Proof.
move=> F mF tF mUF.
suff -> : slength (\bigcup_k F k) = \sum_(k <oo) slength (F k).
  under eq_fun do rewrite -(big_mkord xpredT (slength \o F)).
  exact/is_cvg_sum_slength.
apply/eqP; rewrite eq_le; apply/andP; split; last first.
  apply: (ereal_lim_le (is_cvg_sum_slength _)) => //.
  by near=> n; rewrite big_mkord; exact: le_sum_measure_bigcup.
have [seq_of Fseq_of] := @choice _ _ (fun k s => F k = [sset of s]) mF.
have [j [Fj tj]] : exists j : seq (interval R), \bigcup_k (F k) = [sset of j] /\
    trivIset setT (fun k => [set` nth 0%O j k]).
  have [j Fj] := mUF.
  exists (decompose j); split; last exact: trivIset_decompose.
  by rewrite Fj; have [_ _ ->] := is_decomposition_decompose j.
rewrite Fj ssetE (big_nth 0%O) big_mkord.
rewrite (@measure_bigsetU _ _ (@slength_additive_measure R)
    (fun n => [set` nth 0%O j n])) //; last first.
  by move=> i; exact/measurable_sset_itv.
rewrite (@le_trans _ _ (\sum_(0 <= n < size j)
         \sum_(k <oo) slength ([set` nth 0%O j n] `&` F k))) //.
  rewrite big_mkord; apply: lee_sum => n _.
  rewrite (@le_slength_itv_sumI F seq_of) // Fj ssetE (big_nth 0%O).
  rewrite big_mkord => r jnr.
  by rewrite -bigcup_set; exists n => //=; rewrite mem_index_enum.
rewrite (@le_trans _ _ (\sum_(n <oo)
  \sum_(0 <= k < size j) slength ([set` nth 0%O j k] `&` F n))) //.
  rewrite (@ereal_pseries_sum_nat _ (size j)) //.
  by move=> a b; exact: slength_ge0.
apply: lee_lim.
- apply: is_cvg_ereal_nneg_series => n _.
  by apply: sume_ge0 => /= i _; apply: slength_ge0.
- by apply/is_cvg_sum_slength => ? _; exact/mF.
- near=> n; apply: lee_sum => /= k _.
  have Fkj : F k = \bigcup_i ([set` nth 0%O j i] `&` F k).
    rewrite -setI_bigcupl setIC; apply/esym/setIidPl.
    rewrite (_ : \bigcup_ _ _ = [sset of j]).
      by rewrite -Fj; apply: bigcup_sup.
    rewrite ssetE (big_nth 0%O) big_mkord (bigcup_splitn (size j)).
    rewrite bigcup0 ?setU0// => i _.
    by rewrite nth_default ?set_itvE// leq_addr.
  rewrite {2}Fkj big_mkord le_sum_measure_bigcup//.
  + by move=> i; apply: measurableI => //; exact/measurable_sset_itv.
  + by rewrite -Fkj.
  + by under eq_fun do rewrite setIC; exact: trivIset_setI.
Grab Existential Variables. all: end_near. Qed.

Definition slength_measure : {measure set (sset_algebraOfSetsType R) -> \bar R}
  := Measure (Measure.Axioms slength0 (fun X _ => slength_ge0 X)
                             slength_semi_sigma_additive).

Definition slength_ext_outer_measure
    : {outer_measure set (sset_algebraOfSetsType R) -> \bar R} :=
  [outer_measure of mu_ext slength_measure].

Definition length
    : {measure set (caratheodory_type slength_ext_outer_measure) -> \bar R} :=
  caratheodory_measure slength_ext_outer_measure.

End slength_measure.
Arguments slength_ext_outer_measure {R}.
Arguments length {R}.

Section lebesgue_measure.
Variable R : realType.
Let ssets := @measurable (@sset_algebraOfSetsType R).
Let gssets := g_measurableType ssets.

Definition lebesgue_measure : {measure set gssets -> \bar R} :=
  Hahn_ext (@slength_measure R).

Lemma lebesgue_measure_unique (mu : {measure set gssets -> \bar R}) :
  (forall X, ssets X -> mu X = slength X) ->
  forall X, measurable X -> lebesgue_measure X = mu X.
Proof.
by move=> muE X mX; apply: Hahn_ext_unique => //; exact: slength_sigma_finite.
Qed.

End lebesgue_measure.

Section salgebra_ereal.
Variables (R : realType) (G : set (set R)).
Let measurableTypeR := g_measurableType G.
Let measurableR : set (set R) := @measurable measurableTypeR.

Inductive ps_infty : set \bar R -> Prop :=
| ps_infty0 : ps_infty set0
| ps_ninfty : ps_infty [set -oo]%E
| ps_pinfty : ps_infty [set +oo]%E
| ps_inftys : ps_infty [set -oo; +oo]%E.

Lemma ps_inftyP (A : set \bar R) : ps_infty A <-> A `<=` [set -oo; +oo]%E.
Proof.
split => [[]//|Aoo]; [by left|by right| ].
by have [|[|[|]]] := subset_set2 Aoo; move=> ->; constructor.
Qed.

Definition emeasurable : set (set \bar R) :=
  [set EFin @` A `|` B | A in measurableR & B in ps_infty].

Lemma emeasurable0 : emeasurable set0.
Proof.
exists set0; first exact: measurable0.
by exists set0; rewrite ?setU0// ?image_set0//; constructor.
Qed.

Lemma bigcup_EFIn (F : (set R)^nat) : [set x%:E | x in \bigcup_i F i] =
                                    \bigcup_i (EFin @` F i).
Proof.
rewrite eqEsubset; split => [_ [r [n _ Fnr <-]]|]; first by exists n => //; exists r.
by move=> x [n _ [r Fnr <- /=]]; exists r => //; exists n.
Qed.

Lemma setC_EFin (B : set R) : [set x%:E | x in ~` B] =
                               (~` (EFin @` B)) `\` [set -oo%E; +oo%E].
Proof.
rewrite eqEsubset; split => [_ [r Br <-]|[r | |]].
  by split => [|[]//]; apply: contra_not Br => -[? ? [] <-].
- move=> [Br _]; apply/not_exists2P; apply: contra_not Br => h.
  by exists r => //; have [|//] := h r; apply: contrapT.
- by move=> -[_] /not_orP[_ /=].
- by move=> -[_] /not_orP[/=].
Qed.

(* TODO: improve with setC_EFin *)
Lemma setCU_R_ereal (A : set R) (B : set \bar R) : ps_infty B ->
  ~` ([set x%:E | x in A] `|` B) = [set x%:E | x in ~` A] `|` [set -oo%E; +oo%E] `&` ~` B.
Proof.
move=> ps_inftyB; rewrite setCU.
have -> : ~` [set x%:E | x in A] = [set x%:E | x in ~` A] `|` [set -oo; +oo]%E.
  rewrite predeqE => -[x| |]; split.
  - by move=> Ax; left; exists x => //; apply: contra_not Ax => Ax; exists x.
  - by move=> [[r Ar [<-{x}]]|[]//]; apply: contra_not Ar => -[x Ax [<-]].
  - by move=> _; right; right.
  - by move=> [[]|[] _ []].
  - by move=> _; right; left.
  - by move=> [[]|[_ []|]].
rewrite setIUl; congr (_ `|` _).
rewrite predeqE => -[x| |]; split; try by case.
move=> [] x' Ax' [] <-{x}; split; first by exists x'.
by case: ps_inftyB => // -[].
Qed.

Lemma emeasurableC (X : set \bar R) : emeasurable X -> emeasurable (~` X).
Proof.
move => -[A mA] [B PooB <-]; rewrite setCU_R_ereal //.
exists (~` A); [exact: measurableC | exists ([set -oo%E; +oo%E] `&` ~` B) => //].
case: PooB.
- by rewrite setC0 setIT; constructor.
- rewrite setIUl setICr set0U -setDE.
  have [_ ->] := @setDidPl (\bar R) [set +oo%E] [set -oo%E]; first by constructor.
  by rewrite predeqE => x; split => // -[->].
- rewrite setIUl setICr setU0 -setDE.
  have [_ ->] := @setDidPl (\bar R) [set -oo%E] [set +oo%E]; first by constructor.
  by rewrite predeqE => x; split => // -[->].
- by rewrite setICr; constructor.
Qed.

Lemma emeasurable_bigcup (F : (set \bar R)^nat) :
  (forall i, emeasurable (F i)) -> emeasurable (\bigcup_i (F i)).
Proof.
move=> mF; pose P := fun i j => measurableR j.1 /\ ps_infty j.2 /\
                            F i = [set x%:E | x in j.1] `|` j.2.
have [f fi] : {f : nat -> (set R) * (set \bar R) & forall i, P i (f i) }.
  by apply: choice => i; have [x mx [y PSoo'y] xy] := mF i; exists (x, y).
exists (\bigcup_i (f i).1).
  by apply: measurable_bigcup => i; exact: (fi i).1.
exists (\bigcup_i (f i).2).
  apply/ps_inftyP => x [n _] fn2x.
  have /ps_inftyP : ps_infty(f n).2 by have [_ []] := fi n.
  exact.
rewrite [RHS](@eq_bigcupr _ _ _ _
    (fun i => [set x%:E | x in (f i).1] `|` (f i).2)); last first.
  by move=> i; have [_ []] := fi i.
rewrite bigcupU; congr (_ `|` _).
rewrite predeqE => i /=; split=> [[r [n _ fn1r <-{i}]]|[n _ [r fn1r <-{i}]]];
 by [exists n => //; exists r | exists r => //; exists n].
Qed.

Definition ereal_isMeasurable : isMeasurable \bar R :=
  isMeasurable.Build _ emeasurable0 emeasurableC emeasurable_bigcup.

End salgebra_ereal.

Section puncture_ereal_itv.
Variable R : realDomainType.
Implicit Types (y : R) (b : bool).
Local Open Scope ereal_scope.

Lemma punct_eitv_bnd_pinfty b y : [set` Interval (BSide b y%:E) +oo%O] =
  EFin @` [set` Interval (BSide b y) +oo%O] `|` [set +oo].
Proof.
rewrite predeqE => x; split; rewrite /= in_itv andbT.
- move: x => [x| |] yxb; [|by right|by case: b yxb].
  by left; exists x => //; rewrite in_itv /= andbT; case: b yxb.
- move=> [[r]|->].
  + by rewrite in_itv /= andbT => yxb <-; case: b yxb.
  + by case: b => /=; rewrite ?(lte_pinfty, lee_pinfty).
Qed.

Lemma punct_eitv_ninfty_bnd b y : [set` Interval -oo%O (BSide b y%:E)] =
  [set -oo%E] `|` EFin @` [set x | x \in Interval -oo%O (BSide b y)].
Proof.
rewrite predeqE => x; split; rewrite /= in_itv.
- move: x => [x| |] yxb; [|by case: b yxb|by left].
  by right; exists x => //; rewrite in_itv /= andbT; case: b yxb.
- move=> [->|[r]].
  + by case: b => /=; rewrite ?(lte_ninfty, lee_ninfty).
  + by rewrite in_itv /= => yxb <-; case: b yxb.
Qed.

Lemma punct_eitv_setTR : [set of @EFin R] `|` [set +oo] = [set~ -oo].
Proof.
rewrite eqEsubset; split => [a [[a' _ <-]|->]|]; rewrite ?lte_ninfty//.
by move=> [x| |] //= _; [left; exists x|right].
Qed.

Lemma punct_eitv_setTL : [set of @EFin R] `|` [set -oo] = [set~ +oo].
Proof.
rewrite eqEsubset; split => [a [[a' _ <-]|->]|]; rewrite ?lte_ninfty//.
by move=> [x| |] //= _; [left; exists x|right].
Qed.

End puncture_ereal_itv.

Section salgebra_R_ssets.
Variable R : realType.

Fail Check forall (T : measurableType) (f : T -> R), measurable_fun setT f.

Definition measurableTypeR :=
  g_measurableType (@measurable (@sset_algebraOfSetsType R)).

Definition measurableR : set (set R) := @measurable measurableTypeR.

HB.instance Definition R_isMeasurable : isMeasurable R :=
  isMeasurable.Build measurableTypeR
  measurable0 (@measurableC _) (@measurable_bigcup _).
(*HB.instance (Real.sort R) R_isMeasurable.*)

Check forall (T : measurableType) (f : T -> R), measurable_fun setT f.

Lemma measurable_set1 (r : R) : measurable [set r].
Proof.
apply: g_salgebra_self => /=; exists [:: `[r, r]] => //=.
rewrite /sset /= big_cons /= big_nil setU0 /= set_itvE //.
rewrite predeqE => t; split => [<-|]; first by rewrite lexx.
by rewrite -eq_le => /eqP <-.
Qed.

Lemma measurable_itv (i : interval R) : measurable ([set` i]).
Proof. exact/g_salgebra_self/measurable_sset_itv. Qed.

(*HB.instance Definition _ :=
  Rbar_isMeasurable (@measurable (@sset_algebraOfSetsType R)).*)
HB.instance (\bar (Real.sort R))
  (ereal_isMeasurable (@measurable (@sset_algebraOfSetsType R))).
(* NB: this produces a warning but the alternative fails with Coq 8.12 with the
  following message (according to the CI):
  # [redundant-canonical-projection,typechecker]
  # forall (T : measurableType) (f : T -> R), measurable_fun setT f
  #      : Prop
  # File "./theories/lebesgue_measure.v", line 4508, characters 0-88:
  # Error: Anomaly "Uncaught exception Failure("sep_last")."
  # Please report at http://coq.inria.fr/bugs/.
*)

Check forall (T : measurableType) (f : T -> \bar R), measurable_fun setT f.

Lemma measurable_EFin (A : set R) : measurableR A -> measurable (EFin @` A).
Proof.
by move=> mA; exists A => //; exists set0; [constructor|rewrite setU0].
Qed.

Lemma emeasurable_set1 (x : \bar R) : measurable [set x].
Proof.
case: x => [r| |].
- by rewrite -image_set1; exact/measurable_EFin/measurable_set1.
- exists set0 => //; [exists [set +oo%E]; [by constructor|]].
  by rewrite image_set0 set0U.
- exists set0 => //; [exists [set -oo%E]; [by constructor|]].
  by rewrite image_set0 set0U.
Qed.

Lemma itv_cpinfty_pinfty : `[+oo%E, +oo[%classic = [set +oo%E] :> set (\bar R).
Proof.
rewrite set_itvE predeqE => t; split => /= [|<-//].
by rewrite lee_pinfty_eq => /eqP.
Qed.

Lemma itv_opinfty_pinfty : `]+oo%E, +oo[%classic = set0 :> set (\bar R).
Proof.
rewrite set_itvE predeqE => t; split => //=.
by apply/negP; rewrite -leNgt lee_pinfty.
Qed.

Lemma itv_cninfty_pinfty : `[-oo%E, +oo[%classic = setT :> set (\bar R).
Proof.
by rewrite set_itvE predeqE => t; split => //= _; rewrite lee_ninfty.
Qed.

Lemma itv_oninfty_pinfty : `]-oo%E, +oo[%classic = ~` [set -oo]%E :> set (\bar R).
Proof.
rewrite set_itvE predeqE => x; split => /=.
- by move: x => [x| |]; rewrite ?ltxx//.
- by move: x => [x h|//|/(_ erefl)]; rewrite ?lte_ninfty.
Qed.

Lemma emeasurable_itv_bnd_pinfty b (y : \bar R) :
  measurable [set` Interval (BSide b y) +oo%O].
Proof.
move: y => [y| |].
- exists [set` Interval (BSide b y) +oo%O]; first exact: measurable_itv.
  by exists [set +oo%E]; [constructor|rewrite -punct_eitv_bnd_pinfty].
- case: b; last by rewrite itv_opinfty_pinfty.
  by rewrite itv_cpinfty_pinfty; exact: emeasurable_set1.
- case: b; first by rewrite itv_cninfty_pinfty.
  by rewrite itv_oninfty_pinfty; exact/measurableC/emeasurable_set1.
Qed.

Lemma emeasurable_itv_ninfty_bnd b (y : \bar R) :
  measurable [set` Interval -oo%O (BSide b y)].
Proof.
by rewrite -set_itvC_bnd_infty; exact/measurableC/emeasurable_itv_bnd_pinfty.
Qed.

Definition elebesgue_measure' : set \bar R -> \bar R :=
  fun S => lebesgue_measure R (fine @` (S `\` [set -oo; +oo]%E)).

Lemma elebesgue_measure'0 : elebesgue_measure' set0 = 0%E.
Proof. by rewrite /elebesgue_measure' set0D image_set0 measure0. Qed.

Lemma measurable_fine (X : set \bar R) : measurable X ->
  measurable [set fine x | x in X `\` [set -oo; +oo]%E].
Proof.
case => Y mY [X' [ | <-{X} | <-{X} | <-{X} ]].
- rewrite setU0 => <-{X}.
  rewrite [X in measurable X](_ : _ = Y) // predeqE => r; split.
    by move=> [x [[x' Yx' <-{x}/= _ <-//]]].
  by move=> Yr; exists r%:E; split => [|[]//]; exists r.
- rewrite [X in measurable X](_ : _ = Y) // predeqE => r; split.
    move=> [x [[[x' Yx' <- _ <-//]|]]].
    by move=> <-; rewrite not_orP => -[]/(_ erefl).
  by move=> Yr; exists r%:E => //; split => [|[]//]; left; exists r.
- rewrite [X in measurable X](_ : _ = Y) // predeqE => r; split.
    move=> [x [[[x' Yx' <-{x} _ <-//]|]]].
    by move=> ->; rewrite not_orP => -[_]/(_ erefl).
  by move=> Yr; exists r%:E => //; split => [|[]//]; left; exists r.
- rewrite [X in measurable X](_ : _ = Y) // predeqE => r; split.
    by rewrite setDUl setDv setU0 => -[_ [[x' Yx' <-]] _ <-].
  by move=> Yr; exists r%:E => //; split => [|[]//]; left; exists r.
Qed.

Lemma elebesgue_measure'_ge0 X : measurable X -> (0 <= elebesgue_measure' X)%E.
Proof. by move=> /= mX; exact/measure_ge0/measurable_fine. Qed.

Lemma semi_sigma_additive_elebesgue_measure' :
  semi_sigma_additive elebesgue_measure'.
Proof.
move=> /= F mF tF mUF; rewrite /elebesgue_measure'.
rewrite [X in lebesgue_measure _ X](_ : _ =
    \bigcup_n (fine @` (F n `\` [set -oo; +oo]%E))); last first.
  rewrite predeqE => r; split.
    by move=> [x [[n _ Fnx xoo <-]]]; exists n => //; exists x.
  by move=> [n _ [x [Fnx xoo <-{r}]]]; exists x => //; split => //; exists n.
apply: (@measure_semi_sigma_additive _ _ (@lebesgue_measure R)
  (fun n => fine @` (F n `\` [set -oo; +oo]%E))).
- move=> n; have := mF n.
  move=> [X mX [X' mX']] XX'Fn.
  apply: measurable_fine.
  rewrite -XX'Fn.
  apply: measurableU; first exact: measurable_EFin.
  case: mX'; [by [] |exact: emeasurable_set1
                    |exact: emeasurable_set1|].
  by apply: measurableU; exact: emeasurable_set1.
- move=> i j _ _ [x [[a [Fia aoo ax] [b [Fjb boo] bx]]]].
  move: tF => /(_ i j Logic.I Logic.I); apply.
  suff ab : a = b by exists a; split => //; rewrite ab.
  move: a b {Fia Fjb} aoo boo ax bx.
  move=> [a| |] [b| |] /=.
  + by move=> _ _ -> ->.
  + by move=> _; rewrite not_orP => -[_]/(_ erefl).
  + by move=> _; rewrite not_orP => -[]/(_ erefl).
  + by rewrite not_orP => -[_]/(_ erefl).
  + by rewrite not_orP => -[_]/(_ erefl).
  + by rewrite not_orP => -[_]/(_ erefl).
  + by rewrite not_orP => -[]/(_ erefl).
  + by rewrite not_orP => -[]/(_ erefl).
  + by rewrite not_orP => -[]/(_ erefl).
- move: mUF.
  rewrite {1}/measurable /emeasurable /= => -[X mX [Y []]] {Y}.
  - rewrite setU0 => h.
    rewrite [X in measurable X](_ : _ = X) // predeqE => r; split => [|Xr].
      move=> -[n _ [x [Fnx xoo <-{r}]]].
      have : (\bigcup_n F n) x by exists n.
      by rewrite -h => -[x' Xx' <-].
    have [n _ Fnr] : (\bigcup_n F n) r%:E by rewrite -h; exists r.
    by exists n => //; exists r%:E => //; split => //; case.
  - move=> h.
    rewrite [X in measurable X](_ : _ = X) // predeqE => r; split => [|Xr].
      move=> -[n _ [x [Fnx xoo <-]]].
      have : (\bigcup_n F n) x by exists n.
      by rewrite -h => -[[x' Xx' <-//]|xoo']; move/not_orP : xoo => -[].
    have [n _ Fnr] : (\bigcup_n F n) r%:E by rewrite -h; left; exists r.
    by exists n => //; exists r%:E => //; split => //; case.
  - (* NB: almost the same as the previous one, factorize?*)
    move=> h.
    rewrite [X in measurable X](_ : _ = X) // predeqE => r; split => [|Xr].
      move=> -[n _ [x [Fnx xoo <-]]].
      have : (\bigcup_n F n) x by exists n.
      by rewrite -h => -[[x' Xx' <-//]|xoo']; move/not_orP : xoo => -[].
    have [n _ Fnr] : (\bigcup_n F n) r%:E by rewrite -h; left; exists r.
    by exists n => //; exists r%:E => //; split => //; case.
  - move=> h.
    rewrite [X in measurable X](_ : _ = X) // predeqE => r; split => [|Xr].
      move=> -[n _ [x [Fnx xoo <-]]].
      have : (\bigcup_n F n) x by exists n.
      by rewrite -h => -[[x' Xx' <-//]|].
    have [n _ Fnr] : (\bigcup_n F n) r%:E by rewrite -h; left; exists r.
    by exists n => //; exists r%:E => //; split => //; case.
Qed.

Definition elebesgue_measure_isMeasure : is_measure elebesgue_measure' :=
  Measure.Axioms elebesgue_measure'0 elebesgue_measure'_ge0
                 semi_sigma_additive_elebesgue_measure'.

Definition elebesgue_measure : {measure set \bar R -> \bar R} :=
  Measure.Pack _ elebesgue_measure_isMeasure.

End salgebra_R_ssets.

(* TODO: move *)
Lemma preimage_itv T (d : unit) (rT : porderType d) (f : T -> rT) (i : interval rT) (x : T) :
  ((f @^-1` [set` i]) x) = (f x \in i).
Proof. by rewrite inE. Qed.

Lemma preimage_itv_o_infty T (d : unit) (rT : porderType d) (f : T -> rT) y :
  f @^-1` `]y, +oo[%classic = [set x | (y < f x)%O].
Proof.
by rewrite predeqE => t; split => /= [|?]; rewrite preimage_itv in_itv/= andbT.
Qed.

Lemma preimage_itv_c_infty T (d : unit) (rT : porderType d) (f : T -> rT) y :
  f @^-1` `[y, +oo[%classic = [set x | (y <= f x)%O].
Proof.
by rewrite predeqE => t; split => [|?]; rewrite preimage_itv in_itv/= andbT.
Qed.

Lemma preimage_itv_infty_o T (d : unit) (rT : orderType d) (f : T -> rT) y :
  f @^-1` `]-oo, y[%classic = [set x | (f x < y)%O].
Proof. by rewrite predeqE => t; split => [|?]; rewrite preimage_itv in_itv. Qed.

Lemma preimage_itv_infty_c T (d : unit) (rT : orderType d) (f : T -> rT) y :
  f @^-1` `]-oo, y]%classic = [set x | (f x <= y)%O].
Proof. by rewrite predeqE => t; split => [|?]; rewrite preimage_itv in_itv. Qed.

Section measurable_fun_measurable.
Local Open Scope ereal_scope.
Variables (T : measurableType) (R : realType) (D : set T) (f : T -> \bar R).
Hypotheses (mD : measurable D) (mf : measurable_fun D f).
Implicit Types y : \bar R.

Lemma emeasurable_fun_c_infty y : measurable ([set x | y <= f x] `&` D).
Proof.
by rewrite -preimage_itv_c_infty; exact/mf/emeasurable_itv_bnd_pinfty.
Qed.

Lemma emeasurable_fun_o_infty y :  measurable ([set x | y < f x] `&` D).
Proof.
by rewrite -preimage_itv_o_infty; exact/mf/emeasurable_itv_bnd_pinfty.
Qed.

Lemma emeasurable_fun_infty_o y : measurable ([set x | f x < y] `&` D).
Proof.
by rewrite -preimage_itv_infty_o; exact/mf/emeasurable_itv_ninfty_bnd.
Qed.

Lemma emeasurable_fun_infty_c y : measurable ([set x | f x <= y] `&` D).
Proof.
by rewrite -preimage_itv_infty_c; exact/mf/emeasurable_itv_ninfty_bnd.
Qed.

Lemma emeasurable_fin_num : measurable ([set x | f x \is a fin_num] `&` D).
Proof.
rewrite [X in measurable X](_ : _ =
  \bigcup_k (([set  x | - k%:R%:E <= f x] `&` [set x | f x <= k%:R%:E]) `&` D)).
  apply: measurable_bigcup => k; rewrite -(setIid D) setIACA.
  by apply: measurableI; [exact: emeasurable_fun_c_infty|
                          exact: emeasurable_fun_infty_c].
rewrite predeqE => t; split => [/= [ft Dt]|].
  have [ft0|ft0] := leP 0%R (fine (f t)).
    exists `|ceil (fine (f t))|%N => //=; split => //; split.
      by rewrite -{2}(fineK ft)// lee_fin (le_trans _ ft0)// ler_oppl oppr0.
    by rewrite natr_absz ger0_norm ?ceil_ge0// -(fineK ft) lee_fin ceil_ge.
  exists `|floor (fine (f t))|%N => //=; split => //; split.
    rewrite natr_absz ltr0_norm ?floor_lt0// EFinN.
    by rewrite -{2}(fineK ft) lee_fin mulrNz opprK floor_le.
  by rewrite -(fineK ft)// lee_fin (le_trans (ltW ft0)).
move=> [n _] [/= [nft fnt Dt]]; split => //; rewrite fin_numElt.
by rewrite (lt_le_trans _ nft) ?lte_ninfty//= (le_lt_trans fnt)// lte_pinfty.
Qed.

Lemma emeasurable_neq y : measurable ([set x | f x != y] `&` D).
Proof.
rewrite (_ : [set x | f x != y] = f @^-1` (setT `\ y)); last first.
  rewrite predeqE => t; split.
    by rewrite /= => ft0; rewrite /preimage /=; split => //; exact/eqP.
  by rewrite /preimage /= => -[_ /eqP].
by apply/mf/measurableD => //; exact/emeasurable_set1.
Qed.

End measurable_fun_measurable.

Module RGenOInfty.
Section rgenoinfty.
Variable R : realType.
Implicit Types x y z : R.

Definition G := [set A | exists x, A = `]x, +oo[%classic].
Let T := g_measurableType G.

Lemma measurable_itv_bnd_infty b x :
  @measurable T [set` Interval (BSide b x) +oo%O].
Proof.
case: b; last by apply g_salgebra_self; eexists; reflexivity.
rewrite itv_c_inftyEbigcap; apply: measurable_bigcap => i.
by apply g_salgebra_self; eexists; reflexivity.
Qed.

Lemma measurable_itv_bounded a b x : a != +oo%O ->
  @measurable T [set` Interval a (BSide b x)].
Proof.
case: a => [a r _|[_|//]].
  rewrite itv_boundedErays; apply/measurableD => //;
    exact: measurable_itv_bnd_infty.
by rewrite -set_itvC_bnd_infty; exact/measurableC/measurable_itv_bnd_infty.
Qed.

Lemma measurableE :
  @measurable (g_measurableType (@Sset.is_sset R)) = @measurable T.
Proof.
rewrite eqEsubset; split => A; last first.
  apply: subset_g_salgebra => A' /= [x ->]; exists [:: `]x, +oo[ ].
  by rewrite /sset big_cons big_nil setU0.
apply: g_salgebra_smallest; last exact: are_measurable_sets_g_salgebra.
move=> _ [s ->] {A}; elim: s => [|h t ih]; first by rewrite /sset big_nil.
rewrite /sset big_cons; apply: measurableU => //.
by move: h => [[a x|a] [b y|b]]; move: a b => [] []; solve
  [exact: measurable_itv_bounded | exact: measurable_itv_bnd_infty |
   by rewrite set_itvE].
Qed.

End rgenoinfty.
End RGenOInfty.

Module RGenInftyO.
Section rgeninftyo.
Variable R : realType.
Implicit Types x y z : R.

Definition G := [set A | exists x, A = `]-oo, x[%classic].
Let T := g_measurableType G.

Lemma measurable_itv_bnd_infty b x :
  @measurable T [set` Interval -oo%O (BSide b x)].
Proof.
case: b; last first.
  rewrite -[X in measurable X]setCK set_itvC itv_o_inftyEbigcup.
  apply/measurableC/measurable_bigcup => n; rewrite -[X in measurable X]setCK.
  apply: measurableC; rewrite set_itvC.
  by apply: g_salgebra_self; eexists; reflexivity.
by apply g_salgebra_self; eexists; reflexivity.
Qed.

Lemma measurable_itv_bounded a b x : a != -oo%O ->
  @measurable T [set` Interval (BSide b x) a].
Proof.
case: a => [a r _|[//|_]].
  rewrite itv_boundedErays; apply/measurableD => //;
    rewrite -[X in measurable X]setCK; apply: measurableC; rewrite set_itvC;
    exact: measurable_itv_bnd_infty.
by rewrite -set_itvC_infty_bnd; exact/measurableC/measurable_itv_bnd_infty.
Qed.

Lemma measurableE :
  @measurable (g_measurableType (@Sset.is_sset R)) = @measurable T.
Proof.
rewrite eqEsubset; split => A; last first.
  apply: subset_g_salgebra => A' /= [x ->]; exists [:: `]-oo, x[ ].
  by rewrite /sset big_cons big_nil setU0.
apply: g_salgebra_smallest; last exact: are_measurable_sets_g_salgebra.
move=> _ [s ->] {A}; elim: s => [|h t ih]; first by rewrite /sset big_nil.
rewrite /sset big_cons; apply: measurableU => //.
by move: h => [[a x|a] [b y|b]]; move: a b => [] []; solve
  [exact: measurable_itv_bounded | exact: measurable_itv_bnd_infty |
   by rewrite set_itvE].
Qed.

End rgeninftyo.
End RGenInftyO.

Module RGenCInfty.
Section rgencinfty.
Variable R : realType.
Implicit Types x y z : R.

Definition G : set (set R) := [set A | exists x, A = `[x, +oo[%classic].
Let T := g_measurableType G.

Lemma measurable_itv_bnd_infty b x :
  @measurable T [set` Interval (BSide b x) +oo%O].
Proof.
case: b; first by apply: g_salgebra_self; exists x; rewrite set_itv_c_infty.
rewrite itv_o_inftyEbigcup; apply: measurable_bigcup => i.
by apply: g_salgebra_self; eexists; reflexivity.
Qed.

Lemma measurable_itv_bounded a b y : a != +oo%O ->
  @measurable T [set` Interval a (BSide b y)].
Proof.
case: a => [a r _|[_|//]].
  rewrite itv_boundedErays.
  by apply: measurableD; apply: measurable_itv_bnd_infty.
by rewrite -set_itvC_bnd_infty; exact/measurableC/measurable_itv_bnd_infty.
Qed.

Lemma measurableE :
  @measurable (g_measurableType (@Sset.is_sset R)) = @measurable T.
Proof.
rewrite eqEsubset; split => A; last first.
  apply: subset_g_salgebra => B /= [x ->]; exists [:: `[x, +oo[ ].
  by rewrite /sset big_cons big_nil setU0 set_itv_c_infty.
apply: g_salgebra_smallest; last exact: are_measurable_sets_g_salgebra.
move=> _ [s ->] {A}; elim: s => [|h t ih]; first by rewrite /sset big_nil.
rewrite /sset big_cons; apply: measurableU => //.
by move: h => [[a x|a] [b y|b]]; move: a b => [] []; solve
  [exact: measurable_itv_bounded | exact: measurable_itv_bnd_infty |
   by rewrite set_itvE].
Qed.

End rgencinfty.
End RGenCInfty.

Module RGenOpens.
Section rgenopens.

Variable R : realType.
Implicit Types x y z : R.

Definition G := [set A | exists x y, A = `]x, y[%classic].
Let T := g_measurableType G.

Local Lemma measurable_itvoo x y : @measurable T `]x, y[%classic.
Proof. by apply g_salgebra_self; eexists; eexists; reflexivity. Qed.

Local Lemma measurable_itv_o_infty x : @measurable T `]x, +oo[%classic.
Proof.
rewrite itv_bnd_inftyEbigcup; apply: measurable_bigcup => i.
exact: measurable_itvoo.
Qed.

Lemma measurable_itv_bnd_infty b x :
  @measurable T [set` Interval (BSide b x) +oo%O].
Proof.
case: b; last exact: measurable_itv_o_infty.
rewrite itv_c_inftyEbigcap; apply: measurable_bigcap => i.
exact/measurable_itv_o_infty.
Qed.

Lemma measurable_itv_infty_bnd b x :
  @measurable T [set` Interval -oo%O (BSide b x)].
Proof.
case: b.
- by rewrite -set_itvC_bnd_infty; exact/measurableC/measurable_itv_bnd_infty.
- by rewrite -set_itvC_bnd_infty; exact/measurableC/measurable_itv_o_infty.
Qed.

Lemma measurable_itv_bounded a x b y :
  @measurable T [set` Interval (BSide a x) (BSide b y)].
Proof.
move: a b => [] []; rewrite -[X in measurable X]setCK set_itvC_itv;
  apply: measurableC; apply: measurableU; try solve[
    exact: measurable_itv_infty_bnd|exact: measurable_itv_bnd_infty].
Qed.

Lemma measurableE :
  @measurable (g_measurableType (@Sset.is_sset R)) = @measurable T.
Proof.
rewrite eqEsubset; split => A; last first.
  apply: subset_g_salgebra => B /= [x [y ->]]; exists [:: `]x, y[ ].
  by rewrite /sset big_cons big_nil setU0.
apply: g_salgebra_smallest; last by apply: are_measurable_sets_g_salgebra.
move=> _ [s ->] {A}; elim: s => [|h t ih]; first by rewrite /sset big_nil.
rewrite /sset big_cons; apply: measurableU => //.
by move: h => [[a x|a] [b y|b]]; move: a b => [] []; solve[
  exact: measurable_itv_bounded | exact: measurable_itv_infty_bnd |
  exact: measurable_itv_bnd_infty | by rewrite set_itvE].
Qed.

End rgenopens.
End RGenOpens.

Section erealwithrays.
Variable R : realType.
Implicit Types (x y z : \bar R) (r s : R).
Local Open Scope ereal_scope.

Lemma EFin_itv_bnd_infty b r : EFin @` [set` Interval (BSide b r) +oo%O] =
  [set` Interval (BSide b r%:E) +oo%O] `\ +oo.
Proof.
rewrite eqEsubset; split => [x [s /itvP rs <-]|x []].
  split => //=; rewrite in_itv /=.
  by case: b in rs *; rewrite /= ?(lee_fin, lte_fin) rs.
move: x => [s|_ /(_ erefl)|] //=; rewrite in_itv /= andbT; last first.
  by case: b => /=; rewrite 1?(leNgt,ltNge) 1?(lte_ninfty,lee_ninfty).
by case: b => /=; rewrite 1?(lte_fin,lee_fin) => rs _;
  exists s => //; rewrite in_itv /= rs.
Qed.

Lemma EFin_itv r : [set s | r%:E < s%:E] = `]r, +oo[%classic.
Proof.
by rewrite predeqE => s; split => [|]; rewrite /= lte_fin in_itv/= andbT.
Qed.

Lemma preimage_EFin_setT : @EFin R @^-1` [set x | x \in `]-oo%E, +oo[] = setT.
Proof.
by rewrite set_itvE predeqE => r; split=> // _; rewrite /preimage /= lte_ninfty.
Qed.

Lemma eitv_c_infty r : `[r%:E, +oo[%classic =
  \bigcap_k `](r - k.+1%:R^-1)%:E, +oo[%classic :> set _.
Proof.
rewrite predeqE => x; split=> [|].
- move: x => [s /=| _ n _|//].
  + rewrite in_itv /= andbT lee_fin => rs n _ /=.
    rewrite in_itv /= andbT lte_fin.
    by rewrite ltr_subl_addl (le_lt_trans rs)// ltr_addr invr_gt0.
  + by rewrite /= in_itv /= andbT lte_pinfty.
- move: x => [s| |/(_ 0%N Logic.I)] //=; last by rewrite in_itv /= lee_pinfty.
  move=> h; rewrite in_itv /= lee_fin leNgt andbT; apply/negP.
  move=> /ltr_add_invr[k skr]; have {h} := h k Logic.I.
  rewrite /= in_itv /= andbT lte_fin ltNge => /negP; apply.
  by rewrite -ler_subl_addr opprK ltW.
Qed.

Lemma eitv_infty_c r : `]-oo, r%:E]%classic =
  \bigcap_k `]-oo, (r%:E + k.+1%:R^-1%:E)]%classic :> set _.
Proof.
rewrite predeqE => x; split=> [|].
- move: x => [s /=|//|_ n _].
  + rewrite in_itv /= lee_fin => sr n _; rewrite /= in_itv /=.
    by rewrite -EFinD lee_fin (le_trans sr)// ler_addl invr_ge0.
  + by rewrite /= in_itv /= -EFinD lee_ninfty.
- move: x => [s|/(_ 0%N Logic.I)//|]/=; rewrite ?in_itv /= ?lee_ninfty//.
  move=> h; rewrite lee_fin leNgt; apply/negP => /ltr_add_invr[k rks].
  have {h} := h k Logic.I; rewrite /= in_itv /=.
  by rewrite -EFinD lee_fin leNgt => /negP; apply.
Qed.

Lemma eset1_ninfty :
  [set -oo] = \bigcap_k `]-oo, (-k%:R%:E)[%classic :> set (\bar R).
Proof.
rewrite eqEsubset; split=> [_ -> i _ |].
  by rewrite /= in_itv /= lte_ninfty.
move=> [r|/(_ O Logic.I)|]//.
move=> /(_ `|floor r|%N Logic.I); rewrite /= in_itv/= ltNge.
rewrite lee_fin; have [r0|r0] := leP 0%R r.
  by rewrite (le_trans _ r0) // ler_oppl oppr0 ler0n.
rewrite ler_oppl -abszN natr_absz gtr0_norm; last first.
  by rewrite ltr_oppr oppr0 floor_lt0.
by rewrite mulrNz ler_oppl opprK floor_le.
Qed.

Lemma eset1_pinfty :
  [set +oo] = \bigcap_k `]k%:R%:E, +oo[%classic :> set (\bar R).
Proof.
rewrite eqEsubset; split=> [_ -> i _/=|]; first by rewrite in_itv /= lte_pinfty.
move=> [r| |/(_ O Logic.I)] // /(_ `|ceil r|%N Logic.I); rewrite /= in_itv /=.
rewrite andbT lte_fin ltNge.
have [r0|r0] := ltP 0%R r; last by rewrite (le_trans r0).
by rewrite natr_absz gtr0_norm // ?ceil_ge// ceil_gt0.
Qed.

End erealwithrays.

Module ErealGenOInfty.
Section erealgenoinfty.
Variable R : realType.
Implicit Types (x y z : \bar R) (r s : R).

Local Open Scope ereal_scope.

Definition G := [set A : set \bar R | exists x, A = `]x, +oo[%classic].
Let T := g_measurableType G.

Lemma measurable_set1_ninfty : @measurable T [set -oo].
Proof.
rewrite eset1_ninfty; apply: (@measurable_bigcap T) => i.
rewrite -set_itvC_bnd_infty; apply: measurableC; rewrite eitv_c_infty.
apply: measurable_bigcap => j; apply: g_salgebra_self.
by exists (- (i%:R + j.+1%:R^-1))%:E; rewrite opprD.
Qed.

Lemma measurable_set1_pinfty : @measurable T [set +oo].
Proof.
rewrite eset1_pinfty; apply: measurable_bigcap => i.
by apply: g_salgebra_self; exists i%:R%:E.
Qed.

Lemma measurableE : emeasurable (@Sset.is_sset R) = @measurable T.
Proof.
rewrite eqEsubset; split => A; last first.
  elim => [_ [x ->] | | |]; [|exact: emeasurable0| |].
  - rewrite /emeasurable /=; move: x => [r| |].
    + exists `]r, +oo[%classic.
        rewrite RGenOInfty.measurableE.
        exact: RGenOInfty.measurable_itv_bnd_infty.
      by exists [set +oo]; [constructor|rewrite -punct_eitv_bnd_pinfty].
    + exists set0 => //.
      by exists set0; [constructor|rewrite setU0 itv_opinfty_pinfty image_set0].
    + exists setT => //; exists [set +oo]; first by constructor.
      by rewrite itv_oninfty_pinfty punct_eitv_setTR.
  - by move=> *; rewrite setTD; exact: emeasurableC.
  - by move=> *; exact: emeasurable_bigcup.
move=> [B mB [C mC]] <-; apply: measurableU; last first.
  case: mC; [by []|exact: measurable_set1_ninfty
                  |exact: measurable_set1_pinfty|].
  - by apply: measurableU; [exact: measurable_set1_ninfty|
                            exact: measurable_set1_pinfty].
rewrite RGenOInfty.measurableE in mB.
elim: mB => [_ /= [r ->]| |D sD mD|F sF mF].
- rewrite EFin_itv_bnd_infty; apply: measurableD.
    by apply g_salgebra_self => /=; exists r%:E.
  exact: measurable_set1_pinfty.
- by rewrite image_set0.
- rewrite setTD setC_EFin; apply: measurableD; first exact: measurableC.
  by apply: measurableU; [exact: measurable_set1_ninfty|
                          exact: measurable_set1_pinfty].
- by rewrite bigcup_EFIn; apply: measurable_bigcup => i; exact: mF.
Qed.

End erealgenoinfty.
End ErealGenOInfty.

Module ErealGenCInfty.
Section erealgencinfty.
Variable R : realType.
Implicit Types (x y z : \bar R) (r s : R).
Local Open Scope ereal_scope.

Definition G := [set A : set \bar R | exists x, A = `[x, +oo[%classic].
Let T := g_measurableType G.

Lemma measurable_set1_ninfty : @measurable T [set -oo].
Proof.
rewrite eset1_ninfty; apply: measurable_bigcap=> i; rewrite -set_itvC_bnd_infty.
by apply: measurableC; apply: g_salgebra_self; exists (- i%:R)%:E.
Qed.

Lemma measurable_set1_pinfty : @measurable T [set +oo].
Proof.
apply: g_salgebra_self; exists +oo; rewrite predeqE => x; split => [->//|/=].
by rewrite in_itv /= andbT lee_pinfty_eq => /eqP ->.
Qed.

Lemma measurableE : emeasurable (@Sset.is_sset R) = @measurable T.
Proof.
rewrite eqEsubset; split => A; last first.
  elim => [_ [x ->]| | |]; [|exact: emeasurable0| |].
  - rewrite /emeasurable /=; move: x => [r| |].
    + exists `[r, +oo[%classic.
        rewrite RGenOInfty.measurableE.
        exact: RGenOInfty.measurable_itv_bnd_infty.
      by exists [set +oo]; [constructor | rewrite -punct_eitv_bnd_pinfty].
    + exists set0 => //; exists [set +oo]; first by constructor.
      by rewrite image_set0 set0U itv_cpinfty_pinfty.
    + exists setT => //; exists [set -oo; +oo]; first by constructor.
      by rewrite itv_cninfty_pinfty setUA punct_eitv_setTL setUCl.
    + by move=> *; rewrite setTD; exact: emeasurableC.
    + by move=> *; exact: emeasurable_bigcup.
move=> [A' mA' [C mC]] <-; apply: measurableU; last first.
  case: mC; [by []|exact: measurable_set1_ninfty|
                   exact: measurable_set1_pinfty|].
  by apply: measurableU; [exact: measurable_set1_ninfty|
                          exact: measurable_set1_pinfty].
rewrite RGenCInfty.measurableE in mA'.
elim: mA' => [_ /= [r ->]| |B sB mB|F sF mF].
- rewrite EFin_itv_bnd_infty; apply: measurableD.
    by apply g_salgebra_self => /=; exists r%:E.
  exact: measurable_set1_pinfty.
- by rewrite image_set0.
- rewrite setTD setC_EFin; apply: measurableD; first exact: measurableC.
  by apply: measurableU; [exact: measurable_set1_ninfty|
                          exact: measurable_set1_pinfty].
- by rewrite bigcup_EFIn; apply: measurable_bigcup => i; exact: mF.
Qed.

End erealgencinfty.
End ErealGenCInfty.

(* NB: PR 435 in progress *)
From mathcomp Require Import rat.

Definition pair_of_rat (q : rat) : nat * nat :=
  let x := numq q in let y := denq q in
  (if x >= 0 then `|x|.*2 else `|x|.*2.+1, `|y|.-1).

Lemma pair_of_rat_inj : {in setT &, injective pair_of_rat}.
Proof.
move=> x y _ _; rewrite /pair_of_rat.
have [x_ge0|x_gt0] := leP 0 (numq x); have [y_ge0|y_gt0] := leP 0 (numq y).
- case=> /eqP; rewrite -!muln2 eqn_mul2r => /eqP/(congr1 Posz).
  rewrite !gez0_abs// => numqxy /(congr1 S); rewrite ?(prednK,absz_gt0)//.
  move=> /(congr1 Posz); rewrite 2!absz_denq => dxy; apply/eqP.
  by rewrite rat_eqE numqxy dxy 2!eqxx.
- by case=> /(congr1 odd); rewrite /= 2!odd_double.
- by case=> /(congr1 odd); rewrite /= 2!odd_double.
- case=> /eqP; rewrite -!muln2 eqn_mul2r => /eqP/(congr1 Posz).
  rewrite !ltz0_abs// => /eqP; rewrite eqr_opp => /eqP numqxy /(congr1 S).
  rewrite ?(prednK,absz_gt0)// => /(congr1 Posz); rewrite 2!absz_denq => dxy.
  by apply/eqP; rewrite rat_eqE numqxy dxy 2!eqxx.
Qed.

Lemma countable_rat : countable (@setT rat).
Proof.
apply/countable_injective; have [f [inj_f _]] := countable_prod_nat.
exists (f \o pair_of_rat); apply: (@in_inj_comp _ _ _ _ _ xpredT) => //.
by move=> x y _ _ /inj_f; apply; rewrite inE.
exact: pair_of_rat_inj.
Qed.

Definition nat_of_rat := nat_of_pair \o pair_of_rat.

Lemma nat_of_rat_inj : {in setT &, injective nat_of_rat}.
Proof.
apply: (in_inj_comp nat_of_pair_inj pair_of_rat_inj).
by move=> q _; rewrite inE.
Qed.

Definition rat_of_nat : nat -> rat := inverse 0%Q setT nat_of_rat.

Lemma nat_of_ratK : {in setT, cancel nat_of_rat rat_of_nat}.
Proof.
by apply: injective_left_inverse; exact: nat_of_rat_inj.
Qed.
(* /NB: PR 435 in progress *)

(* TODO: move to measure.v once PR 435 is merged *)
Lemma measurable_bigcup_rat (T : measurableType) (F : rat -> set T) :
  (forall i, measurable (F i)) -> measurable (\bigcup_i F i).
Proof.
move=> mF.
rewrite [X in measurable X](_ : _ = \bigcup_i F (rat_of_nat i)); last first.
  rewrite predeqE => r; split => [[q _ Fqr]|[n _ Fnr]].
    by exists (nat_of_rat q) => //; rewrite nat_of_ratK => //; rewrite inE.
  by exists (rat_of_nat n).
by apply: measurable_bigcup => i; exact/mF.
Qed.

Section trace.
Variable (T : Type).
Implicit Types (G : set (set T)) (A D : set T).

(* intended as a trace sigma-algebra *)
Definition strace G D := [set x `&` D | x in G].

Lemma stracexx G D : G D -> strace G D D.
Proof. by rewrite /strace /=; exists D => //; rewrite setIid. Qed.

Lemma are_measurable_sets_strace G D :
  are_measurable_sets setT G -> are_measurable_sets D (strace G D).
Proof.
move=> [G0 GC GU]; split; first by exists set0 => //; rewrite set0I.
- move=> S [A mA ADS]; have mCA := GC _ mA.
  have : strace G D (D `&` ~` A).
    by rewrite setIC; exists (setT `\` A) => //; rewrite setTD.
  rewrite -setDE => trDA.
  have DADS : D `\` A = D `\` S by rewrite -ADS !setDE setCI setIUr setICr setU0.
  by rewrite DADS in trDA.
- move=> S mS; have /choice[M GM] : forall n, exists A, G A /\ S n = A `&` D.
    by move=> n; have [A mA ADSn] := mS n; exists A.
  exists (\bigcup_i (M i)); first by apply GU => i;  exact: (GM i).1.
  by rewrite setI_bigcupl; apply eq_bigcupr => i _; rewrite (GM i).2.
Qed.

End trace.

(* TODO: PR limit inferior and limit superior *)
Section sdrop.
Variable R : realFieldType.
Implicit Types (r : R) (u : R^o^nat).

Definition sdrop T (u : T^nat) n := [set u k | k in [set k | k >= n]]%N.

Lemma has_lbound_sdrop u : has_lbound [set of u] ->
  forall m, has_lbound (sdrop u m).
Proof.
by move=> [M uM] n; exists M => _ [m /= nm] <-; rewrite uM //; exists m.
Qed.

Lemma has_ubound_sdrop u : has_ubound [set of u] ->
  (forall m, has_ubound (sdrop u m)).
Proof.
by move=> [M uM] n; exists M => _ [m /= nm] <-; rewrite uM //; exists m.
Qed.

End sdrop.

Section sups_infs.
Variable R : realType.
Implicit Types (r : R) (u : R^o^nat).

Definition sups u := [sequence sup (sdrop u n)]_n.

Definition infs u := [sequence inf (sdrop u n)]_n.

Lemma supsN u : sups (-%R \o u) = - infs u.
Proof.
rewrite funeqE => n; rewrite /sups /infs /inf /= opprK; congr (sup _).
by rewrite predeqE => x; split => [[m /= nm <-]|[_ [m /= nm] <-] <-];
  [exists (u m) => //; exists m | exists m].
Qed.

Lemma infsN u : infs (-%R \o u) = - sups u.
Proof.
apply/eqP; rewrite -eqr_oppLR -supsN; apply/eqP; congr (sups _).
by rewrite funeqE => ? /=; rewrite opprK.
Qed.

Lemma nonincreasing_sups u : has_ubound [set of u] ->
  nonincreasing_seq (sups u).
Proof.
move=> u_ub m n mn; apply: le_sup => [_ /= [p np] <-| |].
- by apply/downP; exists (u p) => //=; exists p => //; exact: leq_trans np.
- by exists (u n) => /=; exists n => /=.
- by split; [exists (u m); exists m => //=|exact/has_ubound_sdrop].
Qed.

Lemma nondecreasing_infs u : has_lbound [set of u] ->
  nondecreasing_seq (infs u).
Proof.
move=> u_lb; rewrite -nonincreasing_opp -supsN; apply/nonincreasing_sups.
by move: u_lb => /has_lb_ubN; rewrite /comp /= image_comp.
Qed.

Lemma is_cvg_sups u : cvg u -> cvg (sups u).
Proof.
move=> cf; have [M [Mreal Mu]] := cvg_seq_bounded cf.
apply: nonincreasing_is_cvg.
  exact/nonincreasing_sups/bounded_fun_has_ubound/cvg_seq_bounded.
exists (- (M + 1)) => _ [n _ <-]; rewrite (@le_trans _ _ (u n)) //.
  by apply/lerNnormlW/Mu => //; rewrite ltr_addl.
apply: sup_ub; last by exists n => /=.
exact/has_ubound_sdrop/bounded_fun_has_ubound/cvg_seq_bounded.
Qed.

Lemma is_cvg_infs u : cvg u -> cvg (infs u).
Proof.
move/is_cvgN/is_cvg_sups; rewrite supsN.
by move/(@is_cvgN _ [normedModType R of R^o]); rewrite opprK.
Qed.

Lemma infs_le_sups u n : cvg u -> infs u n <= sups u n.
Proof.
move=> cu; rewrite /infs /sups /=; set A := sdrop _ _.
have [a Aa] : A !=set0 by exists (u n); rewrite /A /=; exists n => //=.
rewrite (@le_trans _ _ a) //; [apply/inf_lb|apply/sup_ub] => //.
- exact/has_lbound_sdrop/bounded_fun_has_lbound/cvg_seq_bounded.
- exact/has_ubound_sdrop/bounded_fun_has_ubound/cvg_seq_bounded.
Qed.

Lemma cvg_sups_inf u : has_ubound [set of u] -> has_lbound [set of u] ->
  sups u --> inf [set of sups u].
Proof.
move=> u_ub u_lb.
apply: nonincreasing_cvg; first exact: nonincreasing_sups.
case: u_lb => M uM; exists M => _ [n _ <-].
rewrite (@le_trans _ _ (u n)) //; first by apply uM; exists n.
by apply: sup_ub; [exact/has_ubound_sdrop|exists n => /=].
Qed.

Lemma cvg_infs_sup u : has_ubound [set of u] -> has_lbound [set of u] ->
  infs u --> sup [set of infs u].
Proof.
move=> u_ub u_lb; have : sups (- u) --> inf [set of sups (- u)].
  apply: cvg_sups_inf.
  - by move: u_lb => /has_lb_ubN; rewrite image_comp.
  - by move: u_ub => /has_ub_lbN; rewrite image_comp.
rewrite /inf => /(@cvg_comp _ _ _ _ (fun x => - x)).
rewrite supsN /comp /= -[in X in _ -> X --> _](opprK (infs u)); apply.
rewrite image_comp /comp /= -(opprK (sup [set of infs u])).
apply: (@cvgN _ [normedModType R of R^o]).
by rewrite (_ : [set _ | _ in setT] = [set of infs u]) // opprK.
Qed.

Lemma sups_preimage T (D : set T) r (f : (T -> R)^nat) n :
  (forall t, D t -> has_ubound [set of f ^~ t]) ->
  (fun x => sups (f ^~x) n) @^-1` `]r, +oo[%classic `&` D =
  \bigcup_(k in [set k | n <= k]%N) f k @^-1` `]r, +oo[ `&` D.
Proof.
move=> f_ub; rewrite predeqE => t; split.
- have [|/set0P h] := eqVneq (sdrop (f ^~ t) n) set0.
    by rewrite predeqE => /(_ (f n t))[+ _] => /forall2NP/(_ n)/= [].
  rewrite /= preimage_itv in_itv /= andbT => -[] /[swap] Dt.
  move=> /(sup_gt h)[_ [m /= nm <-]] rfmt; split => //; exists m => //.
  by rewrite preimage_itv in_itv /= rfmt.
- move=> [] /[swap] Dt -[k /= nk]; rewrite preimage_itv in_itv /= andbT => rfkt.
  split=> //; rewrite preimage_itv in_itv /= andbT; apply: (lt_le_trans rfkt).
  by apply: sup_ub; [exact/has_ubound_sdrop/f_ub|by exists k].
Qed.

Lemma infs_preimage T (D : set T) r (f : (T -> R)^nat) n :
  (forall t, D t -> has_lbound [set of f ^~ t]) ->
  (fun x => infs (f ^~ x) n) @^-1` `]-oo, r[ `&` D =
  \bigcup_(k in [set k | n <= k]%N) f k @^-1` `]-oo, r[ `&` D.
Proof.
move=> lb_f; rewrite predeqE => t; split.
- have [|/set0P h] := eqVneq (sdrop (f ^~ t) n) set0.
    by rewrite predeqE => /(_ (f n t))[+ _] => /forall2NP/(_ n)/= [].
  rewrite /= preimage_itv in_itv /= => -[] /[swap] Dt.
  by move=>  /(inf_lt h)[_ [m /= nm <-]] fmtr; split => //; exists m.
- move=> -[] /[swap] Dt -[k /= nk]; rewrite preimage_itv in_itv /= => fktr.
  rewrite preimage_itv in_itv /=; split => //; apply: le_lt_trans fktr.
  by apply/inf_lb => //; [exact/has_lbound_sdrop/lb_f|by exists k].
Qed.

Lemma bounded_fun_has_lbound_sups u :
  bounded_fun u -> has_lbound [set of sups u].
Proof.
move=> /[dup] ba /bounded_fun_has_lbound/has_lbound_sdrop h.
have [M hM] := h O; exists M => y [n _ <-].
rewrite (@le_trans _ _ (u n)) //; first by apply hM; exists n.
apply: sup_ub; last by exists n => /=.
by move: ba => /bounded_fun_has_ubound/has_ubound_sdrop; exact.
Qed.

Lemma bounded_fun_has_ubound_infs u :
  bounded_fun u -> has_ubound [set of infs u].
Proof.
move=> /[dup] ba /bounded_fun_has_ubound/has_ubound_sdrop h.
have [M hM] := h O; exists M => y [n _ <-].
rewrite (@le_trans _ _ (u n)) //; last by apply hM; exists n.
apply: inf_lb; last by exists n => /=.
by move: ba => /bounded_fun_has_lbound/has_lbound_sdrop; exact.
Qed.

End sups_infs.

Section lim_sup_lim_inf.
Variable R : realType.
Implicit Types (r : R) (u v : R^o^nat).

Definition lim_sup u := lim (sups u).

Definition lim_inf u := lim (infs u).

Lemma lim_infN u : cvg u -> lim_inf (-%R \o u) = - lim_sup u.
Proof.
move=> cu_; rewrite /lim_inf infsN.
rewrite (@limN _ [normedModType R of R^o] _ _ _ (sups u)) //.
exact: is_cvg_sups.
Qed.

Lemma lim_supE u : bounded_fun u -> lim_sup u = inf [set of sups u].
Proof.
move=> ba; apply/cvg_lim; first exact: Rhausdorff.
by apply/cvg_sups_inf; [exact/bounded_fun_has_ubound|
                        exact/bounded_fun_has_lbound].
Qed.

Lemma lim_infE u : bounded_fun u -> lim_inf u = sup [set of infs u].
Proof.
move=> ba; apply/cvg_lim; first exact: Rhausdorff.
apply/cvg_infs_sup; [exact/bounded_fun_has_ubound|
                     exact/bounded_fun_has_lbound].
Qed.

Lemma lim_inf_le_lim_sup u : cvg u -> lim_inf u <= lim_sup u.
Proof.
move=> cf_; apply: ler_lim; [exact: is_cvg_infs|exact: is_cvg_sups|].
by apply: nearW => n; apply: infs_le_sups.
Qed.

Lemma cvg_lim_inf_sup u l : u --> l -> (lim_inf u = l) * (lim_sup u = l).
Proof.
move=> ul.
have /cvg_seq_bounded [M [Mr Mu]] : cvg u by apply/cvg_ex; eexists; exact: ul.
suff: lim_sup u <= l <= lim_inf u.
  move=> /andP[sul liu].
  have /lim_inf_le_lim_sup iusu : cvg u by apply/cvg_ex; eexists; exact: ul.
  split; first by apply/eqP; rewrite eq_le liu andbT (le_trans iusu).
  by apply/eqP; rewrite eq_le sul /= (le_trans _ iusu).
apply/andP; split.
- apply/ler_addgt0Pr => e e0.
  apply: lim_le; first by apply: is_cvg_sups; apply/cvg_ex; exists l.
  move/cvg_distP : (ul) => /(_ _ e0); rewrite near_map => -[k _ klu].
  near=> n; have kn : (k <= n)%N by near: n; exists k.
  apply: sup_le_ub; first by exists (u n) => /=; exists n => //=.
  move=> _ /= [m nm] <-; apply/ltW/ltr_distl_addr; rewrite distrC.
  by apply: (klu m) => /=; rewrite (leq_trans kn).
- apply/ler_addgt0Pr => e e0; rewrite -ler_subl_addr.
  apply: lim_ge; first by apply: is_cvg_infs; apply/cvg_ex; exists l.
  move/cvg_distP : (ul) => /(_ _ e0); rewrite near_map => -[k _ klu].
  near=> n; have kn: (k <= n)%N by near: n; exists k.
  apply: lb_le_inf; first by exists (u n) => /=; exists n => //=.
  move=> _ /= [m nm] <-; apply/ltW/ltr_distl_subl.
  by apply: (klu m) => /=; rewrite (leq_trans kn).
Grab Existential Variables. all: end_near. Qed.

Lemma cvg_lim_infE u : cvg u -> lim_inf u = lim u.
Proof.
move=> /cvg_ex[l ul]; have [-> _] := cvg_lim_inf_sup ul.
by move/cvg_lim : ul => ->.
Qed.

Lemma cvg_lim_supE u : cvg u -> lim_sup u = lim u.
Proof.
move=> /cvg_ex[l ul]; have [_ ->] := cvg_lim_inf_sup ul.
by move/cvg_lim : ul => ->.
Qed.

Lemma cvg_sups u l : u --> l -> (sups u) --> (l : R^o).
Proof.
move=> ul; have [iul <-] := cvg_lim_inf_sup ul.
have cu : cvg u by apply/cvg_ex; eexists; apply: ul.
have /cvg_ex[l' sul'] := is_cvg_sups cu.
by move/cvg_lim : (sul') ; rewrite /lim_sup => ->//; exact: Rhausdorff.
Qed.

Lemma cvg_infs u l : u --> l -> (infs u) --> (l : R^o).
Proof.
move=> ul; have [<- iul] := cvg_lim_inf_sup ul.
have cu : cvg u by apply/cvg_ex; eexists; apply: ul.
have /cvg_ex[l' sul'] := is_cvg_infs cu.
by move/cvg_lim : (sul') ; rewrite /lim_inf => ->//; exact: Rhausdorff.
Qed.

Lemma le_lim_supD u v :
  bounded_fun u -> bounded_fun v -> lim_sup (u \+ v) <= lim_sup u + lim_sup v.
Proof.
move=> ba bb; have ab k : sups (u \+ v) k <= sups u k + sups v k.
  apply: sup_le_ub; first by exists ((u \+ v) k); exists k => /=.
  by move=> M [n /= kn <-]; apply: ler_add; apply: sup_ub; [
    exact/has_ubound_sdrop/bounded_fun_has_ubound; exact | exists n |
    exact/has_ubound_sdrop/bounded_fun_has_ubound; exact | exists n ].
have cu : cvg (sups u).
  apply: nonincreasing_is_cvg; last exact: bounded_fun_has_lbound_sups.
  exact/nonincreasing_sups/bounded_fun_has_ubound.
have cv : cvg (sups v).
  apply: nonincreasing_is_cvg; last exact: bounded_fun_has_lbound_sups.
  exact/nonincreasing_sups/bounded_fun_has_ubound.
rewrite -(@limD _ [normedModType R of R^o] _ _ _ _ _ cu cv); apply: ler_lim.
- apply: nonincreasing_is_cvg; last first.
    exact/bounded_fun_has_lbound_sups/bounded_funD.
  exact/nonincreasing_sups/bounded_fun_has_ubound/bounded_funD.
- exact: (@is_cvgD _ [normedModType R of R^o] _ _ _ _ _ cu cv).
- exact: nearW.
Qed.

Lemma le_lim_infD u v :
  bounded_fun u -> bounded_fun v -> lim_inf u + lim_inf v <= lim_inf (u \+ v).
Proof.
move=> ba bb; have ab k : infs u k + infs v k <= infs (u \+ v) k.
  apply: lb_le_inf; first by exists ((u \+ v) k); exists k => /=.
  by move=> M [n /= kn <-]; apply: ler_add; apply: inf_lb; [
    exact/has_lbound_sdrop/bounded_fun_has_lbound; exact | exists n |
    exact/has_lbound_sdrop/bounded_fun_has_lbound; exact | exists n ].
have cu : cvg (infs u).
  apply: nondecreasing_is_cvg; last exact: bounded_fun_has_ubound_infs.
  exact/nondecreasing_infs/bounded_fun_has_lbound.
have cv : cvg (infs v).
  apply: nondecreasing_is_cvg; last exact: bounded_fun_has_ubound_infs.
  exact/nondecreasing_infs/bounded_fun_has_lbound.
rewrite -(@limD _ [normedModType R of R^o] _ _ _ _ _ cu cv); apply: ler_lim.
- exact: (@is_cvgD _ [normedModType R of R^o] _ _ _ _ _ cu cv).
- apply: nondecreasing_is_cvg; last first.
    exact/bounded_fun_has_ubound_infs/bounded_funD.
  exact/nondecreasing_infs/bounded_fun_has_lbound/bounded_funD.
- exact: nearW.
Qed.

Lemma lim_supD u v : cvg u -> cvg v -> lim_sup (u \+ v) = lim_sup u + lim_sup v.
Proof.
move=> cu cv; have [ba bb] := (cvg_seq_bounded cu, cvg_seq_bounded cv).
apply/eqP; rewrite eq_le le_lim_supD //=.
have := @le_lim_supD _ _ (bounded_funD ba bb) (bounded_funN bb).
rewrite -ler_subl_addr; apply: le_trans.
rewrite -[_ \+ _]/(u + v - v) addrK -lim_infN; last exact: is_cvgN.
rewrite /comp /=; under eq_fun do rewrite opprK.
by rewrite ler_add// cvg_lim_infE// cvg_lim_supE.
Qed.

Lemma lim_infD u v : cvg u -> cvg v -> lim_inf (u \+ v) = lim_inf u + lim_inf v.
Proof.
move=> cu cv; rewrite (cvg_lim_infE cu) -(cvg_lim_supE cu).
rewrite (cvg_lim_infE cv) -(cvg_lim_supE cv) -lim_supD//.
rewrite cvg_lim_supE; last exact: (@is_cvgD _ _ _ _ _ _ _ cu cv).
by rewrite cvg_lim_infE //; exact: (@is_cvgD _ _ _ _ _ _ _ cu cv).
Qed.

End lim_sup_lim_inf.

Section esups_einfs.
Variable R : realType.
Implicit Types (u : (\bar R)^nat).
Local Open Scope ereal_scope.

Definition esups u := [sequence ereal_sup (sdrop u n)]_n.

Definition einfs u := [sequence ereal_inf (sdrop u n)]_n.

Lemma esupsN u : esups (-%E \o u) = -%E \o einfs u.
Proof.
rewrite funeqE => n; rewrite /esups /= oppeK; congr (ereal_sup _).
by rewrite predeqE => x; split => [[m /= nm <-]|[_ [m /= nm] <-] <-];
  [exists (u m) => //; exists m | exists m].
Qed.

Lemma einfsN u : einfs (-%E \o u) = -%E \o esups u.
Proof.
by rewrite [in RHS](_ : u = -%E \o -%E \o u);
  rewrite ?esupsN funeqE => n /=; rewrite oppeK.
Qed.

Lemma nonincreasing_esups u : nonincreasing_seq (esups u).
Proof.
move=> m n mn; apply: le_ereal_sup => _ /= [k nk <-]; exists k => //=.
by rewrite (leq_trans mn).
Qed.

Lemma nondecreasing_einfs u : nondecreasing_seq (einfs u).
Proof.
move=> m n mn; apply: le_ereal_inf => _ /= [k nk <-]; exists k => //=.
by rewrite (leq_trans mn).
Qed.

Lemma einfs_le_esups u n : einfs u n <= esups u n.
Proof.
rewrite /einfs /=; set A := sdrop _ _; have [a Aa] : A !=set0.
  by exists (u n); rewrite /A /=; exists n => //=.
by rewrite (@le_trans _ _ a) //; [exact/ereal_inf_lb|exact/ereal_sup_ub].
Grab Existential Variables. all: end_near. Qed.

Lemma cvg_esups_inf u : esups u --> ereal_inf [set of esups u].
Proof. by apply: ereal_nonincreasing_cvg => //; exact: nonincreasing_esups. Qed.

Lemma is_cvg_esups u : cvg (esups u).
Proof. by apply/cvg_ex; eexists; exact/cvg_esups_inf. Qed.

Lemma cvg_einfs_sup u : einfs u --> ereal_sup [set of einfs u].
Proof. by apply: ereal_nondecreasing_cvg => //; exact: nondecreasing_einfs. Qed.

Lemma is_cvg_einfs u : cvg (einfs u).
Proof. by apply/cvg_ex; eexists; exact/cvg_einfs_sup. Qed.

Lemma esups_preimage T (a : \bar R) (f : (T -> \bar R)^nat) n :
  (fun x => esups (f^~x) n) @^-1` `]a, +oo[ =
  \bigcup_(k in [set k | n <= k]%N) f k @^-1` `]a, +oo[.
Proof.
rewrite predeqE => t; split => /=.
  rewrite preimage_itv in_itv /= andbT=> /ereal_sup_gt[_ [/= k nk <-]] afnt.
  by exists k => //=; rewrite preimage_itv in_itv /= afnt.
move=> -[k /= nk] /=; rewrite preimage_itv in_itv /= andbT => /lt_le_trans afkt.
by rewrite preimage_itv in_itv andbT/=; apply/afkt/ereal_sup_ub; exists k.
Qed.

Lemma einfs_preimage T (a : \bar R) (f : (T -> \bar R)^nat) n :
  (fun x => einfs (f^~x) n) @^-1` `[a, +oo[%classic =
  \bigcap_(k in [set k | n <= k]%N) f k @^-1` `[a, +oo[%classic.
Proof.
rewrite predeqE => t; split => /= [|h].
  rewrite preimage_itv in_itv andbT /= => h k nk /=.
  by rewrite preimage_itv in_itv/= (le_trans h)//; apply ereal_inf_lb; exists k.
rewrite preimage_itv in_itv /= andbT leNgt; apply/negP.
move=> /ereal_inf_lt[_ /= [k nk <-]]; apply/negP.
by have := h _ nk; rewrite preimage_itv in_itv /= andbT -leNgt.
Qed.

End esups_einfs.

Section elim_sup_inf.
Local Open Scope ereal_scope.
Variable R : realType.
Implicit Types (u v : (\bar R)^nat) (l : \bar R).

Definition elim_sup u := lim (esups u).

Definition elim_inf u := lim (einfs u).

Lemma elim_infN u : elim_inf (-%E \o u) = - elim_sup u.
Proof.
by rewrite /elim_inf einfsN /elim_sup ereal_limN //; exact/is_cvg_esups.
Qed.

Lemma elim_supN u : elim_sup (-%E \o u) = - elim_inf u.
Proof.
apply/eqP; rewrite -eqe_oppLR -elim_infN /=.
by rewrite (_ : _ \o _ = u) // funeqE => n /=; rewrite oppeK.
Qed.

Lemma elim_inf_sup u : elim_inf u <= elim_sup u.
Proof.
apply: lee_lim; [exact/is_cvg_einfs|exact/is_cvg_esups|].
by apply: nearW; exact: einfs_le_esups.
Qed.

Lemma cvg_ninfty_elim_inf_sup u : u --> -oo ->
  (elim_inf u = -oo) * (elim_sup u = -oo).
Proof.
move=> unoo; suff: elim_sup u = -oo.
  move=> {}unoo; split => //; apply/eqP.
  by rewrite -lee_ninfty_eq -unoo elim_inf_sup.
apply/cvg_lim => //=; apply/ereal_cvgPninfty => M M0.
move: unoo => /ereal_cvgPninfty /(_ _ M0)[m _ h].
near=> n; apply ub_ereal_sup => _ [k /= nk] <-.
by apply h => /=; rewrite (leq_trans _ nk) //; near: n; exists m.
Grab Existential Variables. all: end_near. Qed.

Lemma cvg_ninfty_einfs u : u --> -oo -> einfs u --> -oo.
Proof.
move=> /cvg_ninfty_elim_inf_sup[uoo _]; have /cvg_ex[l ul] := @is_cvg_einfs _ u.
by have <- : l = -oo by rewrite -uoo; apply/esym/cvg_lim.
Qed.

Lemma cvg_ninfty_esups u : u --> -oo -> esups u --> -oo.
Proof.
move=> /cvg_ninfty_elim_inf_sup[_ uoo]; have /cvg_ex[l ul] := @is_cvg_esups _ u.
by have <- : l = -oo by rewrite -uoo; apply/esym/cvg_lim.
Qed.

Lemma cvg_pinfty_einfs u : u --> +oo -> einfs u --> +oo.
Proof.
move=> /ereal_cvgN/cvg_ninfty_esups/ereal_cvgN; rewrite esupsN.
apply: cvg_trans; rewrite (_ : _ \o (_ \o _) = einfs u) //.
by rewrite funeqE => n /=; rewrite oppeK.
Qed.

Lemma cvg_pinfty_esups u : u --> +oo -> esups u --> +oo.
Proof.
move=> /ereal_cvgN/cvg_ninfty_einfs/ereal_cvgN; rewrite einfsN.
apply: cvg_trans; rewrite (_ : _ \o (_ \o _) = esups u) //.
by rewrite funeqE => n /=; rewrite oppeK.
Qed.

Lemma cvg_esups u l : u --> l -> esups u --> l.
Proof.
case: l => [l /ereal_cvg_real[u_fin_num] ul| |]; last 2 first.
  - exact: cvg_pinfty_esups.
  - exact: cvg_ninfty_esups.
have [p _ pu] := u_fin_num; apply/cvg_ballP => _/posnumP[e].
have : EFin \o sups (fine \o u) --> l%:E.
  by apply: continuous_cvg => //; apply: cvg_sups.
move=> /cvg_ballP /(_ e%:num (posnum_gt0 _))[q _ qsupsu].
rewrite near_simpl; near=> n.
have -> : esups u n = (EFin \o sups (fine \o u)) n.
  rewrite /= -ereal_sup_EFin; last 2 first.
    - apply/has_ubound_sdrop/bounded_fun_has_ubound.
      apply/(@cvg_seq_bounded _ [normedModType R of R^o])/cvg_ex.
      by eexists; exact ul.
    - by eexists; rewrite /sdrop /=; exists n; [|reflexivity].
  congr (ereal_sup _).
  rewrite predeqE => y; split=> [[m /= nm <-{y}]|[r [m /= nm <-{r} <-{y}]]].
    have /pu : (p <= m)%N by rewrite (leq_trans _ nm) //; near: n; exists p.
    by move=> /fineK umE; eexists; [exists m|exact/umE].
  have /pu : (p <= m)%N by rewrite (leq_trans _ nm) //; near: n; exists p.
  by move=> /fineK umE; exists m => //; exact/umE.
by apply: qsupsu => /=; near: n; exists q.
Grab Existential Variables. all: end_near. Qed.

Lemma cvg_einfs u l : u --> l -> einfs u --> l.
Proof.
move=> /ereal_cvgN/cvg_esups/ereal_cvgN; rewrite oppeK esupsN.
by rewrite (_ : _ \o (_ \o _) = einfs u) // funeqE => n /=; rewrite oppeK.
Qed.

Lemma cvg_elim_inf_sup u l : u --> l -> (elim_inf u = l) * (elim_sup u = l).
Proof.
by move=> ul; split; apply/cvg_lim => //; [apply/cvg_einfs|apply/cvg_esups].
Qed.

Lemma is_cvg_elim_infE u : cvg u -> elim_inf u = lim u.
Proof.
move=> /cvg_ex[l ul]; have [-> _] := cvg_elim_inf_sup ul.
by move/cvg_lim : ul => ->.
Qed.

Lemma is_cvg_elim_supE u : cvg u -> elim_sup u = lim u.
Proof.
move=> /cvg_ex[l ul]; have [_ ->] := cvg_elim_inf_sup ul.
by move/cvg_lim : ul => ->.
Qed.

End elim_sup_inf.

(* TODO: PR the properties of measurable functions to measure.v *)
Section measurable_fun.
Implicit Types T : measurableType.

Lemma measurable_fun_comp T1 T2 T3 (f : T2 -> T3) E (g : T1 -> T2) :
  measurable_fun setT f -> measurable_fun E g -> measurable_fun E (f \o g).
Proof.
move=> mf mg /= A mA; rewrite comp_preimage; apply/mg.
by rewrite -[X in measurable X]setIT; apply/mf.
Qed.

Lemma measurable_funU T1 T2 (D E : set T1) (f : T1 -> T2) :
  measurable D -> measurable E ->
  measurable_fun (D `|` E) f <-> measurable_fun D f /\ measurable_fun E f.
Proof.
move=> mD mE; split=> [mDEf|[mDf mEf] A mA]; last first.
  by rewrite setIUr; apply: measurableU; [exact: mDf|exact: mEf].
split => A mA.
- have /(measurableI D) := mDEf A mA=> /(_ mD).
  by rewrite setICA setUC setKU.
- have /(measurableI E) := mDEf A mA => /(_ mE).
  by rewrite setICA setKU.
Qed.

Lemma measurable_funS T1 T2 (E D : set T1) (f : T1 -> T2) :
     measurable E -> measurable D -> D `<=` E -> measurable_fun E f ->
  measurable_fun D f.
Proof.
move=> mE mD DE mf; have mC : measurable (E `\` D) by exact: measurableD.
have := measurable_funU f mD mC; suff -> : (D `|` (E `\` D)) = E by move=> [[]].
apply/seteqP; split=> x /= => [ [/DE|[]]//|].
by have [] := pselect (D x); [left|right].
Qed.

Lemma measurable_fun_cst (T1 T2 : measurableType) (D : set T1) (r : T2) :
  measurable D -> measurable_fun D (cst r : T1 -> T2).
Proof.
move=> mD A mA; have [rA|rA] := boolP (r \in A).
- rewrite [X in measurable X](_ : _ = D) // predeqE => t; split=> [[]//|Dt].
  by split => //; rewrite inE in rA.
- rewrite [X in measurable X](_ : _ = set0)// predeqE.
  by move=> t; split=> // -[]; rewrite notin_set in rA.
Qed.

Lemma measurable_fun_id (T : measurableType) (D : set T) : measurable D ->
  measurable_fun D id.
Proof. by move=> mD A mA; apply: measurableI. Qed.

End measurable_fun.

Section standard_measurable_fun.

Lemma measurable_fun_normr (R : realType) (D : set R) :
  measurable D -> measurable_fun D (@normr _ R).
Proof.
move=> mD; apply: (measurability mD (RGenOInfty.measurableE R)) => //.
move=> /= _ [_ [x ->] <-]; apply: measurableI => //.
have [x0|x0] := leP 0 x.
  rewrite [X in measurable X](_ : _ = `]-oo, (- x)[ `|` `]x, +oo[)%classic.
    by apply: measurableU; exact/measurable_itv.
  rewrite predeqE => r; split => [|[|]]; rewrite preimage_itv in_itv andbT/=.
  - have [r0|r0] := leP 0 r; [rewrite ger0_norm|rewrite ltr0_norm] => // xr;
      rewrite 2!in_itv/=.
    + by right; rewrite xr.
    + by left; rewrite ltr_oppr.
  - move=> rx /=.
    by rewrite ler0_norm 1?ltr_oppr// (le_trans (ltW rx))// ler_oppl oppr0.
  - by rewrite in_itv /= andbT => xr; rewrite (lt_le_trans _ (ler_norm _)).
rewrite [X in measurable X](_ : _ = setT)// predeqE => r.
by split => // _; rewrite preimage_itv in_itv /= andbT (lt_le_trans x0).
Qed.

End standard_measurable_fun.

Section measurable_fun_realType.
Variables (T : measurableType) (R : realType).
Implicit Types (D : set T) (f g : T -> R).

Lemma measurable_funD D f g : measurable D ->
  measurable_fun D f -> measurable_fun D g -> measurable_fun D (f \+ g).
Proof.
move=> mD mf mg; apply: (measurability mD (RGenOInfty.measurableE R)) => //.
move=> /= _ [_ [a ->] <-]; rewrite preimage_itv_o_infty.
rewrite [X in measurable X](_ : _ = \bigcup_(r : rat)
  (([set x | ratr r < f x] `&` D) `&` ([set x | a - ratr r < g x] `&` D))).
  apply: measurable_bigcup_rat => q; apply: measurableI.
  - by rewrite -preimage_itv_o_infty; exact/mf/measurable_itv.
  - by rewrite -preimage_itv_o_infty; exact/mg/measurable_itv.
rewrite predeqE => x; split => [|[r _] []/= [rfx Dx]] /= [].
  rewrite -ltr_subl_addr => /rat_in_itvoo[r]; rewrite inE /= => /itvP h Dx.
  exists r => //; rewrite setIACA setIid; split => //; split => /=.
    by rewrite h.
  by rewrite ltr_subl_addr addrC -ltr_subl_addr h.
by rewrite ltr_subl_addr=> afg; rewrite (lt_le_trans afg)// addrC ler_add2r ltW.
Qed.

Lemma measurable_fun_sqr D f : measurable D ->
  measurable_fun D f -> measurable_fun D (fun x => f x ^+ 2).
Proof.
move=> mD mf /= A mA.
apply: (measurability _ (RGenOInfty.measurableE R)) => //= _ [_ [a ->] <-].
have [a0|a0] := leP 0 a; last first.
  rewrite (_ : _ `&` _ = D) // predeqE => x; split => [[]//|Dx]; split => //.
  by rewrite preimage_itv in_itv /= andbT (lt_le_trans a0)// sqr_ge0.
rewrite (_ : _ `&` D = (f @^-1` `]Num.sqrt a, +oo[ `&` D) `|`
                       (f @^-1` `]-oo, -Num.sqrt a[ `&` D) ).
  by apply: measurableU; exact/mf/measurable_itv.
rewrite predeqE => t; split=> [[]|].
  rewrite preimage_itv in_itv /= andbT => aft2 Dt.
  have := le_lt_trans a0 aft2.
  rewrite exprn_even_gt0 //= neq_lt => /orP[|] ft0.
    move: aft2; rewrite -ltr_sqrt; last first.
      by rewrite exprn_even_gt0//= lt_eqF.
    by rewrite sqrtr_sqr ltr0_norm// ltr_oppr; tauto.
  move: aft2; rewrite -ltr_sqrt; last first.
    by rewrite exprn_even_gt0//= gt_eqF.
  by rewrite sqrtr_sqr gtr0_norm// !preimage_itv !in_itv/= andbT; tauto.
move=> [] /=; rewrite !preimage_itv !in_itv /= ?andbT => -[fta Dt]; split => //.
  rewrite -ltr_sqrt; last first.
    by rewrite exprn_even_gt0//= gt_eqF// (le_lt_trans _ fta)// sqrtr_ge0.
  by rewrite sqrtr_sqr gtr0_norm// (le_lt_trans _ fta)// sqrtr_ge0.
rewrite -ltr_sqrt; last first.
  rewrite exprn_even_gt0//= lt_eqF// (lt_le_trans fta)// -ler_oppl oppr0.
  by rewrite sqrtr_ge0.
rewrite sqrtr_sqr ltr0_norm// 1?ltr_oppr//.
by rewrite (lt_le_trans fta)// -ler_oppl oppr0 sqrtr_ge0.
Qed.

Lemma measurable_funrM D f (k : R) : measurable D -> measurable_fun D f ->
  measurable_fun D (fun x => k * f x).
Proof.
move=> mD; have [-> _|] := eqVneq k 0.
  rewrite (_ : (fun _ => _) = cst 0); first exact: measurable_fun_cst.
  by rewrite funeqE// => t; rewrite mul0r.
rewrite neq_lt => /orP[k0|k0] mf;
  apply: (measurability _ (RGenOInfty.measurableE R)) => //= A [B [a ->] <-].
- rewrite preimage_itv_o_infty [X in measurable X](_ : _ =
      f @^-1` `]-oo, a / k[ `&` D); last first.
    rewrite predeqE => t; split => [[/= akft Dtr]|[]].
      by rewrite preimage_itv in_itv/= ltr_ndivl_mulr// mulrC.
    by rewrite preimage_itv in_itv /= => ftak Dt; rewrite mulrC -ltr_ndivl_mulr.
  by apply: mf; rewrite -(set_itv_infty_o (a / k)); exact/measurable_itv.
- rewrite preimage_itv_o_infty [X in measurable X](_ : _ =
      f @^-1` `]a / k, +oo[ `&` D); first exact/mf/measurable_itv.
  rewrite predeqE => t; split => [[/= akft Dt]|[]].
    by rewrite preimage_itv in_itv/= andbT ltr_pdivr_mulr// mulrC.
  by rewrite preimage_itv in_itv/= andbT=> akft; rewrite mulrC -ltr_pdivr_mulr.
Qed.

Lemma measurable_funN D f : measurable D -> measurable_fun D f ->
  measurable_fun D (-%R \o f).
Proof.
move=> mD mf; rewrite (_ : _ \o _ = (fun x => - 1 * f x)).
  exact: measurable_funrM.
by under eq_fun do rewrite mulN1r.
Qed.

Lemma measurable_funB D f g : measurable D -> measurable_fun D f ->
  measurable_fun D g -> measurable_fun D (f \- g).
Proof.
by move=> ? ? ?; apply: measurable_funD => //; exact: measurable_funN.
Qed.

Lemma measurable_funM D f g : measurable D ->
  measurable_fun D f -> measurable_fun D g ->
  measurable_fun D (fun x => f x * g x).
Proof.
move=> mD mf mg.
rewrite (_ : (fun _ => _) = (fun x => 2%:R^-1 * (f x + g x) ^+ 2)
  \- (fun x => 2%:R^-1 * (f x ^+ 2)) \- (fun x => 2%:R^-1 * ( g x ^+ 2))).
  apply: measurable_funB => //; last first.
    by apply: measurable_funrM => //; exact: measurable_fun_sqr.
  apply: measurable_funB => //; last first.
    by apply: measurable_funrM => //; exact: measurable_fun_sqr.
  apply: measurable_funrM => //.
  by apply: measurable_fun_sqr => //; exact: measurable_funD.
rewrite funeqE => x /=; rewrite -2!mulrBr sqrrD (addrC (f x ^+ 2)) -addrA.
rewrite -(addrA (f x * g x *+ 2)) -opprB opprK (addrC (g x ^+ 2)) addrK.
by rewrite -(mulr_natr (f x * g x)) -(mulrC 2) mulrA mulVr ?mul1r// unitfE.
Qed.

Lemma measurable_fun_sup D (h : (T -> R)^nat) n :
  (forall t, D t -> has_ubound [set of h^~t]) ->
  measurable D -> (forall m, measurable_fun D (h m)) ->
  measurable_fun D (fun x => sup (sdrop (h^~x) n)).
Proof.
move=> f_ub mD mf; apply: (measurability mD (RGenOInfty.measurableE R)) => //.
move=> _ [_ [x ->] <-]; rewrite sups_preimage // setI_bigcupl.
by apply: bigcup_measurable => k /= nk; exact/mf/measurable_itv.
Qed.

Lemma measurable_fun_inf D (h : (T -> R)^nat) n :
  (forall t, D t -> has_lbound [set of h ^~ t]) ->
  measurable D -> (forall n, measurable_fun D (h n)) ->
  measurable_fun D (fun x => inf (sdrop (h ^~ x) n)).
Proof.
move=> lb_f mD mf; apply: (measurability mD (RGenInftyO.measurableE R)) =>//.
move=> _ [_ [x ->] <-]; rewrite infs_preimage // setI_bigcupl.
by apply: bigcup_measurable => k /= nk; exact/mf/measurable_itv.
Qed.

Lemma eq_measurable_fun D (f g : T -> R) :
  {in D, f =1 g} -> measurable_fun D f -> measurable_fun D g.
Proof.
move=> Dfg Df A mA; rewrite (_ : _ `&` D = f @^-1` A `&` D); first exact: Df.
apply/seteqP; rewrite /preimage; split => [x /= [Agx Dx]|x /= [Afx Dx]].
  by split=> //; rewrite Dfg// inE.
by split=> //; rewrite -Dfg// inE.
Qed.

Lemma measurable_fun_lim_sup D (h : (T -> R)^nat) :
  (forall t, D t -> has_ubound [set of h^~t]) ->
  (forall t, D t -> has_lbound [set of h^~t]) ->
  measurable D -> (forall n, measurable_fun D (h n)) ->
  measurable_fun D (fun x => lim_sup (h ^~ x)).
Proof.
move=> f_ub f_lb mD mf.
have : {in D, (fun x => inf [set sups (h ^~ x) n | n in [set n | 0 <= n]%N])
              =1 (fun x => lim_sup (h^~ x))}.
  move=> t; rewrite inE => Dt; apply/esym/cvg_lim; first exact: Rhausdorff.
  rewrite [X in _ --> X](_ : _ = inf [set of sups (h^~t)]).
    by apply: cvg_sups_inf; [exact: f_ub|exact: f_lb].
  by congr (inf [set _ | _ in _]); rewrite predeqE.
move/eq_measurable_fun; apply; apply: measurable_fun_inf => //.
  move=> t Dt; have [M hM] := f_lb _ Dt; exists M => _ [m /= nm <-].
  rewrite (@le_trans _ _ (h m t)) //; first by apply hM => /=; exists m.
  by apply: sup_ub; [exact/has_ubound_sdrop/f_ub|exists m => /=].
by move=> k; exact: measurable_fun_sup.
Qed.

Lemma measurable_fun_cvg D (h : (T -> R)^nat) f : measurable D ->
  (forall m, measurable_fun D (h m)) -> (forall x, D x -> h ^~ x --> f x) ->
  measurable_fun D f.
Proof.
move=> mD mf_ f_f; have fE x : D x -> f x = lim_sup (h ^~ x).
  move=> Dx; have /cvg_lim  <-// := (@cvg_sups _ (h ^~ x) (f x) (f_f _ Dx)).
  exact: Rhausdorff.
apply: (@eq_measurable_fun D (fun x => lim_sup (h ^~ x))).
  by move=> x; rewrite inE => Dx; rewrite -fE.
apply: (@measurable_fun_lim_sup _ h) => // t Dt.
- apply/bounded_fun_has_ubound/(@cvg_seq_bounded _ [normedModType R of R^o]).
  by apply/cvg_ex; eexists; exact: f_f.
- apply/bounded_fun_has_lbound/(@cvg_seq_bounded _ [normedModType R of R^o]).
  by apply/cvg_ex; eexists; exact: f_f.
Qed.

End measurable_fun_realType.

Section standard_emeasurable_fun.
Variable R : realType.

Lemma measurable_fun_EFin (D : set R) : measurable D -> measurable_fun D EFin.
Proof.
move=> mD; apply: (measurability mD (ErealGenOInfty.measurableE R)) => //.
move=> /= _ [_ [x ->]] <-; move: x => [x| |]; apply: measurableI => //.
- by rewrite preimage_itv_o_infty EFin_itv; exact: measurable_itv.
- by rewrite [X in measurable X](_ : _ = set0)// predeqE.
- by rewrite preimage_EFin_setT.
Qed.

Lemma measurable_fun_abse (D : set (\bar R)) :
  measurable D -> measurable_fun D abse.
Proof.
move=> mD; apply: (measurability mD (ErealGenOInfty.measurableE R)).
move=> /= _ [_ [x ->] <-]; move: x => [x| |].
- rewrite [X in _ @^-1` X](punct_eitv_bnd_pinfty _ x) preimage_setU setIUl.
  apply: measurableU; last first.
    rewrite preimage_abse_pinfty.
    by apply: measurableI => //; apply: measurableU; exact: emeasurable_set1.
  apply: measurableI => //; exists (normr @^-1` `]x, +oo[%classic).
    rewrite -[X in measurable X]setIT.
    by apply: measurable_fun_normr => //; exact: measurable_itv.
  exists set0; first by constructor.
  rewrite setU0 predeqE => -[y| |]; split => /= => -[r];
    rewrite ?preimage_itv /= ?in_itv /= ?andbT => xr//.
    + by move=> [ry]; exists `|y| => //=; rewrite in_itv/= andbT -ry.
    + by move=> [ry]; exists y => //=; rewrite preimage_itv in_itv/= andbT -ry.
- by apply: measurableI => //; rewrite itv_opinfty_pinfty preimage_set0.
- apply: measurableI => //; rewrite itv_oninfty_pinfty -preimage_setC.
  by apply: measurableC; rewrite preimage_abse_ninfty.
Qed.

Lemma emeasurable_fun_minus (D : set (\bar R)) : measurable D ->
  measurable_fun D (-%E : \bar R -> \bar R).
Proof.
move=> mD; apply: (measurability mD (ErealGenCInfty.measurableE R)).
move=> _ [_ [x ->] <-]; rewrite (_ : _ @^-1` _ = `]-oo, (- x)%E]%classic).
  by apply: measurableI => //; exact: emeasurable_itv_ninfty_bnd.
by rewrite predeqE => y; rewrite !preimage_itv !in_itv/= andbT in_itv lee_oppr.
Qed.

End standard_emeasurable_fun.

(* NB: real-valued function *)
Lemma EFin_measurable_fun (T : measurableType) (R : realType) (D : set T)
    (g : T -> R) :
  measurable_fun D (EFin \o g) <-> measurable_fun D g.
Proof.
split=> [mf A mA|]; last first.
  by move=> mg; apply: measurable_fun_comp => //; exact: measurable_fun_EFin.
rewrite [X in measurable X](_ : _ = (EFin \o g) @^-1` (EFin @` A) `&` D).
  by apply: mf; exists A => //; exists set0; [constructor|rewrite setU0].
congr (_ `&` _);rewrite eqEsubset; split=> [|? []/= _ /[swap] -[->//]].
by move=> ? ?; exact: preimage_image.
Qed.

Section emeasurable_fun.
Variables (T : measurableType) (R : realType).
Implicit Types (D : set T).

Lemma emeasurable_fun_ext D (f g : T -> \bar R) :
  measurable D -> {in D, f =1 g} ->
  measurable_fun D f -> measurable_fun D g.
Proof.
move=> mD fg mf A mA.
rewrite [X in measurable X](_ : _ = f @^-1` A `&` D); first exact: mf.
(* NB: lemma? *)
rewrite predeqE /preimage /= => x; split => [[Agx Dx]|[Afx Dx]].
  by split => //; rewrite fg// inE.
by split => //; rewrite -fg// inE.
Qed.

Lemma measurable_fun_ereal_inf D (f : (T -> \bar R)^nat) :
  measurable D -> (forall n, measurable_fun D (f n)) ->
  forall n, measurable_fun D (fun x => ereal_inf (sdrop (f ^~ x) n)).
Proof.
move=> mD mf n.
apply: (measurability mD (ErealGenCInfty.measurableE R)) => //.
move=> _ [_ [x ->] <-]; rewrite einfs_preimage -bigcapIl; last by exists n => /=.
by apply: bigcap_measurable => ? ?; exact/mf/emeasurable_itv_bnd_pinfty.
Qed.

Lemma measurable_fun_ereal_sup D (f : (T -> \bar R)^nat) :
  measurable D -> (forall n, measurable_fun D (f n)) ->
  forall n, measurable_fun D (fun x => ereal_sup (sdrop (f ^~ x) n)).
Proof.
move=> mD mf n; apply: (measurability _ (ErealGenOInfty.measurableE R)) => //.
move=> _ [_ [x ->] <-];rewrite esups_preimage setI_bigcupl.
by apply: bigcup_measurable => ? ?; exact/mf/emeasurable_itv_bnd_pinfty.
Qed.

Lemma emeasurable_fun_max D (f g : T -> \bar R) :
  measurable D -> measurable_fun D f -> measurable_fun D g ->
  measurable_fun D (fun x => maxe (f x) (g x)).
Proof.
move=> mD mf mg; apply: (measurability mD (ErealGenCInfty.measurableE R)) => //.
move=> _ [_ [x ->] <-]; rewrite [X in measurable X](_ : _ =
    (f @^-1` `[x, +oo[ `&` D) `|` (g @^-1` `[x, +oo[ `&` D)); last first.
  rewrite predeqE => t /=; split.
    by rewrite !preimage_itv /= !in_itv /= !andbT le_maxr => -[+ Dx] => /orP[|];
      tauto.
  by move=> [|]; rewrite !preimage_itv /= !in_itv/= !andbT le_maxr;
    move=> [+ Dx] => ->//; rewrite orbT.
by apply: measurableU; [exact/mf/emeasurable_itv_bnd_pinfty|
                        exact/mg/emeasurable_itv_bnd_pinfty].
Qed.

Lemma emeasurable_fun_min D (f g : T -> \bar R) :
  measurable D -> measurable_fun D f -> measurable_fun D g ->
  measurable_fun D (fun x => mine (f x) (g x)).
Proof.
move=> mD mf mg; apply: (measurability mD (ErealGenCInfty.measurableE R)) => //.
move=> _ [_ [x ->] <-]; rewrite [X in measurable X](_ : _ =
    (f @^-1` `[x, +oo[ `&` D) `&` (g @^-1` `[x, +oo[ `&` D)); last first.
  rewrite predeqE => t /=; split.
    rewrite !preimage_itv !in_itv /= !andbT le_minr => -[/andP[xft xgt] Dt].
    tauto.
  move=> []; rewrite !preimage_itv !in_itv/= !andbT le_minr=> -[xft Dt [xgt _]].
  by split => //; rewrite xft xgt.
by apply: measurableI; [exact/mf/emeasurable_itv_bnd_pinfty|
                        exact/mg/emeasurable_itv_bnd_pinfty].
Qed.

Lemma measurable_fun_elim_sup D (f : (T -> \bar R)^nat) :
  measurable D -> (forall n, measurable_fun D (f n)) ->
  measurable_fun D (fun x => elim_sup (f ^~ x)).
Proof.
move=> mD mf; rewrite (_ :  (fun _ => _) =
    (fun x => ereal_inf [set esups (f^~ x) n | n in [set n | n >= 0]%N])).
  by apply: measurable_fun_ereal_inf => // k; exact: measurable_fun_ereal_sup.
rewrite funeqE => t; apply/cvg_lim => //.
rewrite [X in _ --> X](_ : _ = ereal_inf [set of esups (f^~t)]).
  exact: cvg_esups_inf.
by congr (ereal_inf [set _ | _ in _]); rewrite predeqE.
Qed.

Lemma emeasurable_fun_cvg D (f_ : (T -> \bar R)^nat) (f : T -> \bar R) :
  measurable D -> (forall m, measurable_fun D (f_ m)) ->
  (forall x, D x -> f_ ^~ x --> f x) ->
  measurable_fun D f.
Proof.
move=> mD mf_ f_f; have fE x : D x -> f x = elim_sup (f_^~ x).
  by move=> Dx; have /cvg_lim  <-// := (@cvg_esups _ (f_^~x) (f x) (f_f x Dx)).
apply: (@emeasurable_fun_ext _ (fun x => elim_sup (f_ ^~ x))) => //.
  by move=> x; rewrite inE => Dx; rewrite fE.
exact: measurable_fun_elim_sup.
Qed.

End emeasurable_fun.

Definition preimage_classes (T1 T2 : measurableType) (T : Type)
    (f1 : T -> T1) (f2 : T -> T2)  :=
  s<< preimage_class setT f1 measurable `|`
      preimage_class setT f2 measurable >>.

Section product_lemma.
Variables (T1 T2 : measurableType) (T : Type) (f1 : T -> T1) (f2 : T -> T2).
Variables (T3 : Type) (g : T3 -> T).

Lemma preimage_classes_comp : preimage_classes (f1 \o g) (f2 \o g) =
                              preimage_class setT g (preimage_classes f1 f2).
Proof.
rewrite {1}/preimage_classes -transfer; congr (s<< _ >>).
rewrite predeqE => C; split.
- move=> [[A mA <-{C}]|[A mA <-{C}]].
  + by exists (f1 @^-1` A) => //; left; exists A => //; rewrite setIT.
  + by exists (f2 @^-1` A) => //; right; exists A => //; rewrite setIT.
- move=> [A [[B mB <-{A} <-{C}]|[B mB <-{A} <-{C}]]].
  + by left; rewrite !setIT; exists B => //; rewrite setIT.
  + by right; rewrite !setIT; exists B => //; rewrite setIT.
Qed.

End product_lemma.

Definition prod_measurable (T1 T2 : measurableType) := (T1 * T2)%type.

Section product_salgebra_instance.
Variables (T1 T2 : measurableType).
Let f1 := @fst T1 T2.
Let f2 := @snd T1 T2.

Lemma prod_salgebra_set0 : preimage_classes f1 f2 (set0 : set (T1 * T2)).
Proof. exact: g_salgebra_set0. Qed.

Lemma prod_salgebra_setC A : preimage_classes f1 f2 A ->
  preimage_classes f1 f2 (~` A).
Proof. exact: g_salgebra_on_setC_setT. Qed.

Lemma prod_salgebra_bigcup (F : _^nat) : (forall i, preimage_classes f1 f2 (F i)) ->
  preimage_classes f1 f2 (\bigcup_i (F i)).
Proof. exact: g_salgebra_bigcup. Qed.

HB.instance Definition prod_salgebra_mixin :=
  @isMeasurable.Build (T1 * T2)%type (preimage_classes f1 f2)
    (prod_salgebra_set0) (prod_salgebra_setC) (prod_salgebra_bigcup).

Definition prod_measurableType := [the measurableType of prod_measurable T1 T2].

End product_salgebra_instance.

Lemma measurableM (T1 T2 : measurableType) (A : set T1) (B : set T2) :
  measurable A -> measurable B -> measurable (A `*` B).
Proof.
move=> mA mB.
have -> : A `*` B = (A `*` setT) `&` (setT `*` B) :> set (T1 * T2).
  by rewrite -{1}(setIT A) -{1}(setTI B) setMI.
rewrite setMT setTM; apply: measurableI.
- by apply: g_salgebra_self; left; exists A => //; rewrite setIT.
- by apply: g_salgebra_self; right; exists B => //; rewrite setIT.
Qed.

Section product_salgebra_measurableType.
Variables (T1 T2 : measurableType).
Let M1 := @measurable T1.
Let M2 := @measurable T2.
Let M1xM2 := [set A `*` B | A in M1 & B in M2].

Lemma measurable_prod_measurableType :
  @measurable (prod_measurableType T1 T2) = s<< M1xM2 >>.
Proof.
rewrite eqEsubset; split.
  apply: g_salgebra_smallest; last apply: are_measurable_sets_g_salgebra.
  rewrite subUset; split.
  - have /subset_trans : preimage_class setT fst M1 `<=` M1xM2.
      by move=> _ [X MX <-]; exists X=> //; exists setT; rewrite /M2 //.
    by apply; exact: g_salgebra_self.
  - have /subset_trans : preimage_class setT snd M2 `<=` M1xM2.
      move=> _ [Y MY <-]; exists setT; rewrite /M1 //.
      by exists Y => //; rewrite predeqE // => -[x y]; split => [|] [].
    by apply; exact: g_salgebra_self.
apply: g_salgebra_smallest; last exact: are_measurable_sets_g_salgebra.
by move=> _ [A MA] [B MB] <-; apply: measurableM => //; exact: g_salgebra_self.
Qed.

End product_salgebra_measurableType.

Section product_salgebra_g_measurableTypeR.
Variables (T1 : measurableType) (T2 : Type) (C2 : set (set T2)).
Hypothesis (setTC2 : setT `<=` C2).

(* NB: useful? *)
Lemma measurable_prod_g_measurableTypeR :
  @measurable (prod_measurableType T1 (g_measurableType C2))
  = s<< [set A `*` B | A in measurable & B in C2] >>.
Proof.
rewrite measurable_prod_measurableType //; congr (s<< _ >>).
rewrite predeqE => X; split=> [[A mA] [B mB] <-{X}|[A C1A] [B C2B] <-{X}].
  by exists A => //; exists B => //; exact: setTC2.
by exists A => //; exists B => //; exact: g_salgebra_self.
Qed.

End product_salgebra_g_measurableTypeR.

Section product_salgebra_g_measurableType.
Variables (T1 T2 : Type) (C1 : set (set T1)) (C2 : set (set T2)).
Hypotheses (setTC1 : setT `<=` C1) (setTC2 : setT `<=` C2).

Lemma measurable_prod_g_measurableType :
  @measurable (prod_measurableType (g_measurableType C1) (g_measurableType C2))
  = s<< [set A `*` B | A in C1 & B in C2] >>.
Proof.
rewrite measurable_prod_measurableType //; congr (s<< _ >>).
rewrite predeqE => X; split=> [[A mA] [B mB] <-{X}|[A C1A] [B C2B] <-{X}].
  by exists A; [exact: setTC1|exists B => //; exact: setTC2].
by exists A; [exact: g_salgebra_self|exists B => //; exact: g_salgebra_self].
Qed.

End product_salgebra_g_measurableType.

Section prod_measurable_fun.
Variables (T T1 T2 : measurableType) (f : T -> prod_measurableType T1 T2).

Lemma prod_measurable_funP : measurable_fun setT f <->
  measurable_fun setT (fst \o f) /\ measurable_fun setT (snd \o f).
Proof.
apply: (@iff_trans _ (preimage_classes (fst \o f) (snd \o f) `<=` measurable)).
- rewrite preimage_classes_comp; split=> [mf A [C HC <-]|f12]; first exact: mf.
  by move=> A mA; apply: f12; exists A.
- split => [h|[mf1 mf2]].
    by split => A mA; apply/h/g_salgebra_self; [left; exists A|right; exists A].
  apply: g_salgebra_smallest; last exact: are_measurable_sets_measurable.
  by apply: subsetU => [|] A [C mC <-]; [exact: mf1|exact: mf2].
Qed.

End prod_measurable_fun.

Section partial_measurable_fun.
Variables (T T1 T2 : measurableType) (f : prod_measurableType T1 T2 -> T).

Lemma measurable_fun_prod1 x :
  measurable_fun setT f -> measurable_fun setT (fun y => f (x, y)).
Proof.
move=> mf; pose pairx := fun y : T2 => (x, y).
have m1pairx : measurable_fun setT (fst \o pairx) by exact/measurable_fun_cst.
have m2pairx : measurable_fun setT (snd \o pairx) by exact/measurable_fun_id.
have : measurable_fun setT pairx by exact/(proj2 (prod_measurable_funP _)).
exact: measurable_fun_comp.
Qed.

Lemma measurable_fun_prod2 y :
  measurable_fun setT f -> measurable_fun setT (fun x => f (x, y)).
Proof.
move=> mf; pose pairy := fun x : T1 => (x, y).
have m1pairy : measurable_fun setT (fst \o pairy) by exact/measurable_fun_id.
have m2pairy : measurable_fun setT (snd \o pairy) by exact/measurable_fun_cst.
have : measurable_fun setT pairy by exact/(proj2 (prod_measurable_funP _)).
exact: measurable_fun_comp.
Qed.

End partial_measurable_fun.
