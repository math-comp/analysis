(* mathcomp analysis (c) 2022 Inria and AIST. License: CeCILL-C.              *)
From mathcomp Require Import all_ssreflect.
From mathcomp Require Import ssralg poly ssrnum ssrint interval finmap.
From mathcomp Require Import mathcomp_extra boolp classical_sets functions.
From mathcomp Require Import cardinality fsbigop.
Require Reals Interval.Tactic.
From mathcomp Require Import (canonicals) Rstruct Rstruct_topology.
From HB Require Import structures.
From mathcomp Require Import exp numfun lebesgue_measure lebesgue_integral.
From mathcomp Require Import reals ereal interval_inference topology normedtype.
From mathcomp Require Import sequences realfun convex real_interval.
From mathcomp Require Import derive esum measure exp numfun lebesgue_measure.
From mathcomp Require Import lebesgue_integral kernel probability.
From mathcomp Require Import hoelder independence.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

(**md**************************************************************************)
(* # A Sampling Theorem                                                       *)
(*                                                                            *)
(* This file contains a formalization of a sampling theorem. The proof is     *)
(* decompose in two sections: sampling_theorem_part1 and                      *)
(* sampling_theorem_part2.                                                    *)
(*                                                                            *)
(* References:                                                                *)
(* - Samir Rajani. Applications of Chernoff bounds, 2019                      *)
(*   http://math.uchicago.edu/~may/REU2019/REUPapers/Rajani.pdf               *)
(* - Michael Mitzenmacher and Eli Upfal. Probability and Computingâ€”Randomized *)
(*   Algorithms and Probabilistic Analysis. Cambridge University Press, 2005  *)
(*                                                                            *)
(*  g_sigma_preimage n (f : 'I_n -> aT -> rT) == the sigma-algebra over aT    *)
(*               generated by the projections f                               *)
(*               n.-tuple T is equipped with a measurableType using           *)
(*               g_sigma_preimage and the tnth projections                    *)
(*       Tnth == TODO                                                         *)
(*   pro1 P Q == the probability measure P \x Q                               *)
(*               P and Q are probability measures.                            *)
(*   pro2 P Q == the probability measure P \x^ Q                              *)
(*               P and Q are probability measures.                            *)
(*     \X_n P == the product probability measure P \x P \x ... \x P           *)
(******************************************************************************)

Import Order.TTheory GRing.Theory Num.Def Num.Theory.
Import numFieldTopology.Exports numFieldNormedType.Exports.
Import hoelder ess_sup_inf.

Local Open Scope classical_set_scope.
Local Open Scope ring_scope.

Lemma memB_itv (R : numDomainType) (b0 b1 : bool) (x y z : R) :
  (y - z \in Interval (BSide b0 x) (BSide b1 y)) =
  (x + z \in Interval (BSide (~~ b1) x) (BSide (~~ b0) y)).
Proof.
rewrite !in_itv /= /Order.lteif !if_neg.
by rewrite gerBl gtrBl lerDl ltrDl lerBrDr ltrBrDr andbC.
Qed.

(* generalizes mem_1B_itvcc *)
Lemma memB_itv0 (R : numDomainType) (b0 b1 : bool) (x y : R) :
  (y - x \in Interval (BSide b0 0) (BSide b1 y)) =
  (x \in Interval (BSide (~~ b1) 0) (BSide (~~ b0) y)).
Proof. by rewrite memB_itv add0r. Qed.

Section bool_to_real.
Context d (T : measurableType d) (R : realType) (P : probability T R) (f : {mfun T >-> bool}).
Definition bool_to_real : T -> R := (fun x => x%:R) \o (f : T -> bool).

Lemma measurable_bool_to_real : measurable_fun [set: T] bool_to_real.
Proof.
rewrite /bool_to_real.
apply: measurableT_comp => //=.
exact: (@measurable_funPT _ _ _ _ f).
Qed.
(* HB.about isMeasurableFun.Build. *)
HB.instance Definition _ :=
  isMeasurableFun.Build _ _ _ _ bool_to_real measurable_bool_to_real.

HB.instance Definition _ := MeasurableFun.on bool_to_real.

End bool_to_real.

Section mfunM.
Context {d} (T : measurableType d) {R : realType}.

HB.instance Definition _ (f g : {mfun T >-> R}) :=
  @isMeasurableFun.Build d _ _ _ (f \* g)%R
    (measurable_funM (measurable_funPT f) (measurable_funPT g)).

End mfunM.

HB.instance Definition _ (n : nat) := isPointed.Build 'I_n.+1 ord0.

HB.instance Definition _ (n : nat) := @isMeasurable.Build default_measure_display
  'I_n.+1 discrete_measurable discrete_measurable0
  discrete_measurableC discrete_measurableU.

Section move_to_bigop_nat_lemmas.
Context {T : Type}.
Implicit Types (A : set T).

Lemma bigcup_mkord_ord n (F : 'I_n.+1 -> set T) :
  \bigcup_(i < n.+1) F (inord i) = \big[setU/set0]_(i < n.+1) F i.
Proof.
rewrite bigcup_mkord; apply: eq_bigr => /= i _; congr F.
by apply/val_inj => /=;rewrite inordK.
Qed.

End move_to_bigop_nat_lemmas.

Section fset.
Local Open Scope fset_scope.
Lemma fset_bool : forall B : {fset bool},
    [\/ B == [fset true], B == [fset false], B == fset0 | B == [fset true; false]].
Proof.
move=> B.
have:= set_bool [set` B].
rewrite -!set_fset1 -set_fset0.
rewrite (_ : [set: bool] = [set` [fset true; false]]); last first.
  by apply/seteqP; split=> -[]; rewrite /= !inE eqxx.
by case=> /eqP /(congr1 (@fset_set _)) /[!set_fsetK] /eqP H;
   [apply: Or41|apply: Or42|apply: Or43|apply: Or44].
Qed.
End fset.

Lemma finite_prod {R : realType} n (F : 'I_n -> \bar R) :
  (forall i, 0 <= F i < +oo)%E -> (\prod_(i < n) F i < +oo)%E.
Proof.
move: F; elim: n => n; first by rewrite big_ord0 ltry.
move=> ih F Foo.
rewrite big_ord_recl lte_mul_pinfty//.
- by have /andP[] := Foo ord0.
- rewrite fin_numElt.
  have /andP[F0 ->] := Foo ord0.
  by rewrite (@lt_le_trans _ _ 0%E).
by rewrite ih.
Qed.

(* TODO: this generalize subset_itv! *)
Lemma subset_itvW_bound (d : Order.disp_t) (T : porderType d)
  (x y z u : itv_bound T) :
  (x <= y)%O -> (z <= u)%O -> [set` Interval y z] `<=` [set` Interval x u].
Proof.
move=> xy zu.
by apply: (@subset_trans _ [set` Interval x z]);
  [exact: subset_itvr | exact: subset_itvl].
Qed.

Lemma gtr0_derive1_homo (R : realType) (f : R^o -> R^o) (a b : R) (sa sb : bool) :
  (forall x : R, x \in `]a, b[ -> derivable f x 1) ->
  (forall x : R, x \in `]a, b[ -> 0 < 'D_1 f x) ->
  {within [set` (Interval (BSide sa a) (BSide sb b))], continuous f} ->
  {in (Interval (BSide sa a) (BSide sb b)) &, {homo f : x y / x < y >-> x < y}}.
Proof.
move=> df dfgt0 cf x y + + xy.
rewrite !itv_boundlr /= => /andP [] ax ? /andP [] ? yb.
have HMVT1: {within `[x, y], continuous f}%classic.
  exact/(continuous_subspaceW _ cf)/subset_itvW_bound.
have zab z : z \in `]x, y[ -> z \in `]a, b[.
  apply: subset_itvW_bound.
    by move: ax; clear; case: sa; rewrite !bnd_simp// => /ltW.
  by move: yb; clear; case: sb; rewrite !bnd_simp// => /ltW.
have HMVT0 (z : R^o) : z \in `]x, y[ -> is_derive z 1 f ('D_1 f z).
  by move=> zxy; exact/derivableP/df/zab.
rewrite -subr_gt0.
have[z zxy ->]:= MVT xy HMVT0 HMVT1.
rewrite mulr_gt0// ?subr_gt0// dfgt0//.
exact: zab.
Qed.

Lemma ger0_derive1_homo (R : realType) (f : R^o -> R^o) (a b : R) (sa sb : bool) :
  (forall x : R, x \in `]a, b[ -> derivable f x 1) ->
  (forall x : R, x \in `]a, b[ -> 0 <= 'D_1 f x) ->
  {within [set` (Interval (BSide sa a) (BSide sb b))], continuous f} ->
  {in (Interval (BSide sa a) (BSide sb b)) &, {homo f : x y / x <= y >-> x <= y}}.
Proof.
move=> df dfge0 cf x y + + xy.
rewrite !itv_boundlr /= => /andP [] ax ? /andP [] ? yb.
have HMVT1: {within `[x, y], continuous f}%classic.
  exact/(continuous_subspaceW _ cf)/subset_itvW_bound.
have zab z : z \in `]x, y[ -> z \in `]a, b[.
  apply: subset_itvW_bound.
    by move: ax; clear; case: sa; rewrite !bnd_simp// => /ltW.
  by move: yb; clear; case: sb; rewrite !bnd_simp// => /ltW.
have HMVT0 (z : R^o) : z \in `]x, y[ -> is_derive z 1 f ('D_1 f z).
  by move=> zxy; exact/derivableP/df/zab.
rewrite -subr_ge0.
move: (xy); rewrite le_eqVlt=> /orP [/eqP-> | xy']; first by rewrite subrr.
have[z zxy ->]:= MVT xy' HMVT0 HMVT1.
rewrite mulr_ge0// ?subr_ge0// dfge0//.
exact: zab.
Qed.

Section integrable_theory.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variables (mu : {measure set T -> \bar R}).
Variables (D : set T) (mD : measurable D).
Implicit Type f g : T -> \bar R.

Let ltnP_sumbool (a b : nat) : {(a < b)%N} + {(a >= b)%N}.
Proof. by case: ltnP => _; [left|right]. Qed.

(* TODO: clean, move near integrable_sum, refactor *)
Lemma integrable_sum_ord n (t : 'I_n -> (T -> \bar R)) :
  (forall i, mu.-integrable D (t i)) ->
  mu.-integrable D (fun x => \sum_(i < n) t i x).
Proof.
move=> intt.
pose s0 := fun k => match ltnP_sumbool k n with
  | left kn => t (Ordinal kn)
  | right _ => cst 0%E
  end.
pose s := [tuple of map s0 (index_iota 0 n)].
suff: mu.-integrable D (fun x => (\sum_(i <- s) i x)%R).
  apply: eq_integrable => // i iT.
  rewrite big_map/=.
  rewrite big_mkord.
  apply: eq_bigr => /= j _.
  rewrite /s0.
  case: ltnP_sumbool => // jn.
  f_equal.
  exact/val_inj.
  have := ltn_ord j.
  by rewrite ltnNge jn.
apply: (@integrable_sum d T R mu D mD s) => /= h /mapP[/= k].
rewrite mem_index_iota leq0n/= => kn ->{h}.
have := intt (Ordinal kn).
rewrite /s0.
case: ltnP_sumbool => //.
by rewrite leqNgt kn.
Qed.

End integrable_theory.

(* TODO: clean, move near integrableD, refactor *)
Section integral_sum.
Local Open Scope ereal_scope.
Context d (T : measurableType d) (R : realType).
Variables (mu : {measure set T -> \bar R}) (D : set T) (mD : measurable D).
Variables (I : eqType) (f : I -> (T -> \bar R)).
Hypothesis intf : forall n, mu.-integrable D (f n).

Lemma integral_sum (s : seq I) :
  \int[mu]_(x in D) (\sum_(k <- s) f k x) =
  \sum_(k <- s) \int[mu]_(x in D) (f k x).
Proof.
elim: s => [|h t ih].
  under eq_integral do rewrite big_nil.
  by rewrite integral0 big_nil.
rewrite big_cons -ih -integralD//.
  by apply: eq_integral => x xD; rewrite big_cons.
rewrite [X in _.-integrable _ X](_ : _ =
    (fun x => (\sum_(h0 <- [seq f i | i <- t]) h0 x))); last first.
  by apply/funext => x; rewrite big_map.
apply: integrable_sum => //= g /mapP[i ti ->{g}].
exact: intf.
Qed.

End integral_sum.

(* TODO: integral_fune_lt_pinfty does not look useful a lemma *)

Lemma bounded_RV_integrable d (T : measurableType d) (R : realType)
    (P : probability T R) (X : T -> R) M :
  measurable_fun setT X ->
  (forall t, (0 <= X t <= M)%R) -> P.-integrable setT (EFin \o X).
Proof.
move=> mf XM.
apply: (@le_integrable _ T R _ _ measurableT _ (EFin \o cst M)).
- exact/measurable_EFinP.
- move=> t _ /=; rewrite lee_fin/=.
  rewrite !ger0_norm//.
  + by have /andP[] := XM t.
  + by rewrite (@le_trans _ _ (X t))//; have /andP[] := XM t.
  + by have /andP[] := XM t.
- exact: finite_measure_integrable_cst.
Qed.
Arguments bounded_RV_integrable {d T R P X} M.

Lemma fubini2' {d1} {T1 : measurableType d1} d2 {T2 : measurableType d2}
    {R : realType} (m1 : {sigma_finite_measure set T1 -> \bar R})
    (m2 : {sigma_finite_measure set T2 -> \bar R}) (f : T1 * T2 -> \bar R) :
  (m1 \x m2)%E.-integrable [set: T1 * T2] f ->
  (\int[m2]_x fubini_G m1 f x = \int[(m1 \x^ m2)%E]_z f z)%E.
Proof.
move=> intf; rewrite fubini2//.
apply: eq_measure_integral => //= A mA _.
apply: product_measure_unique => // B C mB mC/=.
by rewrite product_measure2E.
Qed.

Lemma fubini1' {d1} {T1 : measurableType d1} {d2} {T2 : measurableType d2}
    {R : realType} (m1 : {sigma_finite_measure set T1 -> \bar R})
    (m2 : {sigma_finite_measure set T2 -> \bar R}) (f : T1 * T2 -> \bar R) :
  (m1 \x m2)%E.-integrable [set: T1 * T2] f ->
  (\int[m1]_x fubini_F m2 f x = \int[(m1 \x^ m2)%E]_z f z)%E.
Proof.
move=> intf; rewrite fubini1//.
apply: eq_measure_integral => //= A mA _.
apply: product_measure_unique => // B C mB mC/=.
by rewrite product_measure2E.
Qed.

Lemma integrable_prodP {d1} {T1 : measurableType d1} d2 {T2 : measurableType d2}
  {R : realType} (m1 : {sigma_finite_measure set T1 -> \bar R})
  (m2 : {sigma_finite_measure set T2 -> \bar R}) (f : T1 * T2 -> \bar R) :
  (m1 \x m2)%E.-integrable [set: T1 * T2] f ->
  (m1 \x^ m2)%E.-integrable [set: T1 * T2] f.
Proof.
move=> /integrableP[mf intf]; apply/integrableP; split => //.
rewrite -fubini2'//=.
  rewrite fubini2//=.
  apply/integrableP; split => //.
    exact/measurableT_comp.
  by under eq_integral do rewrite abse_id.
apply/integrableP; split => //.
  exact/measurableT_comp.
by under eq_integral do rewrite abse_id.
Qed.

Definition g_sigma_preimage d (rT : semiRingOfSetsType d) (aT : Type)
    (n : nat) (f : 'I_n -> aT -> rT) : set (set aT) :=
  <<s \big[setU/set0]_(i < n) preimage_set_system setT (f i) measurable >>.

Lemma g_sigma_preimage_comp d1 {T1 : semiRingOfSetsType d1} n
    {T : pointedType} (f1 : 'I_n -> T -> T1) [T3 : Type] (g : T3 -> T) :
  g_sigma_preimage (fun i => f1 i \o g) =
  preimage_set_system [set: T3] g (g_sigma_preimage f1).
Proof.
rewrite {1}/g_sigma_preimage.
rewrite -g_sigma_preimageE; congr (<<s _ >>).
destruct n as [|n].
  rewrite !big_ord0 /preimage_set_system/=.
  by apply/esym; rewrite -subset0 => t/= [].
rewrite predeqE => C; split.
- rewrite -bigcup_mkord_ord => -[i Ii [A mA <-{C}]].
  exists (f1 (Ordinal Ii) @^-1` A).
    rewrite -bigcup_mkord_ord; exists i => //.
    exists A => //; rewrite setTI// (_ : Ordinal _ = inord i)//.
    by apply/val_inj => /=;rewrite inordK.
  rewrite !setTI// -comp_preimage// (_ : Ordinal _ = inord i)//.
  by apply/val_inj => /=;rewrite inordK.
- move=> [A].
  rewrite -bigcup_mkord_ord => -[i Ii [B mB <-{A}]] <-{C}.
  rewrite -bigcup_mkord_ord.
  exists i => //.
  by exists B => //; rewrite !setTI -comp_preimage.
Qed.

HB.instance Definition _ (n : nat) (T : pointedType) :=
  isPointed.Build (n.-tuple T) (nseq n point).

Lemma countable_range_bool d (T : measurableType d) (b : bool) :
  countable (range (@cst T _ b)).
Proof. exact: countableP. Qed.

HB.instance Definition _ d (T : measurableType d) b :=
  MeasurableFun_isDiscrete.Build d _ T _  (cst b) (countable_range_bool T b).

Definition measure_tuple_display : measure_display -> measure_display.
Proof. exact. Qed.

Section measurable_tuple.
Context {d} {T : measurableType d}.
Variable n : nat.

Let coors : 'I_n -> n.-tuple T -> T := fun i x => @tnth n T x i.

Let tuple_set0 : g_sigma_preimage coors set0.
Proof. exact: sigma_algebra0. Qed.

Let tuple_setC A : g_sigma_preimage coors A -> g_sigma_preimage coors (~` A).
Proof. exact: sigma_algebraC. Qed.

Let tuple_bigcup (F : _^nat) : (forall i, g_sigma_preimage coors (F i)) ->
  g_sigma_preimage coors (\bigcup_i (F i)).
Proof. exact: sigma_algebra_bigcup. Qed.

HB.instance Definition _ := @isMeasurable.Build (measure_tuple_display d)
  (n.-tuple T) (g_sigma_preimage coors) tuple_set0 tuple_setC tuple_bigcup.

End measurable_tuple.

Lemma measurable_tnth d (T : measurableType d) n (i : 'I_n) :
  measurable_fun [set: n.-tuple T] (@tnth _ T ^~ i).
Proof.
move=> _ Y mY; rewrite setTI; apply: sub_sigma_algebra => /=.
rewrite -bigcup_seq/=; exists i => //=; first by rewrite mem_index_enum.
by exists Y => //; rewrite setTI.
Qed.

Section measurable_cons.
Context d d1 (T : measurableType d) (T1 : measurableType d1).

Lemma cons_measurable_funP (n : nat) (h : T -> n.-tuple T1) :
  measurable_fun setT h <->
  forall i : 'I_n,  measurable_fun setT ((@tnth _ T1 ^~ i) \o h).
Proof.
apply: (@iff_trans _ (g_sigma_preimage
  (fun i : 'I_n  => (@tnth _ T1 ^~ i) \o h) `<=` measurable)).
- rewrite g_sigma_preimage_comp; split=> [mf A [C HC <-]|f12].
    exact: mf.
  by move=> _ A mA; apply: f12; exists A.
- split=> [h12|mh].
    move=> i _ A mA.
    apply: h12.
    apply: sub_sigma_algebra.
    destruct n as [|n].
      by case: i => [] [].
    rewrite -bigcup_mkord_ord.
    exists i => //; first by red.
    exists A => //.
    rewrite !setTI.
    rewrite (_ : inord i = i)//.
    by apply/val_inj => /=; rewrite inordK.
  apply: smallest_sub; first exact: sigma_algebra_measurable.
  destruct n as [|n].
    by rewrite big_ord0.
  rewrite -bigcup_mkord_ord.
  apply: bigcup_sub => i Ii.
  move=> A [C mC <-].
  exact: mh.
Qed.

Lemma measurable_cons (f : T -> T1) n (g : T -> n.-tuple T1) :
  measurable_fun setT f -> measurable_fun setT g ->
  measurable_fun setT (fun x : T => [the n.+1.-tuple T1 of (f x) :: (g x)]).
Proof.
move=> mf mg; apply/cons_measurable_funP => /= i.
have [->|i0] := eqVneq i ord0.
  by rewrite (_ : _ \o _ = f).
have @j : 'I_n.
  apply: (@Ordinal _ i.-1).
  rewrite prednK//.
    have := ltn_ord i.
    by rewrite ltnS.
  by rewrite lt0n.
rewrite (_ : _ \o _ = (fun x => tnth (g x) j))//.
  apply: (@measurableT_comp _ _ _ _ _ _
    (fun x : n.-tuple T1 => tnth x j) _ g) => //.
  exact: measurable_tnth.
apply/funext => t/=.
rewrite (_ : i = lift ord0 j) ?tnthS//.
apply/val_inj => /=.
by rewrite /bump/= add1n prednK// lt0n.
Qed.

End measurable_cons.

(* NB: not used *)
Lemma behead_mktuple n {T : eqType} (t : n.+1.-tuple T) :
  behead t = [tuple (tnth t (lift ord0 i)) | i < n].
Proof.
destruct n as [|n].
  rewrite !tuple0.
  apply: size0nil.
  by rewrite size_behead size_tuple.
apply: (@eq_from_nth _ (tnth_default t ord0)).
  by rewrite size_behead !size_tuple.
move=> i ti.
rewrite nth_behead/= (nth_map ord0); last first.
  rewrite size_enum_ord.
  by rewrite size_behead size_tuple in ti.
rewrite (tnth_nth (tnth_default t ord0)).
congr nth.
rewrite /= /bump/= add1n; congr S.
apply/esym.
rewrite size_behead size_tuple in ti.
have := @nth_ord_enum _ ord0 (Ordinal ti).
by move=> ->.
Qed.

Lemma measurable_behead d (T : measurableType d) n :
  measurable_fun setT (fun x : n.+1.-tuple T => [tuple of behead x] : n.-tuple T).
Proof.
red=> /=.
move=> _ Y mY.
rewrite setTI.
set bh := (bh in preimage bh).
have bhYE : (bh @^-1` Y) = [set x :: y | x in setT & y in Y].
  rewrite /bh.
  apply/seteqP; split=> x /=.
    move=> ?; exists (thead x)=> //.
    exists [tuple of behead x] => //=.
    by rewrite [in RHS](tuple_eta x).
  case=> x0 _ [] y Yy xE.
  suff->: [tuple of behead x] = y by [].
  apply/val_inj=> /=.
  by rewrite -xE.
have:= mY.
rewrite /measurable/= => + F [] sF.
pose F' := image_set_system setT bh F.
move=> /(_ F') /=.
have-> : F' Y = F (bh @^-1` Y) by rewrite /F' /image_set_system /= setTI.
move=> /[swap] H; apply; split; first exact: sigma_algebra_image.
move=> A; rewrite /= /F' /image_set_system /= setTI.
set X := (X in X A).
move => XA.
apply: H; rewrite big_ord_recl /=; right.
set X' := (X' in X' (preimage _ _)).
have-> : X' = preimage_set_system setT bh X.
  rewrite /X.
  rewrite (big_morph _ (preimage_set_systemU _ _) (preimage_set_system0 _ _)).
  apply: eq_bigr=> i _.
  rewrite -preimage_set_system_comp.
  congr preimage_set_system.
  apply: funext=> t.
  rewrite (tuple_eta t) /bh /= tnthS.
  by congr tnth; apply/val_inj.
exists A=> //.
by rewrite setTI.
Qed.

Section tuple_sum.
Context d (T : measurableType d) (R : realType) (P : probability T R).

Definition Tnth n (X : n.-tuple {mfun T >-> R}) i : n.-tuple T -> R :=
  fun t => (tnth X i) (tnth t i).

Lemma measurable_Tnth n (X : n.-tuple {mfun T >-> R}) i :
  measurable_fun [set: n.-tuple T] (Tnth X i).
Proof. by apply: measurableT_comp => //; exact: measurable_tnth. Qed.

HB.instance Definition _ n (X : n.-tuple {mfun T >-> R}) (i : 'I_n) :=
  isMeasurableFun.Build _ _ _ _ (Tnth X i) (measurable_Tnth X i).

Lemma measurable_tuple_sum n (X : n.-tuple {mfun T >-> R}) :
  measurable_fun setT (\sum_(i < n) (Tnth X i))%R.
Proof.
rewrite [X in measurable_fun _ X](_ : _
    = (fun x => \sum_(i < n) Tnth X i x)); last first.
  by apply/funext => x; rewrite fct_sumE.
apply: measurable_sum => i/=; apply/measurableT_comp => //.
exact: measurable_tnth.
Qed.

HB.instance Definition _ n (s : n.-tuple {mfun T >-> R}) :=
  isMeasurableFun.Build _ _ _ _ (\sum_(i < n) Tnth s i)%R (measurable_tuple_sum s).

Lemma measurable_tuple_prod m n (s : m.-tuple {mfun T >-> R}) (f : 'I_n -> 'I_m) :
  measurable_fun setT (\prod_(i < n) Tnth s (f i))%R.
Proof.
rewrite [X in measurable_fun _ X](_ : _
    = (fun x => \prod_(i < n) Tnth s (f i) x)); last first.
  by apply/funext => x; rewrite fct_prodE.
by apply: measurable_prod => /= i _; apply/measurableT_comp => //.
Qed.

HB.instance Definition _ m n (s : m.-tuple {mfun T >-> R}) (f : 'I_n -> 'I_m) :=
  isMeasurableFun.Build _ _ _ _ (\prod_(i < n) Tnth s (f i))%R (measurable_tuple_prod s f).

End tuple_sum.

Section pro1.
Context {d1} {T1 : measurableType d1} {d2} {T2 : measurableType d2}
  (R : realType) (P1 : probability T1 R) (P2 : probability T2 R).

Definition pro1 := (P1 \x P2)%E.

HB.instance Definition _ := Measure.on pro1.

Lemma pro1_setT : pro1 setT = 1%E.
Proof.
rewrite /pro1 -setXTT product_measure1E// -[RHS]mule1.
by rewrite -{1}(@probability_setT _ _ _ P1) -(@probability_setT _ _ _ P2).
Qed.

HB.instance Definition _ := Measure_isProbability.Build _ _ _ pro1 pro1_setT.
End pro1.

Section pro2.
Context {d1} {T1 : measurableType d1} {d2} {T2 : measurableType d2}
  (R : realType) (P1 : probability T1 R) (P2 : probability T2 R).

Definition pro2 := (P1 \x^ P2)%E.

HB.instance Definition _ := Measure.on pro2.

Lemma pro2_setT : pro2 setT = 1%E.
Proof.
rewrite /pro2 -setXTT product_measure2E// -[RHS]mule1.
by rewrite -{1}(@probability_setT _ _ _ P1) -(@probability_setT _ _ _ P2).
Qed.

HB.instance Definition _ := Measure_isProbability.Build _ _ _ pro2 pro2_setT.
End pro2.

Section iterated_product_of_probability_measures.
Context d (T : measurableType d) (R : realType) (P : probability T R).

Fixpoint ipro (n : nat) : set (n.-tuple T) -> \bar R :=
  match n with
  | 0%N => \d_([::] : 0.-tuple T)
  | m.+1 => fun A => (P \x^ @ipro m)%E [set (thead x, [tuple of behead x]) | x in A]
  end.

Lemma ipro_measure n : @ipro n set0 = 0 /\ (forall A, 0 <= @ipro n A)%E
  /\ semi_sigma_additive (@ipro n).
Proof.
elim: n => //= [|n ih].
  by repeat split => //; exact: measure_semi_sigma_additive.
pose build_Mpro := isMeasure.Build _ _ _ (@ipro n) ih.1 ih.2.1 ih.2.2.
pose Mpro : measure _ R := HB.pack (@ipro n) build_Mpro.
pose ppro : measure _ R := (P \x^ Mpro)%E.
split.
  rewrite image_set0 /product_measure2 /=.
  under eq_fun => x do rewrite ysection0 measure0 (_ : 0 = cst 0 x)//.
  by rewrite (_ : @ipro n = Mpro)// integral_cst// mul0e.
split.
  by move => A; rewrite (_ : @ipro n = Mpro).
rewrite (_ : @ipro n = Mpro)// (_ : (P \x^ Mpro)%E = ppro)//.
move=> F mF dF mUF.
rewrite image_bigcup.
move=> [:save].
apply: measure_semi_sigma_additive.
- abstract: save.
  move=> i.
  pose f (t : n.+1.-tuple T) := (@thead n T t, [the _.-tuple T of behead t]).
  pose f' (x : T * n.-tuple T) := [the n.+1.-tuple T of x.1 :: x.2].
  rewrite [X in measurable X](_ : _ = f' @^-1` F i); last first.
    apply/seteqP; split=> [x/= [t Fit] <-{x}|[x1 x2] /= Fif'].
    rewrite /f'/=.
    by rewrite (tuple_eta t) in Fit.
  exists (f' (x1, x2)) => //.
  rewrite /f' /= theadE//; congr pair.
  exact/val_inj.
  rewrite -[X in measurable X]setTI.
  suff: measurable_fun setT f' by exact.
  exact: measurable_cons.
- (* TODO: lemma? *)
  apply/trivIsetP => i j _ _ ij.
  move/trivIsetP : dF => /(_ i j Logic.I Logic.I ij).
  rewrite -!subset0 => ij0 /= [_ _] [[t Fit] [<- <-]]/=.
  move=> [u Fju [hut tut]].
  have := ij0 t; apply; split => //.
  suff: t = u by move=> ->.
  rewrite (tuple_eta t) (tuple_eta u) hut.
  by apply/val_inj => /=; rewrite tut.
- apply: bigcup_measurable => j _.
  exact: save.
Qed.

HB.instance Definition _ n := isMeasure.Build _ _ _ (@ipro n)
  (@ipro_measure n).1 (@ipro_measure n).2.1 (@ipro_measure n).2.2.

Lemma ipro_setT n : @ipro n setT = 1%E.
Proof.
elim: n => [|n ih]/=; first by rewrite diracT.
rewrite /product_measure2 /ysection/=.
under eq_fun => x.
  rewrite [X in P X](_ : _ = [set: T]); last first.
    under eq_fun => y.
      rewrite [X in _ \in X](_ : _ = setT); last first.
        apply: funext=> z/=.
        apply: propT.
        exists (z.1 :: z.2) => //=.
        case: z => z1 z2/=.
        congr pair.
        exact/val_inj.
      over.
    by apply: funext => y /=; rewrite in_setT trueE.
  rewrite probability_setT.
  over.
by rewrite integral_cst// mul1e.
Qed.

HB.instance Definition _ n :=
  Measure_isProbability.Build _ _ _ (@ipro n) (@ipro_setT n).

End iterated_product_of_probability_measures.
Arguments ipro {d T R} P n.

Notation "\X_ n P" := (ipro P n) (at level 10, n, P at next level,
  format "\X_ n  P").

Section integral_ipro.
Context d (T : measurableType d) (R : realType) (P : probability T R).
Local Open Scope ereal_scope.

Definition phi n := fun w : T * n.-tuple T => [the _.-tuple _ of w.1 :: w.2].

Lemma mphi n : measurable_fun [set: T * n.-tuple T] (@phi n).
Proof. exact: measurable_cons. Qed.

Definition psi n := fun w : n.+1.-tuple T => (thead w, [the _.-tuple _ of behead w]).

Lemma mpsi n : measurable_fun [set: _.-tuple _] (@psi n).
Proof.
by apply/measurable_fun_prod => /=;
  [exact: measurable_tnth|exact: measurable_behead].
Qed.

Lemma phiK n : cancel (@phi n) (@psi n).
Proof.
by move=> [x1 x2]; rewrite /psi /phi/=; congr pair => /=; exact/val_inj.
Qed.

Let psiK n : cancel (@psi n) (@phi n).
Proof. by move=> x; rewrite /psi /phi/= [RHS]tuple_eta. Qed.

Lemma integral_ipro n (f : n.+1.-tuple T -> R) :
  (\X_n.+1 P).-integrable [set: n.+1.-tuple T] (EFin \o f) ->
  \int[\X_n.+1 P]_w (f w)%:E =
  \int[pro2 P (\X_n P)]_w (f (w.1 :: w.2))%:E.
Proof.
move=> /integrableP[mf intf].
rewrite -(@integral_pushforward _ _ _ _ R _ (@mphi n) _ setT
    (fun x : n.+1.-tuple T => (f x)%:E)); [|by []| |by []].
  apply: eq_measure_integral => A mA _.
  rewrite /=.
  rewrite /pushforward.
  rewrite /pro2.
  rewrite /phi/=.
  rewrite /preimage/=.
  congr (_ _).
  apply/seteqP; split => [x/= [t At <-/=]|x/= Ax].
    move: At.
    by rewrite {1}(tuple_eta t)//.
  exists (x.1 :: x.2) => //=.
  destruct x as [x1 x2] => //=.
  congr pair.
  exact/val_inj.
rewrite /=.
apply/integrable_prodP.
rewrite /=.
apply/integrableP; split => /=.
  apply: measurableT_comp => //=.
  exact: mphi.
apply: le_lt_trans (intf).
rewrite [leRHS](_ : _ = \int[\X_n.+1 P]_x
    ((((abse \o (@EFin R \o (f \o (@phi n))))) \o (@psi n)) x)); last first.
  by apply: eq_integral => x _ /=; rewrite psiK.
rewrite le_eqVlt; apply/orP; left; apply/eqP.
rewrite -[RHS](@integral_pushforward _ _ _ _ R _ (@mpsi n) _ setT
    (fun x : T * n.-tuple T => ((abse \o (EFin \o (f \o (@phi n)))) x)))//.
- apply: eq_measure_integral => // A mA _.
  apply: product_measure_unique => // B C mB mC.
  rewrite /= /pushforward/=.
  rewrite -product_measure2E//=.
  congr (_ _).
  (* TODO: lemma *)
  apply/seteqP; split => [[x1 x2]/= [t [Bt Ct]] [<- <-//]|].
  move=> [x1 x2] [B1 C2] /=.
  exists (x1 :: x2) => //=.
    split=> //.
    rewrite [X in C X](_ : _ = x2)//.
    exact/val_inj.
  congr pair => //.
  exact/val_inj.
- apply/measurable_EFinP => //=.
  apply: measurableT_comp => //=.
  apply: measurableT_comp => //=.
    exact/measurable_EFinP.
  exact: mphi.
- have : (\X_n.+1 P).-integrable [set: n.+1.-tuple T] (EFin \o f).
    exact/integrableP.
- apply: le_integrable => //=.
  + apply: measurableT_comp => //=; last exact: mpsi.
    apply/measurable_EFinP => //=.
    apply: measurableT_comp => //=.
    apply: measurableT_comp => //=; last exact: mphi.
    by apply/measurable_EFinP => //=.
  + move=> x _.
    by rewrite normr_id// psiK.
Qed.

Lemma integral_ipro_ge0 n (f : {mfun n.+1.-tuple T >-> R}) :
    (forall x, 0 <= f x)%R ->
  \int[\X_n.+1 P]_w (f w)%:E = \int[pro2 P (\X_n P)]_w (f (w.1 :: w.2))%:E.
Proof.
move=> f0.
rewrite -(@ge0_integral_pushforward _ _ _ _ R _ (@mphi n) _ setT
    (fun x : n.+1.-tuple T => (f x)%:E)); [ | by [] | exact: measurableT_comp | ].
  apply: eq_measure_integral => A mA _.
  rewrite /=.
  rewrite /pushforward.
  rewrite /pro2.
  rewrite /phi/=.
  rewrite /preimage/=.
  congr (_ _).
  apply/seteqP; split => [x/= [t At <-/=]|x/= Ax].
    move: At.
    by rewrite {1}(tuple_eta t)//.
  exists (x.1 :: x.2) => //=.
  destruct x as [x1 x2] => //=.
  congr pair.
  exact/val_inj.
move=> x/= _.
by rewrite lee_fin.
Qed.

Lemma ipro_tnth n A i:
  d.-measurable A ->
 (\X_n P) ((tnth (T:=T))^~ i @^-1` A) = P A.
Proof.
elim: n A i => [|n ih A].
  by move=> A; case; case => //.
case; case => [i0|m mn mA].
- transitivity ((P \x^ \X_n P) (A `*` [set: n.-tuple T])).
    rewrite /ipro.
    congr (_ _).
    apply: funext => x/=.
    apply/propext; split.
      move=> [y] Ay0 <-; split => //=.
      by rewrite /thead (_ : ord0 = Ordinal i0)//=; apply: val_inj => /=.
    move=> []Ax _. exists (x.1 :: x.2) => //=.
    rewrite /thead tnth0 [RHS]surjective_pairing.
    congr (_, _).
    by apply: val_inj => /=.
  rewrite /product_measure2/= setXT.
  under [X in integral _ _ X]eq_fun => x do rewrite ysection_preimage_fst.
  by rewrite integral_cst//= probability_setT mule1.
have mn' : (m < n)%N by rewrite -ltnS.
transitivity ((P \x^ \X_n P) ([set: T] `*` ((tnth (T:=T)^~ (Ordinal mn') @^-1` A)))).
  rewrite /ipro.
  congr (_ _).
  apply: funext => x/=.
  apply/propext; split.
    move=> [y]/= Ay <-; split => //=.
    rewrite tnth_behead/=.
    rewrite (_ : inord m.+1 = Ordinal mn)//.
    apply: val_inj => //=.
    by rewrite inordK.
  move=> [_ Ax].
  exists [tuple of x.1 :: x.2].
    rewrite (_ : Ordinal mn = lift ord0 (Ordinal mn'))//=; last first.
      apply: val_inj => /=.
      by rewrite /bump//=.
    by rewrite tnthS.
  move: x Ax.
  case => x1 x2/= Ax.
  congr (_ ,_ ).
  by apply: val_inj.
rewrite product_measure2E//=; first by rewrite probability_setT mul1e ih.
rewrite -[X in measurable X]setTI.
exact: measurable_tnth.
Qed.

Lemma integral_tnth n (f : {mfun T >-> R}) i :
  \int[\X_n P]_x (`|f (tnth x i)|)%:E = \int[P]_x (`|f x|)%:E.
Proof.
rewrite -(preimage_setT ((@tnth n _)^~ i)).
rewrite -(@ge0_integral_pushforward _ _ _ _ _ _ (measurable_tnth i) (\X_n P) _ (EFin \o normr \o f) measurableT).
- apply: eq_measure_integral => A mA _/=.
  by rewrite /pushforward ipro_tnth.
- by do 2 apply: measurableT_comp => //.
by move=> y _/=; rewrite lee_fin normr_ge0.
Qed.

Lemma tnth_integrable n (F : n.-tuple {mfun T >-> R}) i :
  P.-integrable [set: T] (EFin \o tnth F i) ->
    (\X_n P).-integrable [set: n.-tuple T] (EFin \o Tnth F i).
Proof.
move=> /integrableP/=[mF iF]; rewrite /Tnth.
apply/integrableP; split.
  apply: measurableT_comp => //.
  apply: measurableT_comp => //.
  exact: measurable_tnth.
rewrite /=.
by rewrite (integral_tnth (tnth F i)).
Qed.

Lemma integral_ipro_tnth n (F : n.-tuple {mfun T >-> R}) :
    (forall Fi : {mfun T >-> R}, Fi \in F -> (Fi : T -> R) \in lfun P 1) ->
  forall i : 'I_n, \int[\X_n P]_x (Tnth F i x)%:E = \int[P]_x (tnth F i x)%:E.
Proof.
elim: n F => //=[F FiF|]; first by case=> m i0.
move=> m ih F lfunFi/=.
rewrite [X in integral X](_ : _ = \X_m.+1 P)//.
case; case => [i0|i im].
  rewrite [LHS](@integral_ipro m (Tnth F (Ordinal i0))); last first.
    by apply/tnth_integrable/lfun1_integrable/lfunFi/mem_tnth.
  under eq_fun => x do
    rewrite /Tnth (_ : tnth (_ :: _) _ = tnth [tuple of x.1 :: x.2] ord0)// tnth0.
  rewrite -fubini1'/fubini_F/=; last first.
    apply/integrable12ltyP => /=.
      apply: measurableT_comp => //=.
      exact: measurableT_comp.
    under eq_integral => x _ do rewrite integral_cst//= probability_setT mule1. 
    have /lfunFi : tnth F (Ordinal i0) \in F by apply/tnthP; exists (Ordinal i0).
    by move/lfun1_integrable /integrableP => [_].
  apply: eq_integral => x _.
  by rewrite integral_cst//= probability_setT mule1.
rewrite [LHS](@integral_ipro m (Tnth F (Ordinal im))); last first.
  by apply/tnth_integrable/lfun1_integrable/lfunFi/mem_tnth.
have jm : (i < m)%nat by rewrite ltnS in im.
have liftjm : Ordinal im = lift ord0 (Ordinal jm).
  by apply: val_inj; rewrite /= /bump add1n.
rewrite (tuple_eta F).
under eq_integral => x _ do rewrite /Tnth !liftjm !tnthS.
rewrite -fubini2'/fubini_G/=; last first.
  apply/integrable12ltyP => /=.
    apply: measurableT_comp => //=.
    apply: measurableT_comp => //=.
    apply: (@measurableT_comp _ _ _ _ _ _ (fun x => tnth x (Ordinal jm)) _ (fun x => x.2)).
      exact: measurable_tnth.
    exact: measurable_snd.
  rewrite [ltLHS](_ : _ = \int[\X_m P]_y `|tnth (behead_tuple F) (Ordinal jm) (tnth y (Ordinal jm))|%:E); last first.
    by rewrite integral_cst//= probability_setT mule1.
  have : (tnth F (lift ord0 (Ordinal jm)) : T -> R) \in lfun P 1.
    by rewrite lfunFi// mem_tnth.
  rewrite {1}(tuple_eta F) tnthS.
  by move/lfun1_integrable/tnth_integrable/integrableP => [_]/=.
transitivity (\int[\X_m P]_x (tnth (behead F) (Ordinal jm) (tnth x (Ordinal jm)))%:E).
  apply: eq_integral => /=x _.
  by rewrite integral_cst//= probability_setT mule1.
rewrite [LHS]ih; last by move=> Fi FiF; apply: lfunFi; rewrite mem_behead.
apply: eq_integral => x _.
by rewrite liftjm tnthS.
Qed.

End integral_ipro.

Section properties_of_expectation.
Context d (T : measurableType d) (R : realType) (P : probability T R).
Local Open Scope ereal_scope.

Lemma expectation_sum_ipro n (X : n.-tuple {RV P >-> R}) :
    [set` X] `<=` lfun P 1 ->
  'E_(\X_n P)[\sum_(i < n) Tnth X i] = \sum_(i < n) ('E_P[(tnth X i)]).
Proof.
move=>/= bX.
rewrite (_ : \sum_(i < n) Tnth X i = \sum_(Xi <- [seq Tnth X i | i in 'I_n]) Xi)%R; last first.
  by rewrite big_map big_enum.
rewrite expectation_sum/=.
  rewrite big_map big_enum/=.
  apply: eq_bigr => i i_n.
  rewrite unlock.
  exact: integral_ipro_tnth.  
move=> Xi /tnthP[i] ->.
pose j := cast_ord (card_ord _) i.
apply/lfun1_integrable => /=.
rewrite /image_tuple tnth_map.
apply: tnth_integrable.
rewrite (_ : (tnth (enum_tuple 'I_n) i) = j); last first.
  apply: val_inj => //=.
  rewrite /tnth nth_enum_ord//.
  have := ltn_ord i.
  move/leq_trans.
  apply.
  by rewrite card_ord leqnn.
by have /bX/lfun1_integrable : (tnth X j) \in X by apply/tnthP; exists j.
Qed.

Lemma expectation_pro2 d1 d2 (T1 : measurableType d1) (T2 : measurableType d2)
  (P1 : probability T1 R) (P2 : probability T2 R)
  (X : {mfun T1 >-> R}) (Y : {mfun T2 >-> R}) :
  (X : _ -> _) \in lfun P1 1  ->
  (Y : _ -> _) \in lfun P2 1 ->
  let XY := fun (x : T1 * T2) => (X x.1 * Y x.2)%R in
  'E_(pro2 P1 P2)[XY] = 'E_P1[X] * 'E_P2[Y].
Proof.
move=> intX intY/=.
rewrite unlock /expectation/=. rewrite /pro2. rewrite -fubini1'/=; last first.
  apply/integrable21ltyP.
  - apply/measurable_EFinP => //=.
    by apply: measurable_funM => //=; apply: measurableT_comp.
  - under eq_integral.
      move=> t _.
      under eq_integral.
        move=> x _.
        rewrite /= normrM EFinM muleC.
        over.
      rewrite /= integralZl//; last first.
        by move/lfun1_integrable/integrable_abse : intX.
      over.
    rewrite /=.
    rewrite ge0_integralZr//; last 2 first.
      apply/measurable_EFinP => //.
      by apply/measurableT_comp => //.
      by apply: integral_ge0 => //.
    rewrite lte_mul_pinfty//.
      by apply: integral_ge0 => //.
      apply: integral_fune_fin_num => //.
      by move/lfun1_integrable/integrable_abse : intY.
      by move/lfun1_integrable/integrableP : intX => [].
rewrite /fubini_F/=.
under eq_integral => x _.
  under eq_integral => y _ do rewrite EFinM.
  rewrite integralZl//; last exact/lfun1_integrable.
  rewrite -[X in _ * X]fineK ?integral_fune_fin_num//; last exact/lfun1_integrable.
  over.
rewrite /=integralZr//; last exact/lfun1_integrable.
by rewrite fineK// integral_fune_fin_num; last exact/lfun1_integrable.
Qed.

End properties_of_expectation.

Section properties_of_independence.
Context d (T : measurableType d) (R : realType) (P : probability T R).
Local Open Scope ereal_scope.

Lemma boundedM U (f g : U -> R) (A : set U) :
  [bounded f x | x in A] ->
  [bounded g x | x in A] ->
  [bounded (f x * g x)%R | x in A].
Proof.
move=> bF bG.
rewrite/bounded_near.
case: bF => M1 [M1real M1f].
case: bG => M2 [M2real M2g].
near=> M.
rewrite/globally/= => x xA.
rewrite normrM.
rewrite (@le_trans _ _ (`|M1 + 1| * `|M2 + 1|)%R)//.
rewrite ler_pM//.
  by rewrite M1f// (lt_le_trans _ (ler_norm _))// ltrDl.
by rewrite M2g// (lt_le_trans _ (ler_norm _))// ltrDl.
Unshelve. all: by end_near.
Qed.

Lemma expectation_prod_nondep n (X : n.-tuple {RV P >-> R}) :
    [set` X] `<=` lfun P 1 -> (forall i t, 0 <= tnth X i t)%R ->
  'E_(\X_n P)[ \prod_(i < n) Tnth X i] = \prod_(i < n) 'E_P[ (tnth X i) ].
Proof.
elim: n X => [X|n IH X] intX posX/=.
  by rewrite !big_ord0 expectation_cst.
rewrite unlock /expectation.
rewrite [X in integral X](_ : _ = \X_n.+1 P)//.
pose F : n.+1.-tuple T -> R := (\prod_(i < n.+1) Tnth X i)%R.
have mF : measurable_fun setT F by apply: measurable_tuple_prod.
pose build_mF := isMeasurableFun.Build _ _ _ _ F mF.
pose MF : {mfun _ >-> _} := HB.pack F build_mF.
rewrite [LHS](@integral_ipro_ge0 _ _ _ _ _ MF) /pro2; last first.
  by rewrite /MF/F/= => t; rewrite fct_prodE/Tnth/= prodr_ge0//.
under eq_fun.
  move=> /=x.
  rewrite /F/MF.
  rewrite big_ord_recl/=.
  rewrite /Tnth/= fctE tnth0.
  rewrite fct_prodE.
  under eq_bigr.
    move=> i _.
    rewrite tnthS.
    over.
  over.
have /lfun1_integrable/integrableP/=[mXi iXi] := intX _ (mem_tnth ord0 X).
have ? : \int[\X_n P]_x0 (\prod_(i < n) tnth X (lift ord0 i) (tnth x0 i))%:E < +oo.
  under eq_integral => x _.
    rewrite [X in X%:E](_ : _ = \prod_(i < n) tnth (behead_tuple X) i (tnth x i))%R; last first.
      by apply: eq_bigr => i _; rewrite (tuple_eta X) tnthS -tuple_eta.
    over.
  rewrite /= -(_ : 'E_(\X_n P)[\prod_(i < n) Tnth (behead_tuple X) i]%R = \int[\X_n P]_x _); last first.
    rewrite unlock.
    apply: eq_integral => /=x _.
    by rewrite /Tnth fct_prodE.
  rewrite IH.
  - apply: finite_prod => i; rewrite expectation_ge0//=.
      rewrite unlock tnth_behead.
      have /lfun1_integrable/integrableP[?] := (intX (tnth X (inord i.+1)) (mem_tnth _ _)).
      apply: le_lt_trans.
      apply: ge0_le_integral => //.
      - by move=> x _; rewrite lee_fin posX.
      - by apply: measurableT_comp => //.
      by move=> x _; rewrite lee_fin ler_norm.
    by move=> x; rewrite tnth_behead posX.
  - by move=> Xi XiX; rewrite intX//= mem_behead.
  by move=> i t; rewrite tnth_behead posX.
have ? : measurable_fun [set: n.-tuple T]
    (fun x : n.-tuple T => \prod_(i < n) tnth X (lift ord0 i) (tnth x i))%R.
  apply: measurable_prod => //= i i_n.
  apply: measurableT_comp => //.
  exact: measurable_tnth.
rewrite /=.
rewrite -fubini1' /fubini_F/=; last first.
  apply/integrable21ltyP => //=.
    apply: measurableT_comp => //.
    apply: measurable_funM => //=.
      exact: measurableT_comp.
    apply: measurable_prod => //= i i_n.
    apply: measurableT_comp => //.
    exact: (measurableT_comp (measurable_tnth i) measurable_snd).
  under eq_integral => y _.
    under eq_integral => x _ do rewrite normrM EFinM.
    rewrite integralZr//; last exact/lfun1_integrable/lfun_norm/intX/mem_tnth.
    rewrite -[X in X * _]fineK ?ge0_fin_numE ?integral_ge0//.
    over.
  rewrite integralZl ?fineK ?lte_mul_pinfty ?integral_ge0//=.
  - by rewrite ge0_fin_numE ?integral_ge0.
  - by under eq_integral => x _ do rewrite ger0_norm ?prodr_ge0//.
  - by rewrite ge0_fin_numE ?integral_ge0.
  - apply/integrableP; split; first by do 2 apply: measurableT_comp => //.
    by under eq_integral => x _ do rewrite /=normr_id ger0_norm ?prodr_ge0//.
under eq_integral => x _.
  under eq_integral => y _ do rewrite EFinM.
  rewrite integralZl/=; last 2 first.
  - apply: measurableT.
  - apply/integrableP; split => //; first by apply: measurableT_comp => //.
    by under eq_integral => y _ do rewrite /=ger0_norm ?prodr_ge0//.
  rewrite -[X in _ * X]fineK; last first.
    rewrite ge0_fin_numE ?integral_ge0//=; last first.
      by move=> t _; rewrite lee_fin prodr_ge0.
  over.
rewrite /= integralZr//; last exact/lfun1_integrable/intX/mem_tnth.
rewrite fineK; last first.
  by rewrite ge0_fin_numE// integral_ge0 => //=x _; rewrite lee_fin prodr_ge0//.
rewrite [X in _ * X](_ : _ = 'E_(\X_n P)[\prod_(i < n) Tnth (behead X) i])%R; last first.
  rewrite [in RHS]unlock /Tnth.
  apply: eq_integral => x _.
  rewrite fct_prodE.
  congr (_%:E).
  apply: eq_bigr => i _.
  rewrite tnth_behead.
  congr (_ _ _).
  congr (_ _ _).
  apply: val_inj => /=.
  by rewrite /bump/= inordK// ltnS.
rewrite IH; last first.
- by move=> i t; rewrite tnth_behead.
- by move=> Xi XiX; rewrite intX//= mem_behead.
rewrite big_ord_recl/=.
congr (_ * _).
apply: eq_bigr => /=i _.
rewrite unlock /expectation.
apply: eq_integral => x _.
congr EFin.
by rewrite [in RHS](tuple_eta X) tnthS.
Qed.

End properties_of_independence.

HB.mixin Record RV_isBernoulli d (T : measurableType d) (R : realType)
  (P : probability T R) (p : R) (X : T -> bool) of @isMeasurableFun d _ T bool X  := {
    bernoulliP : distribution P X = bernoulli p }.

#[short(type=bernoulliRV)]
HB.structure Definition BernoulliRV d (T : measurableType d) (R : realType)
    (P : probability T R) (p : R) :=
  {X of @RV_isBernoulli _ _ _ P p X}.
Arguments bernoulliRV {d T R}.

Section properties_of_BernoulliRV.
Local Open Scope ereal_scope.
Context d (T : measurableType d) {R : realType} (P : probability T R).
Variable p : R.
Hypothesis p01 : (0 <= p <= 1)%R.

Lemma preimage_set1 (X : T -> bool) r : X @^-1` [set r] = [set i | X i == r].
Proof. by apply/seteqP; split => [x /eqP H//|x /eqP]. Qed.

Lemma bernoulli_RV1 (X : bernoulliRV P p) : P [set i | X i == 1%R] = p%:E.
Proof.
have/(congr1 (fun f => f [set 1%:R])):= @bernoulliP _ _ _ _ _ X.
rewrite bernoulliE//.
rewrite diracE/= mem_set// mule1// diracE/= memNset//.
rewrite mule0 adde0 -preimage_set1.
by rewrite /distribution /= => <-.
Qed.

Lemma bernoulli_RV2 (X : bernoulliRV P p) : P [set i | X i == 0%R] = (`1-p)%:E.
Proof.
have/(congr1 (fun f => f [set 0%:R])):= @bernoulliP _ _ _ _ _ X.
rewrite bernoulliE//.
rewrite diracE/= memNset//.
rewrite mule0// diracE/= mem_set// add0e mule1.
rewrite /distribution /= => <-.
by rewrite -preimage_set1.
Qed.

Lemma bernoulli_expectation (X : bernoulliRV P p) :
  'E_P[bool_to_real R X] = p%:E.
Proof.
rewrite unlock.
rewrite -(@ge0_integral_distribution _ _ _ _ _ _ X (EFin \o GRing.natmul 1))//; last first.
  by move=> y //=.
rewrite /bernoulli/=.
rewrite (@eq_measure_integral _ _ _ _ (bernoulli p)); last first.
   by move=> A mA _ /=; congr (_ _); exact: bernoulliP.
rewrite integral_bernoulli//=.
by rewrite -!EFinM -EFinD mulr0 addr0 mulr1.
Qed.

Lemma integrable_bernoulli (X : bernoulliRV P p) :
  P.-integrable [set: T] (EFin \o bool_to_real R X).
Proof.
apply/integrableP; split.
  by apply: measurableT_comp => //; exact: measurable_bool_to_real.
have -> : \int[P]_x `|(EFin \o bool_to_real R X) x| = 'E_P[bool_to_real R X].
  rewrite unlock /expectation.
  apply: eq_integral => x _.
  by rewrite gee0_abs //= lee_fin.
by rewrite bernoulli_expectation// ltry.
Qed.

Lemma lfun_bernoulli (X : bernoulliRV P p) q :
  1 <= q -> (bool_to_real R X : T -> R) \in lfun P q.
Proof.
move=> q1.
apply: (@lfun_bounded _ _ _ P _ 1%R) => //t.
by rewrite /bool_to_real/= ler_norml lern1 (@le_trans _ _ 0%R) ?leq_b1.
Qed.

Lemma bool_RV_sqr (X : {RV P >-> bool}) :
  ((bool_to_real R X ^+ 2) = bool_to_real R X :> (T -> R))%R.
Proof.
apply: funext => x /=.
rewrite /GRing.exp /bool_to_real /GRing.mul/=.
by case: (X x) => /=; rewrite ?mulr1 ?mulr0.
Qed.

Lemma bernoulli_variance (X : bernoulliRV P p) :
  'V_P[bool_to_real R X] = (p * (`1-p))%:E.
Proof.
rewrite (@varianceE _ _ _ _ (bool_to_real R X));
  [|rewrite ?[X in _ \o X]bool_RV_sqr; apply: lfun_bernoulli..]; last first.
  by rewrite lee1n.
rewrite [X in 'E_P[X]]bool_RV_sqr !bernoulli_expectation//.
by rewrite expe2 -EFinD onemMr.
Qed.

Definition real_of_bool n : _ -> n.-tuple _ :=
  map_tuple (bool_to_real R : bernoulliRV P p -> {mfun _ >-> _}).

Definition trial_value n (X : n.-tuple {RV P >-> _}) : {RV (\X_n P) >-> R : realType} :=
  (\sum_(i < n) Tnth X i)%R.

Definition bool_trial_value n := @trial_value n \o @real_of_bool n.

Lemma btr_ge0 (X : {RV P >-> bool}) t : (0 <= bool_to_real R X t)%R.
Proof. by []. Qed.

Lemma btr_le1 (X : {RV P >-> bool}) t : (bool_to_real R X t <= 1)%R.
Proof. by rewrite /bool_to_real/=; case: (X t). Qed.

Lemma expectation_bernoulli_trial n (X : n.-tuple (bernoulliRV P p)) :
  'E_(\X_n P)[bool_trial_value X] = (n%:R * p)%:E.
Proof.
rewrite expectation_sum_ipro; last first.
  by move=> Xi /tnthP [i] ->; rewrite tnth_map lfun_bernoulli.
transitivity (\sum_(i < n) p%:E).
  by apply: eq_bigr => k _; rewrite !tnth_map bernoulli_expectation.
by rewrite sumEFin big_const_ord iter_addr addr0 mulrC mulr_natr.
Qed.

Lemma bernoulli_trial_ge0 n (X : n.-tuple (bernoulliRV P p)) :
  (forall t, 0 <= bool_trial_value X t)%R.
Proof.
move=> t.
rewrite [leRHS]fct_sumE.
apply/sumr_ge0 => /= i _.
rewrite /Tnth.
by rewrite !tnth_map.
Qed.

Lemma bernoulli_trial_mmt_gen_fun n (X_ : n.-tuple (bernoulliRV P p)) (t : R) :
  let X := bool_trial_value X_ in
  'M_X t = \prod_(i < n) 'M_(bool_to_real R (tnth X_ i) : {RV P >-> _}) t.
Proof.
pose mmtX : 'I_n -> {RV P >-> R : realType} := fun i => expR \o t \o* bool_to_real R (tnth X_ i).
transitivity ('E_(\X_n P)[ \prod_(i < n) Tnth (mktuple mmtX) i ])%R.
  congr expectation => /=; apply: funext => x/=.
  rewrite fct_sumE.
  rewrite big_distrl/= expR_sum.
  rewrite [in RHS]fct_prodE.
  apply: eq_bigr => i _.
  by rewrite /Tnth !tnth_map /mmtX/= tnth_ord_tuple.
rewrite /mmtX.
rewrite expectation_prod_nondep; last 2 first.
- move=> _ /mapP[/= i _ ->].
  apply: (bounded_RV_integrable (expR `|t|)) => // t0.
  rewrite expR_ge0/= ler_expR/=.
  rewrite /bool_to_real/=.
  case: (tnth X_ i t0) => //=; rewrite ?mul1r ?mul0r//.
  by rewrite ler_norm.
- by move=> i t0; rewrite tnth_map/= expR_ge0.
apply: eq_bigr => /= i _.
congr expectation.
rewrite /=.
by rewrite tnth_map/= tnth_ord_tuple.
Qed.

Arguments sub_countable [T U].
Arguments card_le_finite [T U].

Lemma bernoulli_mmt_gen_fun (X : bernoulliRV P p) (t : R) :
  'M_(bool_to_real R X : {RV P >-> R : realType}) t = (p * expR t + (1-p))%:E.
Proof.
rewrite/mmt_gen_fun.
pose mmtX : {RV P >-> R : realType} := expR \o t \o* (bool_to_real R X).
set A := X @^-1` [set true].
set B := X @^-1` [set false].
have mA: measurable A by exact: measurable_sfunP.
have mB: measurable B by exact: measurable_sfunP.
have dAB: [disjoint A & B]
  by rewrite /disj_set /A /B preimage_true preimage_false setICr.
have TAB: setT = A `|` B by rewrite -preimage_setU -setT_bool preimage_setT.
rewrite unlock.
rewrite TAB integral_setU_EFin -?TAB//.
under eq_integral.
  move=> x /=.
  rewrite /A inE /bool_to_real /= => ->.
  rewrite mul1r.
  over.
rewrite integral_cst//.
under eq_integral.
  move=> x /=.
  rewrite /B inE /bool_to_real /= => ->.
  rewrite mul0r.
  over.
rewrite integral_cst//.
rewrite /A /B /preimage /=.
under eq_set do rewrite (propext (rwP eqP)).
rewrite bernoulli_RV1.
under eq_set do rewrite (propext (rwP eqP)).
rewrite bernoulli_RV2.
rewrite -EFinD; congr (_ + _)%:E; rewrite mulrC//.
by rewrite expR0 mulr1.
Qed.

(* wrong lemma *)
Lemma binomial_mmt_gen_fun n (X_ : n.-tuple (bernoulliRV P p)) (t : R) :
  let X := bool_trial_value X_ : {RV \X_n P >-> R : realType} in
  'M_X t = ((p * expR t + (1 - p))`^(n%:R))%:E.
Proof.
move: p01 => /andP[p0 p1] bX/=.
rewrite bernoulli_trial_mmt_gen_fun//.
under eq_bigr => i _ do rewrite bernoulli_mmt_gen_fun//.
rewrite big_const iter_mule mule1 cardT size_enum_ord -EFin_expe powR_mulrn//.
by rewrite addr_ge0// ?subr_ge0// mulr_ge0// expR_ge0.
Qed.

Lemma mmt_gen_fun_expectation n (X_ : n.-tuple (bernoulliRV P p)) (t : R) :
  (0 <= t)%R ->
  let X := bool_trial_value X_ : {RV \X_n P >-> R : realType} in
  'M_X t <= (expR (fine 'E_(\X_n P)[X] * (expR t - 1)))%:E.
Proof.
move=> t_ge0/=.
have /andP[p0 p1] := p01.
rewrite binomial_mmt_gen_fun// lee_fin.
rewrite expectation_bernoulli_trial//.
rewrite addrCA -{2}(mulr1 p) -mulrN -mulrDr.
rewrite -mulrA (mulrC (n%:R)) expRM ge0_ler_powR// ?nnegrE ?expR_ge0//.
  by rewrite addr_ge0// mulr_ge0// subr_ge0 -expR0 ler_expR.
exact: expR_ge1Dx.
Qed.

End properties_of_BernoulliRV.

(* the lemmas used in the sampling theorem that are generic w.r.t. R : realType *)
Section sampling_theorem_part1.
Local Open Scope ereal_scope.
Context {d} {T : measurableType d} {R : realType} (P : probability T R).
Variable p : R.
Hypothesis p01 : (0 <= p <= 1)%R.

(* [end of Theorem 2.4, Rajani]*)
Lemma end_thm24 n (X_ : n.-tuple (bernoulliRV P p)) (t delta : R) :
  (0 < delta)%R ->
  let X := bool_trial_value X_ in
  let mu := 'E_(\X_n P)[X] in
  let t := ln (1 + delta) in
  (expR (expR t - 1) `^ fine mu)%:E *
    (expR (- t * (1 + delta)) `^ fine mu)%:E <=
    ((expR delta / (1 + delta) `^ (1 + delta)) `^ fine mu)%:E.
Proof.
move=> d0 /=.
rewrite -EFinM lee_fin -powRM ?expR_ge0// ge0_ler_powR ?nnegrE//.
- by rewrite fine_ge0// expectation_ge0// => x; exact: bernoulli_trial_ge0.
- by rewrite mulr_ge0// expR_ge0.
- by rewrite divr_ge0 ?expR_ge0// powR_ge0.
- rewrite lnK ?posrE ?addr_gt0// addrAC subrr add0r ler_wpM2l ?expR_ge0//.
  by rewrite -powRN mulNr -mulrN expRM lnK// posrE addr_gt0.
Qed.

(* [theorem 2.4, Rajani] / [thm 4.4.(2), MU] *)
Theorem bernoulli_trial_inequality1 n (X_ : n.-tuple (bernoulliRV P p)) (delta : R) :
  (0 < delta)%R ->
  let X := bool_trial_value X_ in
  let mu := 'E_(\X_n P)[X] in
  (\X_n P) [set i | X i >= (1 + delta) * fine mu]%R <=
  ((expR delta / ((1 + delta) `^ (1 + delta))) `^ (fine mu))%:E.
Proof.
rewrite /= => delta0.
set X := bool_trial_value X_.
set mu := 'E_(\X_n P)[X].
set t := ln (1 + delta).
have t0 : (0 < t)%R by rewrite ln_gt0// ltrDl.
apply: (le_trans (chernoff _ _ t0)).
apply: (@le_trans _ _ ((expR (fine mu * (expR t - 1)))%:E *
                       (expR (- (t * ((1 + delta) * fine mu))))%:E)).
  rewrite lee_pmul2r ?lte_fin ?expR_gt0//.
  by apply: mmt_gen_fun_expectation => //; exact: ltW.
rewrite mulrC expRM -mulNr mulrA expRM.
exact: end_thm24.
Qed.

Section xlnx_bounding.
Local Open Scope ring_scope.
Local Arguments derive_val {R V W a v f df}.

Let f (x : R) := x ^+ 2 - 2 * x * ln x.
Let idf (x : R) : 0 < x -> {df : R | is_derive x 1 f df}.
Proof.
move=> x0.
evar (df : (R : Type)); exists df.
apply: is_deriveD; first by [].
apply: is_deriveN.
apply: is_deriveM; first by [].
exact: is_derive1_ln.
Defined.
Let f1E : f 1 = 1. Proof. by rewrite /f expr1n ln1 !mulr0 subr0. Qed.
Let Df_gt0 (x : R) : 0 < x -> x != 1 -> 0 < 'D_1 f x.
Proof.
move=> x0 x1.
rewrite (derive_val (svalP (idf x0))) /=.
clear idf.
rewrite exp_derive deriveM// derive_cst derive_id .
rewrite scaler0 addr0 /GRing.scale /= !mulr1 expr1.
rewrite -mulrA divff ?lt0r_neq0//.
rewrite (mulrC _ 2) -mulrDr -mulrBr mulr_gt0//.
rewrite opprD addrA subr_gt0 -ltr_expR.
have:= x0; rewrite -lnK_eq => /eqP ->.
rewrite -[ltLHS]addr0 -(subrr 1) addrCA expR_gt1Dx//.
by rewrite subr_eq0.
Qed.

Let sqrxB2xlnx_lt1 (c x : R) :
  x \in `]0, 1[ -> x ^+ 2 - 2 * x * ln x < 1.
Proof.
rewrite in_itv=> /andP [] x0 x1.
fold (f x).
simpl in idf.
rewrite -f1E.
apply: (@gtr0_derive1_homo _ f 0 1 false false).
- move=> t /[!in_itv] /= /andP [] + _.
  by case/idf=> ? /@ex_derive.
- move=> t /[!in_itv] /= /andP [] t0 t1.
  apply: Df_gt0=> //.
  by rewrite (lt_eqF t1).
- apply: derivable_within_continuous => t /[!in_itv] /= /andP [] + _.
  by case/idf=> ? /@ex_derive.
- by rewrite in_itv/=; apply/andP; split=> //; apply/ltW.
- by rewrite in_itv /= ltr01 lexx.
- assumption.
Qed.

Let sqrxB2xlnx_gt1 (c x : R) :
  1 < x -> 1 < x ^+ 2 - 2 * x * ln x.
Proof.
move=> x1.
have x0 : 0 < x by rewrite (lt_trans _ x1).
fold (f x).
simpl in idf.
rewrite -f1E.
apply: (@gtr0_derive1_homo _ f 1 x true false).
- move=> t /[!in_itv] /= /andP [] + _ => t1.
  have: 0 < t by rewrite (lt_trans _ t1).
  by case/idf=> ? /@ex_derive.
- move=> t /[!in_itv] /= /andP [] t1 tx.
  have t0: 0 < t by rewrite (lt_trans _ t1).
  apply: Df_gt0=> //.
  by rewrite (gt_eqF t1).
- apply: derivable_within_continuous => t /[!in_itv] /= /andP [] + _ => t1.
  have: 0 < t by rewrite (lt_le_trans _ t1).
  by case/idf=> ? /@ex_derive.
- by rewrite in_itv/=; apply/andP; split=> //; apply/ltW.
- by rewrite in_itv /= lexx andbT ltW.
- assumption.
Qed.

Lemma xlnx_lbound_i01 (c x : R) :
  c <= 2 -> x \in `]0, 1[ -> x ^+ 2 - 1 < c * x * ln x.
Proof.
pose c' := c - 2.
have-> : c = c' + 2 by rewrite /c' addrAC -addrA subrr addr0.
rewrite -lerBrDr subrr.
move: c'; clear c => c.
rewrite ltrBlDr -ltrBlDl.
rewrite le_eqVlt=> /orP [/eqP-> |]; first by rewrite add0r; exact: sqrxB2xlnx_lt1.
move=> c0 /[dup] x01 /[!in_itv] /andP [] x0 x1.
rewrite -mulrA (addrC c) mulrDl !mulrA opprD addrA.
rewrite -[ltRHS]addr0 ltrD// ?sqrxB2xlnx_lt1// oppr_lt0.
by rewrite -mulrA nmulr_lgt0// nmulr_llt0// ln_lt0.
Qed.

Lemma xlnx_ubound_i1y (c x : R) :
  c <= 2 -> 1 < x -> c * x * ln x < x ^+ 2 - 1.
Proof.
pose c' := c - 2.
have-> : c = c' + 2 by rewrite /c' addrAC -addrA subrr addr0.
rewrite -lerBrDr subrr.
move: c'; clear c => c.
rewrite ltrBrDr -ltrBrDl.
rewrite le_eqVlt=> /orP [/eqP-> |]; first by rewrite add0r; exact: sqrxB2xlnx_gt1.
move=> c0 x1.
rewrite -mulrA (addrC c) mulrDl !mulrA opprD addrA.
rewrite -[ltLHS]addr0 ltrD// ?sqrxB2xlnx_gt1// oppr_gt0.
by rewrite nmulr_rlt0 ?ln_gt0// nmulr_rlt0 ?(lt_trans _ x1).
Qed.
End xlnx_bounding.

(* [Theorem 2.6, Rajani] / [thm 4.5.(2), MU] *)
Theorem bernoulli_trial_inequality3 n (X : n.-tuple (bernoulliRV P p)) (delta : R) :
  (0 < delta < 1)%R ->
  let X' := bool_trial_value X : {RV \X_n P >-> R : realType} in
  let mu := 'E_(\X_n P)[X'] in
  (\X_n P) [set i | X' i <= (1 - delta) * fine mu]%R <= (expR (-(fine mu * delta ^+ 2) / 2)%R)%:E.
Proof.
move=> /andP[delta0 delta1] /=.
set X' := bool_trial_value X : {RV \X_n P >-> R : realType}.
set mu := 'E_(\X_n P)[X'].
have /andP[p0 p1] := p01.
apply: (@le_trans _ _ (((expR (- delta) / ((1 - delta) `^ (1 - delta))) `^ (fine mu))%:E)).
  (* using Markov's inequality somewhere, see mu's book page 66 *)
  have H1 t : (t < 0)%R ->
    (\X_n P) [set i | (X' i <= (1 - delta) * fine mu)%R] = (\X_n P) [set i | `|(expR \o t \o* X') i|%:E >= (expR (t * (1 - delta) * fine mu))%:E].
    move=> t0; apply: congr1; apply: eq_set => x /=.
    rewrite lee_fin ger0_norm ?expR_ge0// ler_expR (mulrC _ t) -mulrA.
    by rewrite -[in RHS]ler_ndivrMl// mulrA mulVf ?lt_eqF// mul1r.
  set t := ln (1 - delta).
  have ln1delta : (t < 0)%R.
    (* TODO: lacking a lemma here *)
    rewrite -oppr0 ltrNr -lnV ?posrE ?subr_gt0// ln_gt0//.
    by rewrite invf_gt1// ?subr_gt0// ltrBlDr ltrDl.
  have {H1}-> := H1 _ ln1delta.
  apply: (@le_trans _ _ (((fine 'E_(\X_n P)[normr \o expR \o t \o* X']) / (expR (t * (1 - delta) * fine mu))))%:E).
    rewrite EFinM lee_pdivlMr ?expR_gt0// muleC fineK.
    apply: (@markov _ _ _ (\X_n P) (expR \o t \o* X' : {RV (\X_n P) >-> R : realType}) id (expR (t * (1 - delta) * fine mu))%R _ _ _ _) => //.
    - by apply: expR_gt0.
    - rewrite norm_expR.
      have -> : 'E_(\X_n P)[expR \o t \o* X'] = 'M_X' t by [].
      by rewrite binomial_mmt_gen_fun.
  apply: (@le_trans _ _ (((expR ((expR t - 1) * fine mu)) / (expR (t * (1 - delta) * fine mu))))%:E).
    rewrite norm_expR lee_fin ler_wpM2r ?invr_ge0 ?expR_ge0//.
    have -> : 'E_(\X_n P)[expR \o t \o* X'] = 'M_X' t by [].
    rewrite binomial_mmt_gen_fun//.
    rewrite /mu /X' expectation_bernoulli_trial//.
    rewrite !lnK ?posrE ?subr_gt0//.
    rewrite expRM powRrM powRAC.
    rewrite ge0_ler_powR ?ler0n// ?nnegrE ?powR_ge0//.
      by rewrite addr_ge0 ?mulr_ge0// subr_ge0// ltW.
    rewrite addrAC subrr sub0r -expRM.
    rewrite addrCA -{2}(mulr1 p) -mulrBr addrAC subrr sub0r mulrC mulNr.
    by apply: expR_ge1Dx.
  rewrite !lnK ?posrE ?subr_gt0//.
  rewrite -addrAC subrr sub0r -mulrA [X in (_ / X)%R]expRM lnK ?posrE ?subr_gt0//.
  rewrite -[in leRHS]powR_inv1 ?powR_ge0// powRM// ?expR_ge0 ?invr_ge0 ?powR_ge0//.
  by rewrite powRAC powR_inv1 ?powR_ge0// powRrM expRM.
rewrite lee_fin.
rewrite -mulrN -mulrA [in leRHS]mulrC expRM ge0_ler_powR// ?nnegrE.
- by rewrite fine_ge0// expectation_ge0// => x; exact: bernoulli_trial_ge0.
- by rewrite divr_ge0 ?expR_ge0// powR_ge0.
- by rewrite expR_ge0.
- rewrite -ler_ln ?posrE ?divr_gt0 ?expR_gt0 ?powR_gt0 ?subr_gt0//.
  rewrite expRK// ln_div ?posrE ?expR_gt0 ?powR_gt0 ?subr_gt0//.
  rewrite expRK//.
  rewrite /powR (*TODO: lemma ln of powR*) gt_eqF ?subr_gt0// expRK.
  (* analytical argument reduced to xlnx_lbound_i01; p.66 of mu's book *)
  rewrite ler_pdivlMr// mulrDl.
  rewrite -lerBrDr -lerBlDl !mulNr !opprK [in leRHS](mulrC _ 2) mulrA.
  rewrite ltW// (le_lt_trans _ (xlnx_lbound_i01 _ _))//; last first.
    by rewrite memB_itv add0r in_itv/=; apply/andP; split.
  by rewrite addrC lerBrDr mulr_natr -[in leRHS]sqrrN opprB sqrrB1.
Qed.
End sampling_theorem_part1.

(* this is a preliminary for the second part of the proof of the sampling lemma *)
Module with_interval.
Declare Scope bigQ_scope.
Import Reals.
Import Rstruct Rstruct_topology.
Import Interval.Tactic.

Section exp2_le8.
Let R := Rdefinitions.R.
Local Open Scope ring_scope.

Lemma exp2_le8 : (exp 2 <= 8)%R.
Proof. interval. Qed.

Lemma exp2_le8_conversion : reflect (exp 2 <= 8)%R (expR 2 <= 8 :> R).
Proof.
rewrite RexpE (_ : 8%R = 8); last
  by rewrite !mulrS -!RplusE Rplus_0_r !RplusA !IZRposE/=.
by apply: (iffP idP) => /RleP.
Qed.

End exp2_le8.
End with_interval.

Section xlnx_bounding_with_interval.
Let R := Rdefinitions.R.
Local Open Scope ring_scope.

Lemma xlnx_lbound_i12 (x : R) : x \in `]0, 1[ -> x + x^+2 / 3 <= (1 + x) * ln (1 + x).
Proof.
move=> x01; rewrite -subr_ge0.
pose f (x : R^o) := (1 + x) * ln (1 + x) - (x + x ^+ 2 / 3).
have f0 : f 0 = 0 by rewrite /f expr0n /= mul0r !addr0 ln1 mulr0 subr0.
rewrite [leRHS](_ : _ = f x) // -f0.
evar (df0 : R -> R); evar (df : R -> R).
have idf (y : R^o) : 0 < 1 + y -> is_derive y (1:R) f (df y).
  move=> y1.
  rewrite (_ : df y = df0 y).
    apply: is_deriveB; last exact: is_deriveD.
    apply: is_deriveM=> //.
    apply: is_derive1_comp=> //.
    exact: is_derive1_ln.
  rewrite /df0.
  rewrite deriveD// derive_cst derive_id.
  rewrite /GRing.scale /= !(mulr0,add0r,mulr1).
  rewrite divff ?lt0r_neq0// opprD addrAC addrA subrr add0r.
  instantiate (df := fun y : R => - (3^-1 * (y + y)) + ln (1 + y)).
  reflexivity.
clear df0.
have y1cc y : y \in `[0, 1] -> 0 < 1 + y.
  rewrite in_itv /= => /andP [] y0 ?.
  by have y1: 0 < 1 + y by apply: (le_lt_trans y0); rewrite ltrDr.
have y1oo y : y \in `]0, 1[ -> 0 < 1 + y by move/subset_itv_oo_cc/y1cc.
have dfge0 y : y \in `]0, 1[ -> 0 <= df y.
  move=> y01.
  have:= y01.
  rewrite /df in_itv /= => /andP [] y0 y1.
  rewrite -lerBlDl opprK add0r -mulr2n -(mulr_natl _ 2) mulrA.
  rewrite [in leLHS](_ : y = 1 + y - 1); last by rewrite addrAC subrr add0r.
  pose iy:= Itv01 (ltW y0) (ltW y1).
  have y1E: 1 + y = @convex.conv _ R^o iy 1 2.
    rewrite convRE /= /onem mulr1 (mulr_natr _ 2) mulr2n.
    by rewrite addrACA (addrC (- y)) subrr addr0.
  rewrite y1E; apply: (le_trans _ (concave_ln _ _ _))=> //.
  rewrite -y1E addrAC subrr add0r convRE ln1 mulr0 add0r /=.
  rewrite mulrC ler_pM// ?(@ltW _ _ 0)// mulrC.
  rewrite ler_pdivrMr//.
  rewrite -[leLHS]expRK -[leRHS]expRK ler_ln ?posrE ?expR_gt0//.
  rewrite expRM/= powR_mulrn ?expR_ge0// lnK ?posrE//.
  rewrite !exprS expr0 mulr1 -!natrM mulnE /=.
  exact/with_interval.exp2_le8_conversion/with_interval.exp2_le8.
apply: (@ger0_derive1_homo R f 0 1 true false).
- by move=> y /y1oo /idf /@ex_derive.
- by move=> y /[dup] /y1oo /idf /@derive_val ->; exact: dfge0.
- by apply: derivable_within_continuous=> y /y1cc /idf /@ex_derive.
- by rewrite bound_itvE.
- exact: subset_itv_oo_cc.
- by have:= x01; rewrite in_itv=> /andP /= [] /ltW.
Qed.

End xlnx_bounding_with_interval.

(* the rest of the sampling theorem including lemmas relying on the Rocq standard library *)
Section sampling_theorem_part2.
Local Open Scope ereal_scope.
Let R := Rdefinitions.R.
Context d (T : measurableType d) (P : probability T R).
Variable p : R.
Hypothesis p01 : (0 <= p <= 1)%R.
Local Open Scope ereal_scope.

(* [Theorem 2.5, Rajani] *)
Theorem bernoulli_trial_inequality2 n (X : n.-tuple (bernoulliRV P p)) (delta : R) :
  let X' := bool_trial_value X in
  let mu := 'E_(\X_n P)[X'] in
  (0 < n)%nat ->
  (0 < delta < 1)%R ->
  (\X_n P) [set i | X' i >= (1 + delta) * fine mu]%R <=
  (expR (- (fine mu * delta ^+ 2) / 3))%:E.
Proof.
move=> X' mu n0 /[dup] delta01 /andP[delta0 _].
apply: (@le_trans _ _ (expR ((delta - (1 + delta) * ln (1 + delta)) * fine mu))%:E).
  rewrite expRM expRB (mulrC _ (ln _)) expRM lnK; last rewrite posrE addr_gt0//.
  exact: bernoulli_trial_inequality1.
apply: (@le_trans _ _ (expR ((delta - (delta + delta ^+ 2 / 3)) * fine mu))%:E).
  rewrite lee_fin ler_expR ler_wpM2r//.
    by rewrite fine_ge0//; apply: expectation_ge0 => t; exact: bernoulli_trial_ge0.
  rewrite lerB//.
  apply: xlnx_lbound_i12.
  by rewrite in_itv /=.
rewrite le_eqVlt; apply/orP; left; apply/eqP; congr (expR _)%:E.
by rewrite opprD addrA subrr add0r mulrC mulrN mulNr mulrA.
Qed.

(* [Corollary 2.7, Rajani] / [Corollary 4.7, MU] *)
Corollary bernoulli_trial_inequality4 n (X : n.-tuple (bernoulliRV P p)) (delta : R) :
  (0 < delta < 1)%R ->
  (0 < n)%nat ->
  (0 < p)%R ->
  let X' := bool_trial_value X in
  let mu := 'E_(\X_n P)[X'] in
  (\X_n P) [set i | `|X' i - fine mu | >=  delta * fine mu]%R <=
  (expR (- (fine mu * delta ^+ 2) / 3)%R *+ 2)%:E.
Proof.
move=> /andP[d0 d1] n0 p0 /=.
set X' := bool_trial_value X.
set mu := 'E_(\X_n P)[X'].
under eq_set => x.
  rewrite ler_normr.
  rewrite lerBrDl opprD opprK -{1}(mul1r (fine mu)) -mulrDl.
  rewrite -lerBDr -(lerN2 (- _)%R) opprK opprB.
  rewrite -{2}(mul1r (fine mu)) -mulrBl.
  rewrite -!lee_fin.
  over.
rewrite /=.
rewrite set_orb.
rewrite measureU; last 3 first.
- rewrite -(@setIidr _ setT [set _ | _]) ?subsetT//.
  apply: emeasurable_fun_le => //.
  apply/measurable_EFinP.
  exact: measurableT_comp.
- rewrite -(@setIidr _ setT [set _ | _]) ?subsetT//.
  apply: emeasurable_fun_le => //.
  apply/measurable_EFinP.
  exact: measurableT_comp.
- rewrite disjoints_subset => x /=.
  rewrite /mem /in_mem/= => X0; apply/negP.
  rewrite -ltNge.
  apply: (@lt_le_trans _ _ _ _ _ _ X0).
  rewrite !EFinM.
  rewrite lte_pmul2r//; first by rewrite lte_fin ltrD2l gt0_cp.
  by rewrite fineK /mu/X' expectation_bernoulli_trial// lte_fin  mulr_gt0 ?ltr0n.
rewrite mulr2n EFinD leeD//=.
- by apply: bernoulli_trial_inequality2; rewrite //d0 d1.
- have d01 : (0 < delta < 1)%R by rewrite d0.
  apply: (le_trans (@bernoulli_trial_inequality3 _ _ _ _ p p01 _ X delta d01)).
  rewrite lee_fin ler_expR !mulNr lerN2.
  rewrite ler_pM//; last by rewrite lef_pV2 ?posrE ?ler_nat.
  rewrite mulr_ge0 ?fine_ge0 ?sqr_ge0//.
  rewrite /mu unlock /expectation integral_ge0// => x _.
  by rewrite /X' lee_fin; exact: bernoulli_trial_ge0.
Qed.

(* [Theorem 3.1, Rajani] / [thm 4.7, MU] *)
Theorem sampling n (X : n.-tuple (bernoulliRV P p)) (theta delta : R) :
  let X' x := (bool_trial_value X x) / n%:R in
  (0 < p)%R ->
  (0 < delta <= 1)%R -> (0 < theta < p)%R -> (0 < n)%nat ->
  (3 / theta ^+ 2 * ln (2 / delta) <= n%:R)%R ->
  (\X_n P) [set i | `| X' i - p | <= theta]%R >= 1 - delta%:E.
Proof.
move=> X' p0 /andP[delta0 delta1] /andP[theta0 thetap] n0 tdn.
have /andP[_ p1] := p01.
set epsilon := theta / p.
have epsilon01 : (0 < epsilon < 1)%R.
  by rewrite /epsilon ?ltr_pdivrMr ?divr_gt0 ?mul1r.
have thetaE : theta = (epsilon * p)%R.
  by rewrite /epsilon -mulrA mulVf ?mulr1// gt_eqF.
have step1 : (\X_n P) [set i | `| X' i - p | >= epsilon * p]%R <=
    ((expR (- (p * n%:R * (epsilon ^+ 2)) / 3)) *+ 2)%:E.
  rewrite [X in (\X_n P) X <= _](_ : _ =
      [set i | `| bool_trial_value X i - p * n%:R | >= epsilon * p * n%:R]%R); last first.
    apply/seteqP; split => [t|t]/=.
      move/(@ler_wpM2r _ n%:R (ler0n _ _)) => /le_trans; apply.
      rewrite -[X in (_ * X)%R](@ger0_norm _ n%:R)// -normrM mulrBl.
      by rewrite -mulrA mulVf ?mulr1// ?gt_eqF ?ltr0n.
    move/(@ler_wpM2r _ n%:R^-1); rewrite invr_ge0// ler0n => /(_ erefl).
    rewrite -(mulrA _ _ n%:R^-1) divff ?mulr1 ?gt_eqF ?ltr0n//.
    move=> /le_trans; apply.
    rewrite -[X in (_ * X)%R](@ger0_norm _ n%:R^-1)// -normrM mulrBl.
    by rewrite -mulrA divff ?mulr1// gt_eqF// ltr0n.
  rewrite -mulrA.
  have -> : (p * n%:R)%R = fine (p * n%:R)%:E by [].
  rewrite -(mulrC _ p) -(expectation_bernoulli_trial p01 X).
  exact: (@bernoulli_trial_inequality4 _ X epsilon).
have step2 : (\X_n P) [set i | `| X' i - p | >= theta]%R <=
    ((expR (- (n%:R * theta ^+ 2) / 3)) *+ 2)%:E.
  rewrite thetaE; move/le_trans : step1; apply.
  rewrite lee_fin ler_wMn2r// ler_expR mulNr lerNl mulNr opprK.
  rewrite -2![in leRHS]mulrA [in leRHS]mulrCA.
  rewrite /epsilon -mulrA mulVf ?gt_eqF// mulr1 -!mulrA !ler_wpM2l ?(ltW theta0)//.
  rewrite mulrCA ler_wpM2l ?(ltW theta0)//.
  rewrite [X in (_ * X)%R]mulrA mulVf ?gt_eqF// -[leLHS]mul1r [in leRHS]mul1r.
  by rewrite ler_wpM2r// invf_ge1.
suff : delta%:E >= (\X_n P) [set i | (`|X' i - p| >=(*NB: this >= in the pdf *) theta)%R].
  rewrite [X in (\X_n P) X <= _ -> _](_ : _ = ~` [set i | (`|X' i - p| < theta)%R]); last first.
    apply/seteqP; split => [t|t]/=.
      by rewrite leNgt => /negP.
    by rewrite ltNge => /negP/negPn.
  have ? : measurable [set i | (`|X' i - p| < theta)%R].
    under eq_set => x do rewrite -lte_fin.
    rewrite -(@setIidr _ setT [set _ | _]) ?subsetT /X'//.
    by apply: emeasurable_fun_lt => //; apply: measurableT_comp => //;
      apply: measurableT_comp => //; apply: measurable_funD => //;
      apply: measurable_funM.
  rewrite probability_setC// lee_subel_addr//.
  rewrite -lee_subel_addl//; last by rewrite fin_num_measure.
  move=> /le_trans; apply.
  rewrite le_measure ?inE//.
    under eq_set => x do rewrite -lee_fin.
    rewrite -(@setIidr _ setT [set _ | _]) ?subsetT /X'//.
    by apply: emeasurable_fun_le => //; apply: measurableT_comp => //;
      apply: measurableT_comp => //; apply: measurable_funD => //;
      apply: measurable_funM.
  by move=> t/= /ltW.
(* NB: last step in the pdf *)
apply: (le_trans step2).
rewrite lee_fin -(mulr_natr _ 2) -ler_pdivlMr//.
rewrite -(@lnK _ (delta / 2)); last by rewrite posrE divr_gt0.
rewrite ler_expR mulNr lerNl -lnV; last by rewrite posrE divr_gt0.
rewrite invf_div ler_pdivlMr// mulrC.
rewrite -ler_pdivrMr; last by rewrite exprn_gt0.
by rewrite mulrAC.
Qed.

End sampling_theorem_part2.
